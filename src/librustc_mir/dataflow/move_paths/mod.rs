// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT
// file at the top-level directory of this distribution and at
// http://rust-lang.org/COPYRIGHT.
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

use rustc::mir::{BasicBlock, Local, Location, Lvalue, Mir};
use rustc::ty::{TyCtxt, ParamEnv};
use rustc::util::nodemap::FxHashMap;

use rustc_data_structures::indexed_vec::{IndexVec};

use self::abs_domain::{AbstractElem, Lift};
use self::builder::MoveDataBuilder;

use std::fmt;
use std::ops::{Index, IndexMut};

/// `MovePath` is a canonicalized representation of a path that is
/// moved or assigned to.
///
/// It follows a tree structure.
///
/// Given `struct X { m: M, n: N }` and `x: X`, moves like `drop x.m;`
/// move *out* of the l-value `x.m`.
///
/// The MovePaths representing `x.m` and `x.n` are siblings (that is,
/// one of them will link to the other via the `next_sibling` field,
/// and the other will have no entry in its `next_sibling` field), and
/// they both have the MovePath representing `x` as their parent.
#[derive(Clone)]
pub struct MovePath<'tcx> {
    pub(crate) next_sibling: Option<MovePathIndex>,
    pub(crate) first_child: Option<MovePathIndex>,
    pub(crate) parent: Option<MovePathIndex>,
    pub(crate) lvalue: Lvalue<'tcx>,
}

impl<'tcx> fmt::Debug for MovePath<'tcx> {
    fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result {
        write!(w, "MovePath {{")?;
        if let Some(parent) = self.parent {
            write!(w, " parent: {:?},", parent)?;
        }
        if let Some(first_child) = self.first_child {
            write!(w, " first_child: {:?},", first_child)?;
        }
        if let Some(next_sibling) = self.next_sibling {
            write!(w, " next_sibling: {:?}", next_sibling)?;
        }
        write!(w, " lvalue: {:?} }}", self.lvalue)
    }
}

impl<'tcx> fmt::Display for MovePath<'tcx> {
    fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result {
        write!(w, "{:?}", self.lvalue)
    }
}

/// `MoveOut` represents a point in a program that moves out of some
/// L-value; i.e., "creates" uninitialized memory.
///
/// With respect to dataflow analysis:
/// - Generated by moves and declaration of uninitialized variables.
/// - Killed by assignments to the memory.
#[derive(Copy, Clone)]
pub struct MoveOut {
    /// path being moved
    pub path: MovePathIndex,
    /// location of move
    pub source: Location,
}

impl fmt::Debug for MoveOut {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        write!(fmt, "{:?}@{:?}", self.path, self.source)
    }
}

pub use super::indexes::{MoveOutIndex, MovePathIndex};

impl MoveOutIndex {
    pub fn move_path_index(&self, move_data: &MoveData) -> MovePathIndex {
        move_data.moves[*self].path
    }
}

pub trait HasMoveData<'tcx> {
    fn move_data(&self) -> &MoveData<'tcx>;
}

#[derive(Debug)]
pub struct MoveData<'tcx> {
    pub move_paths: IndexVec<MovePathIndex, MovePath<'tcx>>,
    pub moves: IndexVec<MoveOutIndex, MoveOut>,
    /// Each Location `l` is mapped to the MoveOut's that are effects
    /// of executing the code at `l`. (There can be multiple MoveOut's
    /// for a given `l` because each MoveOut is associated with one
    /// particular path being moved.)
    pub loc_map: LocationMap<Vec<MoveOutIndex>>,
    pub path_map: IndexVec<MovePathIndex, Vec<MoveOutIndex>>,
    pub rev_lookup: MovePathLookup<'tcx>,
}

#[derive(Debug)]
pub struct LocationMap<T> {
    /// Location-indexed (BasicBlock for outer index, index within BB
    /// for inner index) map.
    pub(crate) map: IndexVec<BasicBlock, Vec<T>>,
}

impl<T> LocationMap<T> {
    pub(crate) fn get(&self, index: Location) -> Option<&T> {
        self.map.get(index.block).and_then(|b| b.get(index.statement_index))
    }
}

impl<T> Index<Location> for LocationMap<T> {
    type Output = T;
    fn index(&self, index: Location) -> &Self::Output {
        &self.map[index.block][index.statement_index]
    }
}

impl<T> IndexMut<Location> for LocationMap<T> {
    fn index_mut(&mut self, index: Location) -> &mut Self::Output {
        &mut self.map[index.block][index.statement_index]
    }
}

impl<T> LocationMap<T> where T: Default + Clone {
    fn new(mir: &Mir) -> Self {
        LocationMap {
            map: mir.basic_blocks().iter().map(|block| {
                vec![T::default(); block.statements.len()+1]
            }).collect()
        }
    }
}

/// Tables mapping from an l-value to its MovePathIndex.
#[derive(Debug)]
pub struct MovePathLookup<'tcx> {
    locals: IndexVec<Local, MovePathIndex>,

    /// projections are made from a base-lvalue and a projection
    /// elem. The base-lvalue will have a unique MovePathIndex; we use
    /// the latter as the index into the outer vector (narrowing
    /// subsequent search so that it is solely relative to that
    /// base-lvalue). For the remaining lookup, we map the projection
    /// elem to the associated MovePathIndex.
    projections: FxHashMap<(MovePathIndex, AbstractElem<'tcx>), MovePathIndex>
}

#[derive(Copy, Clone, Debug)]
pub enum LookupResult {
    Exact(MovePathIndex),
    Parent(Option<MovePathIndex>)
}

impl<'a, 'tcx> MoveData<'tcx> {
    pub fn gather_moves(mir: &Mir<'tcx>,
                        tcx: TyCtxt<'a, 'tcx, 'tcx>,
                        param_env: ParamEnv<'tcx>)
                        -> Self {
        gather_moves(mir, tcx, param_env)
    }
}

fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>,
                          tcx: TyCtxt<'a, 'tcx, 'tcx>,
                          param_env: ParamEnv<'tcx>)
                          -> MoveData<'tcx> {
    let mut builder = MoveDataBuilder::new(mir, tcx, param_env);

    for (bb, block) in mir.basic_blocks().iter_enumerated() {
        for (i, stmt) in block.statements.iter().enumerate() {
            let source = Location { block: bb, statement_index: i };
            builder.gather_statement(source, stmt);
        }

        let terminator_loc = Location {
            block: bb,
            statement_index: block.statements.len()
        };
        builder.gather_terminator(terminator_loc, block.terminator());
    }

    builder.finalize()
}

impl<'tcx> MovePathLookup<'tcx> {
    // Unlike the builder `fn move_path_for` below, this lookup
    // alternative will *not* create a MovePath on the fly for an
    // unknown l-value, but will rather return the nearest available
    // parent.
    pub fn find(&self, lval: &Lvalue<'tcx>) -> LookupResult {
        match *lval {
            Lvalue::Local(local) => LookupResult::Exact(self.locals[local]),
            Lvalue::Static(..) => LookupResult::Parent(None),
            Lvalue::Projection(ref proj) => {
                match self.find(&proj.base) {
                    LookupResult::Exact(base_path) => {
                        match self.projections.get(&(base_path, proj.elem.lift())) {
                            Some(&subpath) => LookupResult::Exact(subpath),
                            None => LookupResult::Parent(Some(base_path))
                        }
                    }
                    inexact => inexact
                }
            }
        }
    }
}

/// The move-analysis portion of borrowck needs to work in an abstract
/// domain of lifted Lvalues.  Most of the Lvalue variants fall into a
/// one-to-one mapping between the concrete and abstract (e.g. a
/// field-deref on a local-variable, `x.field`, has the same meaning
/// in both domains). Indexed-Projections are the exception: `a[x]`
/// needs to be treated as mapping to the same move path as `a[y]` as
/// well as `a[13]`, et cetera.
///
/// (In theory the analysis could be extended to work with sets of
/// paths, so that `a[0]` and `a[13]` could be kept distinct, while
/// `a[x]` would still overlap them both. But that is not this
/// representation does today.)
pub mod abs_domain {
    use rustc::mir::LvalueElem;
    use rustc::mir::{Operand, ProjectionElem};

    #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
    pub struct AbstractOperand;
    pub type AbstractElem<'tcx> =
        ProjectionElem<'tcx, AbstractOperand>;

    pub trait Lift {
        type Abstract;
        fn lift(&self) -> Self::Abstract;
    }
    impl<'tcx> Lift for Operand<'tcx> {
        type Abstract = AbstractOperand;
        fn lift(&self) -> Self::Abstract { AbstractOperand }
    }
    impl<'tcx> Lift for LvalueElem<'tcx> {
        type Abstract = AbstractElem<'tcx>;
        fn lift(&self) -> Self::Abstract {
            match *self {
                ProjectionElem::Deref =>
                    ProjectionElem::Deref,
                ProjectionElem::Field(ref f, ty) =>
                    ProjectionElem::Field(f.clone(), ty.clone()),
                ProjectionElem::Index(ref i) =>
                    ProjectionElem::Index(i.lift()),
                ProjectionElem::Subslice {from, to} =>
                    ProjectionElem::Subslice { from: from, to: to },
                ProjectionElem::ConstantIndex {offset,min_length,from_end} =>
                    ProjectionElem::ConstantIndex {
                        offset: offset,
                        min_length: min_length,
                        from_end: from_end
                    },
                ProjectionElem::Downcast(a, u) =>
                    ProjectionElem::Downcast(a.clone(), u.clone()),
            }
        }
    }
}

mod builder;
