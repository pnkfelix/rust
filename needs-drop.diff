diff --git a/.gitignore b/.gitignore
index 5d5da13..6a1c426 100644
--- a/.gitignore
+++ b/.gitignore
@@ -92,3 +92,6 @@ tmp.*.rs
 version.md
 version.ml
 version.texi
+*.pot
+/*.dot
+/objdir-*
diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..cde2a66
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,87 @@
+FILES_WARN=foo01_warn.rs               foo03_warn.rs foo04_warn.rs foo05_warn.rs \
+           foo06_warn.rs foo07_warn.rs foo08_warn.rs foo09_warn.rs foo10_warn.rs \
+                         foo17_warn.rs foo18_warn.rs                             \
+                                                                   foo25_warn.rs \
+           foo26_warn.rs foo27_warn.rs foo28_warn.rs                             \
+           foo31_warn.rs                                                         \
+                                       foo43_warn.rs                             \
+                                       foo48_warn.rs               foo50_warn.rs \
+                         foo52_warn.rs                                           \
+                                                                                 \
+                         rfc02_warn.rs               rfc04_warn.rs
+
+
+FILES_FINE=              foo02_fine.rs                                           \
+           foo11_fine.rs foo12_fine.rs foo13_fine.rs foo14_fine.rs foo15_fine.rs \
+                                       foo23_fine.rs foo24_fine.rs               \
+                                                     foo29_fine.rs foo30_fine.rs \
+                         foo32_fine.rs foo33_fine.rs foo34_fine.rs               \
+                         foo42_fine.rs               foo44_fine.rs               \
+                         foo47_fine.rs               foo49_fine.rs               \
+                                       foo53_fine.rs foo54_fine.rs foo55_fine.rs \
+                                                                                 \
+           rfc01_fine.rs               rfc03_fine.rs                             \
+           rfc06_fine.rs
+
+FILES_DENY=rfc05_deny.rs
+
+FILES_UNCATEGORIZED=                                                             \
+           foo16.rs                                  foo19.rs      foo20.rs      \
+           foo21.rs      foo22.rs                                                \
+           dlist01.rs \
+           iter1.rs iter2.rs \
+           num01.rs \
+           option01.rs \
+           result01.rs result02.rs result03.rs \
+           str01.rs
+
+FILES=$(FILES_WARN) $(FILES_FINE) $(FILES_DENY) $(FILES_UNCATEGORIZED)
+
+all: $(patsubst %.rs,%.dot,$(FILES))
+.PHONY: touch_fine
+touch_fine:
+	touch *fine.rs
+.PHONY: touch_warn
+touch_warn:
+	touch *warn.rs
+.PHONY: fine
+fine: touch_fine $(patsubst %.rs,%.dot,$(FILES_FINE))
+.PHONY: warn
+warn: touch_warn $(patsubst %.rs,%.dot,$(FILES_WARN))
+
+RUSTC_LIB=$(RUSTC) --crate-type=lib
+
+RUSTC ?= objdir-dbg/x86_64-apple-darwin/stage1/rustc
+
+rwildcard=$(foreach d,$(wildcard $1*),$(call rwildcard,$d/,$2) \
+  $(filter $(subst *,%,$2),$d))
+
+objdir-dbg/x86_64-apple-darwin/stage1/rustc: src/etc/rustc-wrapper.macosx.sh objdir-dbg/x86_64-apple-darwin/stage1/bin/rustc Makefile $(call rwildcard,src/,*.rs)
+	cd objdir-dbg && make-rustc-stage1 --no-libs
+	cp $< $@
+	chmod +x $@
+
+RUST_LOG=rustc::middle::borrowck,rustc::middle::ty,rustc::middle::typeck,rustc::middle::expr_use_visitor,rustc::middle::region,rustc::middle::trans,rustc::middle::resolve,rustc::middle::mem_categorization::rustc::util::common
+
+%.dot: %.rs Makefile objdir-dbg/x86_64-apple-darwin/stage1/rustc
+	$(RUSTC_LIB) -Z flowgraph-print-all --pretty flowgraph=foo $< -o $@
+
+%.pp: %.rs Makefile objdir-dbg/x86_64-apple-darwin/stage1/rustc
+	$(RUSTC_LIB)                        --pretty expanded,identified $< -o $@
+
+%.log: %.rs Makefile objdir-dbg/x86_64-apple-darwin/stage1/rustc
+	RUST_LOG=$(RUST_LOG) RUST_BACKTRACE=1 $(RUSTC_LIB) -Z verbose $< 2> $@
+
+#	RUST_LOG=$(RUST_LOG) $(RUSTC_LIB) -Z flowgraph-print-all --pretty flowgraph=foo $< -o $@.dot 2> $@
+
+foo41.dot: foo41.rs libfoo41_support.rlib
+	RUST_BACKTRACE=1 $(RUSTC_LIB) -L . -Z flowgraph-print-all --pretty flowgraph=foo $< -o $@
+
+foo41: foo41.rs libfoo41_support.rlib
+	RUST_BACKTRACE=1 $(RUSTC_LIB) -L . $<
+
+foo41.llog: foo41.rs libfoo41_support.rlib
+	RUST_LOG=$(RUST_LOG) RUST_BACKTRACE=1 $(RUSTC_LIB) -L . $< 2> $@
+
+libfoo41_support.rlib: foo41_support.rs Makefile objdir-dbg/x86_64-apple-darwin/stage1/rustc
+	objdir-dbg/x86_64-apple-darwin/stage1/bin/rustc  foo41_support.rs --out-dir .
diff --git a/dlist01.rs b/dlist01.rs
new file mode 100644
index 0000000..33ca286
--- /dev/null
+++ b/dlist01.rs
@@ -0,0 +1,69 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+#[lang = "owned_box"]
+#[unstable = "custom allocators will add an additional type parameter (with default)"]
+pub struct Box<T>(*mut T);
+
+mod mem {
+    pub fn replace<T>(_dest: &mut T, mut _src: T) -> T { loop { } }
+}
+
+pub fn drop<T>(_x: T) { }
+
+pub enum Option<T> { None, Some(T), }
+
+impl<T> Option<T> {
+    pub fn take(&mut self) -> Option<T> {
+        mem::replace(self, None)
+    }
+    pub fn map<U>(self, f: |T| -> U) -> Option<U> {
+        match self { Some(x) => Some(f(x)), None => None }
+    }
+}
+
+/// Set the .prev field on `next`, then return `Some(next)`
+fn link_with_prev<T>(mut next: Box<Node<T>>, prev: Rawlink<Node<T>>)
+                  -> Link<T> {
+    next.prev = prev;
+    Some(next)
+}
+
+/// A doubly-linked list.
+pub struct DList<T> {
+    length: uint,
+    list_head: Link<T>,
+    list_tail: Rawlink<Node<T>>,
+}
+
+type Link<T> = Option<Box<Node<T>>>;
+pub struct Rawlink<T>;
+
+pub struct Node<T> {
+    next: Link<T>,
+    prev: Rawlink<Node<T>>,
+}
+
+impl<T> Rawlink<T> {
+    fn none() -> Rawlink<T> {
+        Rawlink
+    }
+}
+
+impl<T> DList<T> {
+    /// Remove the first Node and return it, or None if the list is empty
+    pub fn foo(&mut self) -> Option<Box<Node<T>>> {
+        self.list_head.take().map(|mut front_node| {
+            self.length -= 1;
+            match front_node.next.take() {
+                Some(node) => self.list_head = link_with_prev(node, Rawlink::none()),
+                None => self.list_tail = Rawlink::none()
+            }
+            front_node
+        })
+    }
+}
diff --git a/foo.rs b/foo.rs
new file mode 100644
index 0000000..3918fbd
--- /dev/null
+++ b/foo.rs
@@ -0,0 +1,13 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="sized"] pub trait Sized { }
+
+pub fn foo<T>(b: bool, x: T, f: |T| -> int) -> int {
+    if b {
+        f(x) // Variable x moved in this branch ...
+    } else {
+        3    // ... but not this one ...
+    } // ... thus expect notice at this join-point.
+}
diff --git a/foo01_warn.rs b/foo01_warn.rs
new file mode 100644
index 0000000..e65d1f6
--- /dev/null
+++ b/foo01_warn.rs
@@ -0,0 +1,21 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="sized"] pub trait Sized { }
+
+pub fn foo<T>(b: bool, c: || -> T, f: |T| -> int) -> int {
+    let x = c();
+    //                                                          // NEEDS_DROP={x}
+    let ret = if b {
+    //                                                          // NEEDS_DROP={x}
+        f(x) // Variable x moved in this branch ...
+    //                                                          // NEEDS_DROP={}
+    } else {
+    //                                                          // NEEDS_DROP={x}
+        3    // ... but not this one ...
+    //                                                          // NEEDS_DROP={x}
+    }; // ... thus expect notice at this join-point.
+    c();
+    ret
+}
diff --git a/foo02_fine.rs b/foo02_fine.rs
new file mode 100644
index 0000000..d96d5f0
--- /dev/null
+++ b/foo02_fine.rs
@@ -0,0 +1,23 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub fn foo<T:Copy>(b: bool, c: || -> T, f: |T| -> int) -> int {
+    let x = c();
+    //                                                          // NEEDS_DROP={}
+    let ret = if b {
+    //                                                          // NEEDS_DROP={}
+        f(x) // Variable x copied in this branch ...
+    //                                                          // NEEDS_DROP={}
+    } else {
+    //                                                          // NEEDS_DROP={}
+        3    // ... but not this one ...
+    //                                                          // NEEDS_DROP={}
+    }; // ... but since it is copy, needs-drop = {}.  (Copy and Drop are mutually exclusive)
+    //                                                          // NEEDS_DROP={}
+    c();
+    ret
+}
diff --git a/foo03_warn.rs b/foo03_warn.rs
new file mode 100644
index 0000000..28d0546
--- /dev/null
+++ b/foo03_warn.rs
@@ -0,0 +1,24 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub struct Foo<X,Y> { _x: X, _y: Y }
+
+pub fn foo<X,Y:Copy>(b: bool, c: || -> Foo<X,Y>, f: |X| -> int, _g: |Y| -> int) -> int {
+    let s = c();
+    //                                                          // NEEDS_DROP={s}
+    let ret = if b {
+    //                                                          // NEEDS_DROP={s}
+        f(s._x) // Path s._x moved in this branch ...
+    //                                                          // NEEDS_DROP={}
+    } else {
+    //                                                          // NEEDS_DROP={s}
+        3    // ... but not this one ...
+    //                                                          // NEEDS_DROP={s}
+    }; // ... thus expect notice at this join-point.
+    c();
+    ret
+}
diff --git a/foo04_warn.rs b/foo04_warn.rs
new file mode 100644
index 0000000..07e266a
--- /dev/null
+++ b/foo04_warn.rs
@@ -0,0 +1,26 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub struct Foo<X,Y> { _x: X, _y: Y, _z: X }
+
+pub fn foo<X,Y:Copy>(b: bool, c: || -> Foo<X,Y>, f: |X| -> int) -> int {
+    let mut s = c();
+    //                                                          // NEEDS_DROP={s}
+    s._x = s._z; // s._x assigned here (and s._z moved here).
+    //                                                          // NEEDS_DROP={s._x}
+    let ret = if b {
+        //                                                      // NEEDS_DROP={s._x}
+        f(s._x) // Path s._x moved in this branch ...
+        //                                                      // NEEDS_DROP={}
+    } else {
+        //                                                      // NEEDS_DROP={s._x}
+        3    // ... but not this one ...
+        //                                                      // NEEDS_DROP={s._x}
+    }; // ... thus expect notice at this join-point.
+    c();
+    ret
+}
diff --git a/foo05_warn.rs b/foo05_warn.rs
new file mode 100644
index 0000000..07aff72
--- /dev/null
+++ b/foo05_warn.rs
@@ -0,0 +1,24 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub struct Foo<X,Y> { _x: X, _y: Y, _z: X }
+
+pub fn foo<X,Y:Copy>(b: bool, c: || -> Foo<X,Y>, f: |X| -> int) -> int {
+    let s = c();
+    //                                                          // NEEDS_DROP={s}
+    let ret = if b {
+        //                                                      // NEEDS_DROP={s}
+        f(s._x) // Path s._x moved in this branch ...
+        //                                                      // NEEDS_DROP={s._z}
+    } else {
+        //                                                      // NEEDS_DROP={s}
+        3    // ... but not this one ...
+        //                                                      // NEEDS_DROP={s}
+    }; // ... thus expect notice at this join-point.
+    c();
+    ret
+}
diff --git a/foo06_warn.rs b/foo06_warn.rs
new file mode 100644
index 0000000..08b4623
--- /dev/null
+++ b/foo06_warn.rs
@@ -0,0 +1,26 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub struct Foo<X,Y> { _x: X, _y: Y, _z: X }
+
+pub fn foo<X,Y:Copy>(b: bool, c: || -> Foo<X,Y>, f: |X| -> int, x: X) -> int {
+    let mut s = c();
+    //                                                          // NEEDS_DROP={s, x}
+    s._x = x;
+    //                                                          // NEEDS_DROP={s}
+    let ret = if b {
+        //                                                      // NEEDS_DROP={s}
+        f(s._x) // Path s._x moved in this branch ...
+        //                                                      // NEEDS_DROP={s._z}
+    } else {
+        //                                                      // NEEDS_DROP={s}
+        3    // ... but not this one ...
+        //                                                      // NEEDS_DROP={s}
+    }; // ... thus expect notice at this join-point.
+    c();
+    ret
+}
diff --git a/foo07_warn.rs b/foo07_warn.rs
new file mode 100644
index 0000000..516cba2
--- /dev/null
+++ b/foo07_warn.rs
@@ -0,0 +1,25 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub struct Foo<X,Y> { _x: X, _y: Y, _z: X }
+
+pub fn foo<X,Y:Copy>(b: bool, c: || -> Foo<X,Y>, _f: |X| -> int, x: X) -> int {
+    let mut s = c();
+    //                                                          // NEEDS_DROP={s,x}
+    let ret = if b {
+        //                                                      // NEEDS_DROP={s,x}
+        s._x = x; // `x` moved in this branch
+        //                                                      // NEEDS_DROP={s}
+        4
+    } else {
+        //                                                      // NEEDS_DROP={s,x}
+        3    // ... but not this one ...
+        //                                                      // NEEDS_DROP={s,x}
+    }; // ... thus expect notice at this join-point.
+    c();
+    ret
+}
diff --git a/foo08_warn.rs b/foo08_warn.rs
new file mode 100644
index 0000000..d6b83c9
--- /dev/null
+++ b/foo08_warn.rs
@@ -0,0 +1,29 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub struct Foo<X,Y> { _x: X, _y: Y, _z: X }
+
+pub fn foo<X,Y:Copy>(b: bool, c: || -> Foo<X,Y>, _f: |X| -> int, _g: || -> X) -> int {
+    let mut s = c();
+    //                                                          // NEEDS_DROP={s}
+    _f(s._x);
+    //                                                          // NEEDS_DROP={s._z}
+    _f(s._z);
+    //                                                          // NEEDS_DROP={}
+    // all of `s` is moved away ...
+    let ret = if b {
+        //                                                      // NEEDS_DROP={}
+        s._x = _g(); // but `s._x` is re-established in this branch
+        //                                                      // NEEDS_DROP={s._x}
+        4
+    } else {
+        //                                                      // NEEDS_DROP={}
+        3 // ... but not this one ...
+    }; // ... thus expect notice at this join-point.
+    c();
+    ret
+}
diff --git a/foo09_warn.rs b/foo09_warn.rs
new file mode 100644
index 0000000..be1e7b6
--- /dev/null
+++ b/foo09_warn.rs
@@ -0,0 +1,26 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub struct Foo<X,Y> { _x: X, _y: Y, _z: X, _w: X }
+
+pub fn foo<X,Y:Copy>(b: bool, c: || -> Foo<X,Y>, f: |X| -> int) -> int {
+    let mut s = c();
+    //                                                          // NEEDS_DROP={s}
+    s._x = s._z; // s._x assigned here (and s._z moved here).
+    //                                                          // NEEDS_DROP={s._x}
+    let ret = if b {
+        //                                                      // NEEDS_DROP={s._x}
+        f(s._x) // Path s._x moved in this branch ...
+        //                                                      // NEEDS_DROP={}
+    } else {
+        //                                                      // NEEDS_DROP={s._x}
+        3    // ... but not this one ...
+        //                                                      // NEEDS_DROP={s._x}
+    }; // ... thus expect notice at this join-point.
+    c();
+    ret
+}
diff --git a/foo10_warn.rs b/foo10_warn.rs
new file mode 100644
index 0000000..1e7d10c
--- /dev/null
+++ b/foo10_warn.rs
@@ -0,0 +1,26 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub struct Foo<X,Y> { _x: X, _y: Y, _z: X, _w: X }
+
+pub fn foo<X,Y:Copy>(b: bool, c: || -> Foo<X,Y>, f: |X| -> int) -> int {
+    let mut s = c();
+    //                                                          // NEEDS_DROP={s}
+    s._x = s._z; // s._x assigned here (and s._z moved here).
+    //                                                          // NEEDS_DROP={s._x, s._w}
+    let ret = if b {
+        //                                                      // NEEDS_DROP={s._x, s._w}
+        f(s._x) // Path s._x moved in this branch ...
+        //                                                      // NEEDS_DROP={s._w}
+    } else {
+        //                                                      // NEEDS_DROP={s._x, s._w}
+        3    // ... but not this one ...
+        //                                                      // NEEDS_DROP={s._x, s._w}
+    }; // ... thus expect notice at this join-point.
+    c();
+    ret
+}
diff --git a/foo10a.rs b/foo10a.rs
new file mode 100644
index 0000000..dbd1585
--- /dev/null
+++ b/foo10a.rs
@@ -0,0 +1,17 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub struct Foo<X,Y> { _x: X, _y: Y, _z: X, _w: X }
+
+pub fn foo<X,Y:Copy>(b: bool, mut s: Foo<X,Y>, f: |X| -> int) -> int {
+    s._x = s._z; // s._x assigned here (and s._z moved here).
+    if b {
+        f(s._x) // Path s._x moved in this branch ...
+    } else {
+        3    // ... but not this one ...
+    } // ... thus expect notice at this join-point.
+}
diff --git a/foo11_fine.rs b/foo11_fine.rs
new file mode 100644
index 0000000..ea3c3b1
--- /dev/null
+++ b/foo11_fine.rs
@@ -0,0 +1,27 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub enum Foo<A,B> { Fx(A), Fy(B) }
+
+pub fn foo<X,Y>(c: || -> Foo<X,Y>, f: |X| -> int, g: |Y| -> int) -> int {
+    let s = c();
+    //                                                          // NEEDS_DROP={s}
+    let ret = match s {
+        Fx(x) => {
+    //                                                          // NEEDS_DROP={x}
+            f(x)
+    //                                                          // NEEDS_DROP={}
+        }
+        Fy(y) => {
+    //                                                          // NEEDS_DROP={y}
+            g(y)
+    //                                                          // NEEDS_DROP={}
+        }
+    }; // ... this should be fine.
+    c();
+    ret
+}
diff --git a/foo12_fine.rs b/foo12_fine.rs
new file mode 100644
index 0000000..ceda294
--- /dev/null
+++ b/foo12_fine.rs
@@ -0,0 +1,27 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub enum Foo<A,B> { Fx(A), Fy(B) }
+
+pub fn foo<X,Y:Copy>(c: || -> Foo<X,Y>, f: |X| -> int, g: |Y| -> int) -> int {
+    let s = c();
+    //                                                          // NEEDS_DROP={s}
+    let ret = match s {
+        Fx(x) => {
+    //                                                          // NEEDS_DROP={x}
+            f(x)
+    //                                                          // NEEDS_DROP={}
+        }
+        Fy(y) => {
+    //                                                          // NEEDS_DROP={}
+            g(y)
+    //                                                          // NEEDS_DROP={}
+        }
+    }; // ... this should be fine.
+    c();
+    ret
+}
diff --git a/foo13_fine.rs b/foo13_fine.rs
new file mode 100644
index 0000000..995b452
--- /dev/null
+++ b/foo13_fine.rs
@@ -0,0 +1,38 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub fn drop<T>(_x: T) { }
+
+pub enum Foo<A,B> { Fx(A), Fy(B) }
+
+pub fn foo<X,Y:Copy>(b: || -> bool,
+                     c: || -> Foo<X,Y>,
+                     f: |X| -> int,
+                     g: |Y| -> int) -> int {
+    let s = c();
+    //                                                          // NEEDS_DROP={s}
+    let ret = match s {
+        Fx(_) if b() => {
+    //                                                          // NEEDS_DROP={s}
+            drop(s);
+    //                                                          // NEEDS_DROP={}
+            3
+        }
+        Fx(x) => {
+    //                                                          // NEEDS_DROP={x}
+            f(x)
+    //                                                          // NEEDS_DROP={}
+        }
+        Fy(y) => {
+    //                                                          // NEEDS_DROP={}
+            g(y)
+    //                                                          // NEEDS_DROP={}
+        }
+    }; // ... this should be fine"
+    c();
+    ret
+}
diff --git a/foo14_fine.rs b/foo14_fine.rs
new file mode 100644
index 0000000..beb3569
--- /dev/null
+++ b/foo14_fine.rs
@@ -0,0 +1,22 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub enum Foo<A> { Fx(A) }
+
+pub fn foo<X>(c: || -> Foo<X>, f: |X| -> int) -> int {
+    let s = c();
+    //                                                          // NEEDS_DROP={s}
+    let ret = match s {
+        Fx(x) => {
+    //                                                          // NEEDS_DROP={x}
+            f(x)
+    //                                                          // NEEDS_DROP={}
+        }
+    }; // ... this should be fine.
+    c();
+    ret
+}
diff --git a/foo15_fine.rs b/foo15_fine.rs
new file mode 100644
index 0000000..d55bef2
--- /dev/null
+++ b/foo15_fine.rs
@@ -0,0 +1,34 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub fn drop<T>(_x: T) { }
+
+pub enum Option<T> { None, Some(T), }
+
+pub struct Cell<T> {
+    value: T,
+}
+
+/// Remove the first Node and return it, or None if the list is empty
+pub fn foo<T>(self_: &mut Cell<T>,
+              taken: Option<T>) {
+    let f = |front_node: Option<T>| {
+    //                                                          // NEEDS_DROP={front_node}
+        match front_node { // by-move match consumes front_node ...
+            Some(node) => {
+    //                                                          // NEEDS_DROP={node}
+                self_.value = node
+    //                                                          // NEEDS_DROP={}
+            }
+            None => {
+    //                                                          // NEEDS_DROP={}
+            }
+        } // ... this should be fine
+    };
+
+    f(taken)
+}
diff --git a/foo16.rs b/foo16.rs
new file mode 100644
index 0000000..2d59796
--- /dev/null
+++ b/foo16.rs
@@ -0,0 +1,46 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+#[lang="send"]  pub trait Send { }
+
+
+/// A type that represents a uniquely-owned value.
+#[lang = "owned_box"]
+#[unstable = "custom allocators will add an additional type parameter (with default)"]
+pub struct Box<T>(*mut T);
+
+pub trait Writer { }
+
+pub fn drop<T>(_x: T) { }
+
+pub enum Option<T> { None, Some(T), }
+
+pub fn set_stderr(_stderr: Box<Writer + Send>) -> Option<Box<Writer + Send>> {
+    loop { }
+}
+
+/// Remove the first Node and return it, or None if the list is empty
+pub fn foo<T>() {
+    // a snippet taken from rustdoc::test::runtest
+
+    struct ChanWriter;
+    impl Writer for ChanWriter {}
+    let w1 = ChanWriter;
+    let old = set_stderr(box w1);
+
+    let my_proc = proc() {
+        match old {
+            Some(old) => {
+                // Chop off the `Send` bound.
+                let old : Box<Writer> = old;
+                old
+            }
+            None => loop { }
+        };
+        loop { }
+    };
+    my_proc()
+}
diff --git a/foo17_warn.rs b/foo17_warn.rs
new file mode 100644
index 0000000..208cd19
--- /dev/null
+++ b/foo17_warn.rs
@@ -0,0 +1,40 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub struct Foo<X,Y> { _x: X, _y: Y, _z: X, _w: X }
+
+pub fn foo<X,Y>(b: || -> bool, c: || -> Foo<X,Y>, f: |Foo<X,Y>| -> i8) -> i8 {
+    //                                                       // NEEDS_DROP={}
+    let s = c();
+    //                                                       // NEEDS_DROP={s}
+    let ret = if !b() {
+        //                                                   // NEEDS_DROP={s}
+        f(s) // s moved in this branch ...
+            //                                               // NEEDS_DROP={}
+    } else {
+        //                                                   // NEEDS_DROP={s}
+        if b() {
+            //                                               // NEEDS_DROP={s}
+            f(s) // s moved in this branch ...
+            //                                               // NEEDS_DROP={}
+        } else {
+            //                                               // NEEDS_DROP={s}
+            3    // ... but not this one ...
+        } // ... thus expect notice at this join-point ...
+        // ... but what about the outer merge point ...
+        //                                                   // NEEDS_DROP=merge({}, {s})
+        // ... we need to choose some value for NEEDS_DROP ...
+        // ... we could use union (A | B) ...
+        // ... but instead we choose intersection ...
+        //                                                   //      ...  = {} & {s}
+        // ... (see extensive discussion of why in impl
+        // BitwiseOperator for NeedsDropDataFlowOperator) ...
+        //                                                   //      ...  = {}
+    }; // ... thus do *not* expect notice at this joint point.
+    c();
+    ret
+}
diff --git a/foo18_warn.rs b/foo18_warn.rs
new file mode 100644
index 0000000..4d45829
--- /dev/null
+++ b/foo18_warn.rs
@@ -0,0 +1,41 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub struct Foo<X,Y> { _x: X, _y: Y, _z: X, _w: X }
+
+pub fn foo<X,Y>(b: || -> bool, c: || -> Foo<X,Y>, f: |Foo<X,Y>| -> i8) -> i8 {
+    //                                                       // NEEDS_DROP={}
+    let s = c();
+    //                                                       // NEEDS_DROP={s}
+    let ret = if !b() {
+        //                                                   // NEEDS_DROP={s}
+        2 // s not moved in this branch ...
+            //                                               // NEEDS_DROP={s}
+    } else {
+        //                                                   // NEEDS_DROP={s}
+        if b() {
+            //                                               // NEEDS_DROP={s}
+            f(s) // s moved in this branch ...
+            //                                               // NEEDS_DROP={}
+        } else {
+            //                                               // NEEDS_DROP={s}
+            3    // ... but not this one ...
+        } // ... thus expect notice at this join-point ...
+
+        // ... but what about the outer join-point ...
+        //                                                   // NEEDS_DROP=merge({}, {s})
+        // ... we need to choose some value for NEEDS_DROP ...
+        // ... we could use union (A | B) ...
+        // ... but instead we choose intersection ...
+        //                                                   //      ...  = {} & {s}
+        // ... (see extensive discussion of why in impl
+        // BitwiseOperator for NeedsDropDataFlowOperator) ...
+        //                                                   //      ...  = {}
+    }; // ... thus expect 2nd notice at this join-point.
+    c();
+    ret
+}
diff --git a/foo19.rs b/foo19.rs
new file mode 100644
index 0000000..2575ffd
--- /dev/null
+++ b/foo19.rs
@@ -0,0 +1,29 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub enum Pairy<X,Y,Z> { Two(X,Y), One(Z), None }
+
+pub fn foo<A,B:Copy>(c: || -> Pairy<(A,A),bool,B>,
+                     dA: |A| -> i8,
+                     dB: |B| -> i8) -> i8 {
+    let s = c();
+    let ret = match s {
+        Two((a1,a2), true) => dA(a1) + dA(a2),
+
+        Two((_,a2), false) => dA(a2),
+                            // this is an example of `_` being an
+                            // "autodrop", since user could not write
+                            // the drop themselves except by binding
+                            // it to name, which would be a misfeature
+                            // in the language.
+
+        One(b) => dB(b),
+        None => 5,
+    };
+    c();
+    ret
+}
diff --git a/foo20.rs b/foo20.rs
new file mode 100644
index 0000000..9c50bd2
--- /dev/null
+++ b/foo20.rs
@@ -0,0 +1,12 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub fn foo<X>(t: &(i8, X)) -> i8 {
+    let &(a, _) = t;
+    let &(b, _) = t;
+    a + b
+}
diff --git a/foo21.rs b/foo21.rs
new file mode 100644
index 0000000..3510c1d
--- /dev/null
+++ b/foo21.rs
@@ -0,0 +1,19 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub enum Result<T,E> { Ok(T), Err(E) }
+
+pub fn foo<X,Y>(c: || -> Result<X,Y>,
+                x: |X| -> Result<X,Y>) -> Result<X,Y> {
+    let s = c();
+    let ret = match s {
+        Err(_) => s,
+        Ok(content) => x(content),
+    };
+    c();
+    ret
+}
diff --git a/foo22.rs b/foo22.rs
new file mode 100644
index 0000000..c417d84
--- /dev/null
+++ b/foo22.rs
@@ -0,0 +1,34 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub fn foo<X>(b: || -> bool,
+              c: || -> X,
+              d: |X| -> i8) -> i8 {
+    let mut count = d(c());
+    while count > 0 {
+        count -= 1;
+        let s_loop = c();
+        if b() {
+            d(s_loop);
+        }
+    }
+
+    let s_return = c();
+    if b() {
+        if b() {
+            d(s_return)
+        } else {
+            3
+        }
+    } else {
+        return if b() { // TODO: Stlll not handling this right
+            d(s_return)
+        } else {
+            3
+        };
+    }
+}
diff --git a/foo23_fine.rs b/foo23_fine.rs
new file mode 100644
index 0000000..8ec2fba
--- /dev/null
+++ b/foo23_fine.rs
@@ -0,0 +1,35 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+mod marker {
+    #[lang="no_send_bound"]
+    pub struct NoSend;
+}
+
+#[lang="gc"]
+pub struct Gc<T> {
+    _ptr: *mut T,
+    marker: marker::NoSend,
+}
+
+pub fn foo<T:Copy>(b: bool, c: || -> Gc<T>, f: |Gc<T>| -> int) -> int {
+    let x = c();
+    //                                                          // NEEDS_DROP={}
+    let ret = if b {
+    //                                                          // NEEDS_DROP={}
+        f(x) // Variable x copied in this branch ...
+    //                                                          // NEEDS_DROP={}
+    } else {
+    //                                                          // NEEDS_DROP={}
+        3    // ... but not this one ...
+    //                                                          // NEEDS_DROP={}
+    }; // ... but since it is Gc<T>, needs-drop = {}.
+    //        (Gc should not impose drop obligation)
+    //                                                          // NEEDS_DROP={}
+    c();
+    ret
+}
diff --git a/foo24_fine.rs b/foo24_fine.rs
new file mode 100644
index 0000000..f8d5484
--- /dev/null
+++ b/foo24_fine.rs
@@ -0,0 +1,36 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+mod marker {
+    #[lang="no_send_bound"]
+    pub struct NoSend;
+}
+
+#[lang="gc"]
+pub struct Gc<T> {
+    _ptr: *mut T,
+    marker: marker::NoSend,
+}
+
+pub fn foo<T>(b: bool, c: || -> Gc<T>, f: |Gc<T>| -> int) -> int {
+    let x = c();
+    //                                                          // NEEDS_DROP={}
+    let ret = if b {
+    //                                                          // NEEDS_DROP={}
+        f(x) // Variable x copied in this branch ...
+    //                                                          // NEEDS_DROP={}
+    } else {
+    //                                                          // NEEDS_DROP={}
+        3    // ... but not this one ...
+    //                                                          // NEEDS_DROP={}
+    }; // ... but since it is Gc<T>, needs-drop = {}.
+    //        (Gc should not impose drop obligation, even
+    //         when T itself may need drop-glue.)
+    //                                                          // NEEDS_DROP={}
+    c();
+    ret
+}
diff --git a/foo25_warn.rs b/foo25_warn.rs
new file mode 100644
index 0000000..ab1984f
--- /dev/null
+++ b/foo25_warn.rs
@@ -0,0 +1,29 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+#[lang="send"]  pub trait Send { }
+
+
+/// A type that represents a uniquely-owned value.
+#[lang = "owned_box"]
+pub struct Box<T>(*mut T);
+
+pub fn foo<T>(b: bool, c: || -> Box<T>, f: |Box<T>| -> int) -> int {
+    let x = c();
+    //                                                          // NEEDS_DROP={x}
+    let ret = if b {
+    //                                                          // NEEDS_DROP={x}
+        f(x) // Variable x copied in this branch ...
+    //                                                          // NEEDS_DROP={}
+    } else {
+    //                                                          // NEEDS_DROP={x}
+        3    // ... but not this one ...
+    //                                                          // NEEDS_DROP={x}
+    }; // ... thus expect notice at this join-point.
+    //                                                          // NEEDS_DROP={}
+    c();
+    ret
+}
diff --git a/foo26_warn.rs b/foo26_warn.rs
new file mode 100644
index 0000000..fb738a4
--- /dev/null
+++ b/foo26_warn.rs
@@ -0,0 +1,31 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+#[lang="send"]  pub trait Send { }
+
+
+/// A type that represents a uniquely-owned value.
+#[lang = "owned_box"]
+pub struct Box<T>(*mut T);
+
+pub struct Foo<X,Y> { _x: X, _y: Y }
+
+pub fn foo<T>(b: bool, c: || -> Foo<Box<T>,T>, f: |Box<T>| -> int) -> int {
+    let s = c();
+    //                                                          // NEEDS_DROP={s}
+    let ret = if b {
+    //                                                          // NEEDS_DROP={s}
+        f(s._x) // Path s._x moved in this branch ...
+    //                                                          // NEEDS_DROP={s._y}
+    } else {
+    //                                                          // NEEDS_DROP={s}
+        3    // ... but not this one ...
+    //                                                          // NEEDS_DROP={s}
+    }; // ... thus expect notice at this join-point.
+    //                                                          // NEEDS_DROP={}
+    c();
+    ret
+}
diff --git a/foo27_warn.rs b/foo27_warn.rs
new file mode 100644
index 0000000..7c13054
--- /dev/null
+++ b/foo27_warn.rs
@@ -0,0 +1,31 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+#[lang="send"]  pub trait Send { }
+
+
+/// A type that represents a uniquely-owned value.
+#[lang = "owned_box"]
+pub struct Box<T>(*mut T);
+
+pub struct Foo<X,Y> { _x: X, _y: Y }
+
+pub fn foo<T>(b: bool, c: || -> Foo<Box<T>,T>, f: |T| -> int) -> int {
+    let s = c();
+    //                                                          // NEEDS_DROP={s}
+    let ret = if b {
+    //                                                          // NEEDS_DROP={s}
+        f(s._y) // Path s._y moved in this branch ...
+    //                                                          // NEEDS_DROP={s._x}
+    } else {
+    //                                                          // NEEDS_DROP={s}
+        3    // ... but not this one ...
+    //                                                          // NEEDS_DROP={s}
+    }; // ... thus expect notice at this join-point.
+    //                                                          // NEEDS_DROP={}
+    c();
+    ret
+}
diff --git a/foo28_warn.rs b/foo28_warn.rs
new file mode 100644
index 0000000..e975d1b
--- /dev/null
+++ b/foo28_warn.rs
@@ -0,0 +1,31 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+#[lang="send"]  pub trait Send { }
+
+
+/// A type that represents a uniquely-owned value.
+#[lang = "owned_box"]
+pub struct Box<T>(*mut T);
+
+pub struct Foo<X,Y> { _x: X, _y: Y }
+
+pub fn foo<T>(b: bool, c: || -> Foo<Box<T>,T>, f: |T| -> int) -> int {
+    let s = c();
+    //                                                          // NEEDS_DROP={s}
+    let ret = if b {
+    //                                                          // NEEDS_DROP={s}
+        f(*s._x) // Path s._x consumed in this branch ...
+    //                                                          // NEEDS_DROP={s._y}
+    } else {
+    //                                                          // NEEDS_DROP={s}
+        3    // ... but not this one ...
+    //                                                          // NEEDS_DROP={s}
+    }; // ... thus expect notice at this join-point.
+    //                                                          // NEEDS_DROP={}
+    c();
+    ret
+}
diff --git a/foo29_fine.rs b/foo29_fine.rs
new file mode 100644
index 0000000..8b3a1c2
--- /dev/null
+++ b/foo29_fine.rs
@@ -0,0 +1,40 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub enum Option<T> { None, Some(T), }
+
+mod marker {
+    #[lang="no_send_bound"]
+    pub struct NoSend;
+}
+
+#[lang="gc"]
+pub struct Gc<T> {
+    _ptr: *mut T,
+    marker: marker::NoSend,
+}
+
+pub fn foo<T>(c: || -> Option<Gc<T>>, f: |Gc<T>| -> int) -> int {
+    let s = c();
+    //                                                          // NEEDS_DROP={}
+    let ret = match s {
+        //                                                      // NEEDS_DROP={}
+        Some(x) => {  // Variable s moved in this branch ...
+            f(x)
+                //                                              // NEEDS_DROP={}
+        }
+        None => {     // ... but not this one ...
+            3
+                //                                              // NEEDS_DROP={}
+        }
+    }; // ... but since it is Gc<T>, needs-drop = {}.
+    //        (Gc should not impose drop obligation, even
+    //         when T itself may need drop-glue.)
+    //                                                          // NEEDS_DROP={}
+    c();
+    ret
+}
diff --git a/foo30_fine.rs b/foo30_fine.rs
new file mode 100644
index 0000000..25c012a
--- /dev/null
+++ b/foo30_fine.rs
@@ -0,0 +1,26 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub fn foo<X>(c: || -> (X,u8), f: |X| -> i8) -> i8 {
+    let s = c();
+    //                                                          // NEEDS_DROP={s}
+    let ret = match s {
+        (b, 0) |
+        (b, 1) => {
+            //                                                  // NEEDS_DROP={b}
+            f(b) + 2
+                //                                              // NEEDS_DROP={}
+        }
+        (b, _) => {
+            //                                                  // NEEDS_DROP={b}
+            f(b) + 3
+            //                                                  // NEEDS_DROP={}
+        }
+    }; // ... this should be fine.
+    c();
+    ret
+}
diff --git a/foo31_warn.rs b/foo31_warn.rs
new file mode 100644
index 0000000..ead87b6
--- /dev/null
+++ b/foo31_warn.rs
@@ -0,0 +1,31 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+#[lang="send"]  pub trait Send { }
+
+
+/// A type that represents a uniquely-owned value.
+#[lang = "owned_box"]
+pub struct Box<T>(*mut T);
+
+pub struct Foo<X,Y> { _x: X, _y: Y }
+
+pub fn foo<T>(b: bool, c: || -> Foo<Box<Foo<T,T>>,T>, f: |T| -> int) -> int {
+    let s = c();
+    //                                                          // NEEDS_DROP={s}
+    let ret = if b {
+    //                                                          // NEEDS_DROP={s}
+        f(s._x._y) // Path s._x._y consumed in this branch ...
+    //                                                          // NEEDS_DROP={s._y, s._x._x}
+    } else {
+    //                                                          // NEEDS_DROP={s}
+        f(s._y)    // ... but not this one ...
+    //                                                          // NEEDS_DROP={s._x}
+    }; // ... thus expect notice at this join-point.
+    //                                                          // NEEDS_DROP={}
+    c();
+    ret
+}
diff --git a/foo32_fine.rs b/foo32_fine.rs
new file mode 100644
index 0000000..e8c1db7
--- /dev/null
+++ b/foo32_fine.rs
@@ -0,0 +1,21 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub enum Pairy<X,Y,Z> { Two(X,Y), One(Z), None }
+
+pub fn foo<A,B:Copy>(c: || -> Pairy<(A,A),bool,B>,
+                     dA: |A| -> i8,
+                     dB: |B| -> i8) -> i8 {
+    let s = c();
+    let ret = match s {
+        Two((a1,a2), _) => dA(a1) + dA(a2),
+        One(b) => dB(b),
+        None => 5,
+    };
+    c();
+    ret
+}
diff --git a/foo33_fine.rs b/foo33_fine.rs
new file mode 100644
index 0000000..912b612
--- /dev/null
+++ b/foo33_fine.rs
@@ -0,0 +1,41 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="sized"] pub trait Sized { }
+
+#[lang = "owned_box"]
+pub struct Box<T>(*mut T);
+pub enum Option<T> { None, Some(T), }
+
+pub static SIZE: uint = 2;
+
+
+pub struct TrieNode<T> {
+    _count: uint,
+    children: [Child<T>, ..SIZE],
+}
+
+pub enum Child<T> {
+    Internal(Box<TrieNode<T>>),
+    External(uint, T),
+    Nothing
+}
+
+pub fn foo<'a, T>(node_orig: &'a TrieNode<T>, idx: uint) -> Option<&'a T> {
+    let mut idx = idx;
+    let mut node = node_orig;
+    loop {
+        match node.children[idx] {
+            Internal(ref x) => node = &**x,
+            External(stored, ref value) =>
+                if stored == idx {
+                    return Some(value)
+                } else {
+                    return None
+                },
+            Nothing => return None,
+        }
+        idx += 1;
+    }
+}
diff --git a/foo34_fine.rs b/foo34_fine.rs
new file mode 100644
index 0000000..66254e2
--- /dev/null
+++ b/foo34_fine.rs
@@ -0,0 +1,41 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="sized"] pub trait Sized { }
+
+#[lang = "owned_box"]
+pub struct Box<T>(*mut T);
+pub enum Option<T> { None, Some(T), }
+
+pub static SIZE: uint = 2;
+
+
+pub struct TrieNode<'a,T> {
+    _count: uint,
+    children: &'a [Child<'a,T>],
+}
+
+pub enum Child<'a,T> {
+    Internal(Box<TrieNode<'a,T>>),
+    External(uint, T),
+    Nothing
+}
+
+pub fn foo<'a, T>(node_orig: &'a TrieNode<'a,T>, idx: uint) -> Option<&'a T> {
+    let mut idx = idx;
+    let mut node = node_orig;
+    loop {
+        match node.children[idx] {
+            Internal(ref x) => node = &**x,
+            External(stored, ref value) =>
+                if stored == idx {
+                    return Some(value)
+                } else {
+                    return None
+                },
+            Nothing => return None,
+        }
+        idx += 1;
+    }
+}
diff --git a/foo35_fine.rs b/foo35_fine.rs
new file mode 100644
index 0000000..6e764f8
--- /dev/null
+++ b/foo35_fine.rs
@@ -0,0 +1,47 @@
+#![feature(intrinsics)]
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="sized"] pub trait Sized { }
+
+#[lang = "owned_box"]
+pub struct Box<T>(*mut T);
+pub enum Option<T> { None, Some(T), }
+
+pub static SIZE: uint = 2;
+
+
+pub struct TrieNode<'a,T> {
+    _count: uint,
+    children: &'a [Child<'a,T>],
+}
+
+pub enum Child<'a,T> {
+    Internal(Box<TrieNode<'a,T>>),
+    External(uint, T),
+    Nothing
+}
+
+extern "rust-intrinsic" {
+    pub fn transmute<T,U>(e: T) -> U;
+}
+
+// This was an attempt to capture another ICE from trie.rs back when
+// the LpInterior(Element(_)) cases in `LoanPath::to_type` did not
+// fall through to the second case properly. But I am not sure I ever
+// actually saw the problem manifest itself on this narrowed test case
+// (As in, do not stress about trying to incorporate this test as is.)
+pub fn foo<'a, T>(node_orig: *mut TrieNode<T>, idx: uint) -> Option<&'a T> {
+    let mut idx = idx;
+    let mut node = node_orig;
+    loop {
+        let children = unsafe { &mut (*node).children };
+        match children[idx] {
+            Internal(ref x) => node = unsafe { transmute(&**x) },
+            External(_stored, _) => return None,
+            Nothing => return None,
+        }
+        idx += 1;
+    }
+}
diff --git a/foo36.rs b/foo36.rs
new file mode 100644
index 0000000..ac20f3f
--- /dev/null
+++ b/foo36.rs
@@ -0,0 +1,79 @@
+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT
+// file at the top-level directory of this distribution and at
+// http://rust-lang.org/COPYRIGHT.
+//
+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
+// option. This file may not be copied, modified, or distributed
+// except according to those terms.
+
+#![feature(struct_variant)]
+#![feature(lang_items)]
+
+#![no_std]
+#![crate_type="lib"]
+
+#![allow(unused_variable)]
+#![allow(non_camel_case_types)]
+
+#[lang = "owned_box"]
+pub struct Box<T>(*mut T);
+
+#[lang="exchange_free"]
+unsafe fn exchange_free(ptr: *mut u8, size: uint, align: uint) {
+    loop { }
+}
+
+mod marker {
+    #[lang="no_copy_bound"]
+    pub struct NoCopy;
+}
+
+struct Foo {
+    x: uint,
+    b: bool,
+    marker: marker::NoCopy
+}
+
+fn field_read(f: Foo) -> uint {
+    f.x * f.x
+}
+
+enum XYZ {
+    X,
+    Y {
+        b: i64,
+        c: Box<char>,
+    },
+    Z
+}
+
+fn field_match_in_patterns(b: XYZ) -> Box<char> {
+    match b {
+        Y { c: c, .. } => c,
+        _ => box 'c'
+    }
+}
+
+struct Bar {
+    x: uint,
+    b: bool,
+}
+
+#[repr(C)]
+struct Baz {
+    x: u32,
+}
+
+fn field_match_in_let(f: Bar) -> bool {
+    let Bar { b, .. } = f;
+    b
+}
+
+pub fn foo() {
+    field_read(Foo { x: 1, b: false, marker: marker::NoCopy });
+    field_match_in_patterns(X);
+    field_match_in_let(Bar { x: 42u, b: true });
+    let _ = Baz { x: 0 };
+}
diff --git a/foo37.rs b/foo37.rs
new file mode 100644
index 0000000..3d84ce7
--- /dev/null
+++ b/foo37.rs
@@ -0,0 +1,88 @@
+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT
+// file at the top-level directory of this distribution and at
+// http://rust-lang.org/COPYRIGHT.
+//
+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
+// option. This file may not be copied, modified, or distributed
+// except according to those terms.
+
+#![feature(struct_variant)]
+#![feature(lang_items)]
+
+#![no_std]
+#![crate_type="lib"]
+
+#![allow(unused_variable)]
+#![allow(non_camel_case_types)]
+
+#[lang = "owned_box"]
+pub struct Box<T>(*mut T);
+
+#[lang="exchange_malloc"]
+#[inline]
+unsafe fn exchange_malloc(size: uint, align: uint) -> *mut u8 {
+    loop { }
+}
+
+#[lang="exchange_free"]
+unsafe fn exchange_free(ptr: *mut u8, size: uint, align: uint) {
+    loop { }
+}
+
+mod marker {
+    #[lang="no_copy_bound"]
+    pub struct NoCopy;
+}
+
+struct Foo {
+    x: uint,
+    b: bool,
+    marker: marker::NoCopy
+}
+
+fn field_read(f: Foo) -> uint {
+    f.x * f.x
+}
+
+enum XYZ {
+    X,
+    Y {
+        b: i64,
+        c: Box<char>,
+    },
+    Z {
+        b: i32,
+        c: Box<char>,
+    },
+}
+
+fn field_match_in_patterns(b: XYZ) -> Box<char> {
+    match b {
+        Y { c: c, .. } => c,
+        _ => box 'c'
+    }
+}
+
+struct Bar {
+    x: uint,
+    b: bool,
+}
+
+#[repr(C)]
+struct Baz {
+    x: u32,
+}
+
+fn field_match_in_let(f: Bar) -> bool {
+    let Bar { b, .. } = f;
+    b
+}
+
+pub fn foo() {
+    field_read(Foo { x: 1, b: false, marker: marker::NoCopy });
+    field_match_in_patterns(X);
+    field_match_in_let(Bar { x: 42u, b: true });
+    let _ = Baz { x: 0 };
+}
diff --git a/foo38.rs b/foo38.rs
new file mode 100644
index 0000000..2d59048
--- /dev/null
+++ b/foo38.rs
@@ -0,0 +1,39 @@
+#![feature(intrinsics)]
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="sized"] pub trait Sized { }
+
+#[lang = "owned_box"]
+pub struct Box<T>(*mut T);
+pub enum Option<T> { None, Some(T), }
+
+// Attempting to recreate warning for 
+//   src/libcollections/trie.rs:344:48: 350:26
+//     error: Storage at `(children[..]->trie::External)` is left ...
+// which seems to be falsely arising, since there should not be a
+// move occurring in this case, since the pattern is of the form
+// `External(stored, _)`, and stored is an int (i.e. :Copy), so the
+// whole thing should be pass by copy, with no drop obligation.
+
+pub struct TrieNode<'a,T> {
+    children: &'a [Child<'a,T>],
+}
+
+pub enum Child<'a,T> {
+    Internal(Box<TrieNode<'a,T>>),
+    External(uint, T),
+}
+
+pub fn foo<'a, T>(node_orig: *mut TrieNode<T>, idx: uint) {
+    let mut _node = node_orig;
+    let children = unsafe { &mut (*_node).children };
+    match children[idx] {
+        Internal(ref _x) => {}
+        External(_stored, _) => {}
+    }
+    no_op();
+}
+
+fn no_op() { }
diff --git a/foo39.rs b/foo39.rs
new file mode 100644
index 0000000..a29ed9a
--- /dev/null
+++ b/foo39.rs
@@ -0,0 +1,17 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub enum Result<T,E> { Ok(T), Err(E) }
+
+pub fn foo<X,Y>(c: || -> Result<X,Y>) -> Result<X,Y> {
+    let s = c();
+    let ret = match s {
+        s @ Err(_) | s @ Ok(_) => s,
+    };
+    c();
+    ret
+}
diff --git a/foo40.rs b/foo40.rs
new file mode 100644
index 0000000..a29ed9a
--- /dev/null
+++ b/foo40.rs
@@ -0,0 +1,17 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub enum Result<T,E> { Ok(T), Err(E) }
+
+pub fn foo<X,Y>(c: || -> Result<X,Y>) -> Result<X,Y> {
+    let s = c();
+    let ret = match s {
+        s @ Err(_) | s @ Ok(_) => s,
+    };
+    c();
+    ret
+}
diff --git a/foo41.rs b/foo41.rs
new file mode 100644
index 0000000..c5a0c06
--- /dev/null
+++ b/foo41.rs
@@ -0,0 +1,21 @@
+#![feature(lang_items)]
+#![feature(macro_rules)]
+#![feature(phase)]
+#![no_std]
+#![crate_type="lib"]
+
+#[phase(plugin)]
+extern crate foo41_support;
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+
+pub fn foo() {
+    let a1 = box 3i;
+    let a2 = box 4i;
+    let b = debug_or!(proc(x:int)x+*a1,proc(y:int)y+*a2);
+    let _c = b(1);
+}
+
+pub fn main() { foo() }
diff --git a/foo41_support.rs b/foo41_support.rs
new file mode 100644
index 0000000..0324dbd
--- /dev/null
+++ b/foo41_support.rs
@@ -0,0 +1,12 @@
+#![feature(lang_items)]
+#![feature(macro_rules)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+#[macro_export]
+macro_rules! debug_or(
+    ($arg1:expr, $arg2:expr) => (if cfg!(not(ndebug)) { $arg1 } else { $arg2 })
+)
diff --git a/foo42_fine.rs b/foo42_fine.rs
new file mode 100644
index 0000000..32ed6d2
--- /dev/null
+++ b/foo42_fine.rs
@@ -0,0 +1,30 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+#[lang="drop"] pub trait Drop { fn drop(&mut self); }
+
+pub struct Foo<X,Y> { _x: X, _y: Y }
+
+#[quiet_early_drop]
+pub struct S;
+
+impl Drop for S { fn drop(&mut self) { } }
+
+pub fn foo<Y:Copy>(b: bool, c: || -> Foo<S,Y>, f: |S| -> int, _g: |Y| -> int) -> int {
+    let s = c();
+    //                                                          // NEEDS_DROP={s}
+    let ret = if b {
+    //                                                          // NEEDS_DROP={s}
+        f(s._x) // Path s._x moved in this branch ...
+    //                                                          // NEEDS_DROP={}
+    } else {
+    //                                                          // NEEDS_DROP={s}
+        3    // ... but not this one ...
+    //                                                          // NEEDS_DROP={s}
+    }; // ... but S is quiet_early_drop, so fine.
+    c();
+    ret
+}
diff --git a/foo43_warn.rs b/foo43_warn.rs
new file mode 100644
index 0000000..c3c254e
--- /dev/null
+++ b/foo43_warn.rs
@@ -0,0 +1,31 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+#[lang="drop"] pub trait Drop { fn drop(&mut self); }
+
+pub struct Foo<X,Y> { _x: X, _y: Y }
+
+#[quiet_early_drop]
+pub struct S;
+
+impl Drop for S { fn drop(&mut self) { } }
+
+#[warn(quiet_early_drop)]
+pub fn foo<Y:Copy>(b: bool, c: || -> Foo<S,Y>, f: |S| -> int, _g: |Y| -> int) -> int {
+    let s = c();
+    //                                                          // NEEDS_DROP={s}
+    let ret = if b {
+    //                                                          // NEEDS_DROP={s}
+        f(s._x) // Path s._x moved in this branch ...
+    //                                                          // NEEDS_DROP={}
+    } else {
+    //                                                          // NEEDS_DROP={s}
+        3    // ... but not this one ...
+    //                                                          // NEEDS_DROP={s}
+    }; // ... thus expect notice here (requested warn on quiet_early_drop)
+    c();
+    ret
+}
diff --git a/foo44_fine.rs b/foo44_fine.rs
new file mode 100644
index 0000000..de4d8d0
--- /dev/null
+++ b/foo44_fine.rs
@@ -0,0 +1,30 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+#[lang="drop"] pub trait Drop { fn drop(&mut self); }
+
+pub struct Foo<X,Y> { _x: X, _y: Y }
+
+pub struct S;
+
+impl Drop for S { fn drop(&mut self) { } }
+
+#[allow(unmarked_early_drop)]
+pub fn foo<Y:Copy>(b: bool, c: || -> Foo<S,Y>, f: |S| -> int, _g: |Y| -> int) -> int {
+    let s = c();
+    //                                                          // NEEDS_DROP={s}
+    let ret = if b {
+    //                                                          // NEEDS_DROP={s}
+        f(s._x) // Path s._x moved in this branch ...
+    //                                                          // NEEDS_DROP={}
+    } else {
+    //                                                          // NEEDS_DROP={s}
+        3    // ... but not this one ...
+    //                                                          // NEEDS_DROP={s}
+    }; // ... but we allow unmarked_early_drop above, so fine.
+    c();
+    ret
+}
diff --git a/foo45.rs b/foo45.rs
new file mode 100644
index 0000000..cc145d0
--- /dev/null
+++ b/foo45.rs
@@ -0,0 +1,30 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+#[lang="drop"] pub trait Drop { fn drop(&mut self); }
+
+pub enum Option<T> { None, Some(T), }
+
+pub struct Foo<'a,X,Y> { _x: X, _y: Y, z: Option<&'a mut int> }
+
+pub fn foo<X,Y:Copy>(b: bool, c: <'a> || -> Foo<'a,X,Y>, f: |X| -> int, _g: |Y| -> int) -> int {
+    let mut ret = 4;
+    {
+        let mut s = c();
+        s.z = Some(&mut ret);
+        //                                                          // NEEDS_DROP={s}
+        if b {
+            //                                                          // NEEDS_DROP={s}
+            f(s._x) // Path s._x moved in this branch ...
+                //                                                          // NEEDS_DROP={}
+        } else {
+            //                                                          // NEEDS_DROP={s}
+            3    // ... but not this one ...
+                //                                                          // NEEDS_DROP={s}
+        }; // ... but the only thing remaining is a read, so fine.
+    }
+    ret
+}
diff --git a/foo46.rs b/foo46.rs
new file mode 100644
index 0000000..9504464
--- /dev/null
+++ b/foo46.rs
@@ -0,0 +1,47 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+#[lang="drop"] pub trait Drop { fn drop(&mut self); }
+
+pub enum Option<T> { None, Some(T), }
+
+pub struct Foo<X,Y> { _x: X, _y: Y, z: OneOhOne }
+
+pub struct OneOhOne {
+    ptr: Option<*mut int>
+}
+
+impl Drop for OneOhOne {
+    fn drop(&mut self) {
+        match self.ptr {
+            None => {}
+            Some(ptr) => {
+                unsafe {
+                    *ptr = 101;
+                }
+            }
+        }
+    }
+}
+
+pub fn foo<X,Y:Copy>(b: bool, c: || -> Foo<X,Y>, f: |X| -> int, _g: |Y| -> int) -> int {
+    let mut ret = 4;
+    let mut s = c();
+    {
+        s.z = OneOhOne { ptr: Some(&mut ret as *mut int) };
+        //                                                          // NEEDS_DROP={s}
+        if b {
+            //                                                          // NEEDS_DROP={s}
+            f(s._x) // Path s._x moved in this branch ...
+                //                                                          // NEEDS_DROP={}
+        } else {
+            //                                                          // NEEDS_DROP={s}
+            3    // ... but not this one ...
+                //                                                          // NEEDS_DROP={s}
+        }; // ... but the only thing remaining is a read, so ... is it fine?
+    }
+    ret
+}
diff --git a/foo46_run.rs b/foo46_run.rs
new file mode 100644
index 0000000..22c1c05
--- /dev/null
+++ b/foo46_run.rs
@@ -0,0 +1,46 @@
+#![feature(lang_items)]
+
+pub struct Foo<X,Y> { _x: X, _y: Y, z: Option<OneOhOne> }
+
+pub struct OneOhOne {
+    ptr: *mut int
+}
+
+impl Drop for OneOhOne {
+    fn drop(&mut self) {
+        unsafe {
+            *self.ptr = 101;
+        }
+    }
+}
+
+fn main() {
+    let r = foo(true, || { Foo { _x: 1i, _y: 2i, z: None } }, |_| 10i, |_| 11i);
+    println!("r: {}", r);
+}
+
+pub fn foo<X,Y:Copy>(b: bool, c: || -> Foo<X,Y>, f: |X| -> int, _g: |Y| -> int) -> int {
+    let mut ret = 4;
+    let mut s = c();
+    {
+        s.z = Some(OneOhOne { ptr: &mut ret as *mut int });
+        //                                                          // NEEDS_DROP={s}
+        if b {
+            //                                                          // NEEDS_DROP={s}
+            f(s._x) // Path s._x moved in this branch ...
+                //                                                          // NEEDS_DROP={}
+        } else {
+            //                                                          // NEEDS_DROP={s}
+            3    // ... but not this one ...
+                //                                                          // NEEDS_DROP={s}
+        }; // ... but the only thing remaining is a read, so ... is it fine?
+    }
+
+    match true {
+        #[cfg(illustrate)]
+        true => std::mem::drop(s.z),
+        _ => {}
+    }
+
+    ret
+}
diff --git a/foo47_fine.rs b/foo47_fine.rs
new file mode 100644
index 0000000..60f2a1e
--- /dev/null
+++ b/foo47_fine.rs
@@ -0,0 +1,35 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+#[lang="drop"] pub trait Drop { fn drop(&mut self); }
+
+pub struct Foo<X,Y> { _x: X, _y: Y }
+
+#[lang="quiet_early_drop"]
+pub trait QuietEarlyDrop {
+}
+
+pub struct S;
+
+impl QuietEarlyDrop for S { }
+
+impl Drop for S { fn drop(&mut self) { } }
+
+pub fn foo<Y:Copy>(b: bool, c: || -> Foo<S,Y>, f: |S| -> int, _g: |Y| -> int) -> int {
+    let s = c();
+    //                                                          // NEEDS_DROP={s}
+    let ret = if b {
+    //                                                          // NEEDS_DROP={s}
+        f(s._x) // Path s._x moved in this branch ...
+    //                                                          // NEEDS_DROP={}
+    } else {
+    //                                                          // NEEDS_DROP={s}
+        3    // ... but not this one ...
+    //                                                          // NEEDS_DROP={s}
+    }; // ... but S is quiet_early_drop, so fine.
+    c();
+    ret
+}
diff --git a/foo48_warn.rs b/foo48_warn.rs
new file mode 100644
index 0000000..8ea376e
--- /dev/null
+++ b/foo48_warn.rs
@@ -0,0 +1,36 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+#[lang="drop"] pub trait Drop { fn drop(&mut self); }
+
+pub struct Foo<X,Y> { _x: X, _y: Y }
+
+#[lang="quiet_early_drop"]
+pub trait QuietEarlyDrop {
+}
+
+pub struct S;
+
+impl QuietEarlyDrop for S { }
+
+impl Drop for S { fn drop(&mut self) { } }
+
+#[warn(quiet_early_drop)]
+pub fn foo<Y:Copy>(b: bool, c: || -> Foo<S,Y>, f: |S| -> int, _g: |Y| -> int) -> int {
+    let s = c();
+    //                                                          // NEEDS_DROP={s}
+    let ret = if b {
+    //                                                          // NEEDS_DROP={s}
+        f(s._x) // Path s._x moved in this branch ...
+    //                                                          // NEEDS_DROP={}
+    } else {
+    //                                                          // NEEDS_DROP={s}
+        3    // ... but not this one ...
+    //                                                          // NEEDS_DROP={s}
+    }; // ... thus expect notice here (requested warn on quiet_early_drop)
+    c();
+    ret
+}
diff --git a/foo49_fine.rs b/foo49_fine.rs
new file mode 100644
index 0000000..56bc34e
--- /dev/null
+++ b/foo49_fine.rs
@@ -0,0 +1,37 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+#[lang="drop"] pub trait Drop { fn drop(&mut self); }
+
+pub struct Foo<X,Y> { _x: X, _y: Y }
+
+#[lang="quiet_early_drop"]
+pub trait QuietEarlyDrop {
+}
+
+pub struct S;
+pub struct T<X> { _s: X }
+
+impl QuietEarlyDrop for S { }
+impl<X:QuietEarlyDrop> QuietEarlyDrop for T<X> { }
+
+impl Drop for S { fn drop(&mut self) { } }
+
+pub fn foo<Y:Copy>(b: bool, c: || -> Foo<T<S>,Y>, f: |T<S>| -> int, _g: |Y| -> int) -> int {
+    let s = c();
+    //                                                          // NEEDS_DROP={s}
+    let ret = if b {
+    //                                                          // NEEDS_DROP={s}
+        f(s._x) // Path s._x moved in this branch ...
+    //                                                          // NEEDS_DROP={}
+    } else {
+    //                                                          // NEEDS_DROP={s}
+        3    // ... but not this one ...
+    //                                                          // NEEDS_DROP={s}
+    }; // ... but T<S> is quiet_early_drop, so fine.
+    c();
+    ret
+}
diff --git a/foo50_warn.rs b/foo50_warn.rs
new file mode 100644
index 0000000..9f70d9c
--- /dev/null
+++ b/foo50_warn.rs
@@ -0,0 +1,36 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+#[lang="drop"] pub trait Drop { fn drop(&mut self); }
+
+pub struct Foo<X,Y> { _x: X, _y: Y }
+
+#[lang="quiet_early_drop"]
+pub trait QuietEarlyDrop {
+}
+
+pub struct S;
+pub struct T<X> { _s: S }
+
+impl<X:QuietEarlyDrop> QuietEarlyDrop for T<X> { }
+
+impl Drop for S { fn drop(&mut self) { } }
+
+pub fn foo<Y:Copy>(b: bool, c: || -> Foo<T<S>,Y>, f: |T<S>| -> int, _g: |Y| -> int) -> int {
+    let s = c();
+    //                                                          // NEEDS_DROP={s}
+    let ret = if b {
+    //                                                          // NEEDS_DROP={s}
+        f(s._x) // Path s._x moved in this branch ...
+    //                                                          // NEEDS_DROP={}
+    } else {
+    //                                                          // NEEDS_DROP={s}
+        3    // ... but not this one ...
+    //                                                          // NEEDS_DROP={s}
+    }; // ... thus expect notice at this join-point (note T<S> is not quiet_early_drop).
+    c();
+    ret
+}
diff --git a/foo51.rs b/foo51.rs
new file mode 100644
index 0000000..3a97597
--- /dev/null
+++ b/foo51.rs
@@ -0,0 +1,41 @@
+// #![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+// extracted version of ICE I encountered while bootstrapping libstd
+
+extern crate core;
+extern crate libc;
+extern crate rustrt;
+extern crate collections;
+
+use rustrt::c_str::{CString, ToCStr};
+use core::option::Option;
+use core::ptr;
+use core::result::{Result,Ok,Err};
+use collections::string::String;
+
+pub fn foo<T>(f: || -> T) -> Result<T, String> {
+    use rustrt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};
+    static mut lock: StaticNativeMutex = NATIVE_MUTEX_INIT;
+    unsafe {
+        // dlerror isn't thread safe, so we need to lock around this entire
+        // sequence
+        let _guard = lock.lock();
+        let _old_error = dlerror();
+
+        let result = f();
+
+        let last_error = dlerror() as *const _;
+        let ret = if ptr::null() == last_error {
+            Ok(result)
+            } else {
+            Err(String::from_str(CString::new(last_error, false).as_str()
+                                 .unwrap()))
+        };
+
+        ret
+    }
+}
+
+fn dlerror() -> *mut libc::c_char { loop { } }
diff --git a/foo52_warn.rs b/foo52_warn.rs
new file mode 100644
index 0000000..e2b0246
--- /dev/null
+++ b/foo52_warn.rs
@@ -0,0 +1,21 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+// reduced version of foo51.rs
+#[lang="sized"] pub trait Sized { }
+
+#[lang="quiet_early_drop"]
+pub trait QuietEarlyDrop { }
+
+pub fn foo<T>(b: || -> bool, f: || -> T) -> T {
+    let result = f();
+
+    let ret = if b() {
+        result
+    } else {
+        f()
+    };
+
+    ret
+}
diff --git a/foo53_fine.rs b/foo53_fine.rs
new file mode 100644
index 0000000..82d30c4
--- /dev/null
+++ b/foo53_fine.rs
@@ -0,0 +1,23 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub fn drop<T>(_x: T) { }
+
+pub enum Ordering { Less = -1i, Equal = 0i, Greater = 1i, }
+
+pub trait Ord {
+    fn cmp(&self, _other: &Self) -> bool { loop { } }
+}
+impl Ord for int { }
+
+pub fn foo(x: &int) -> int {
+    match *x {
+        n if n.cmp(&0) => 1,  // int is copy ...
+        0              => 0,  // ... and that is all ...
+        _              => -1, // ... we are looking at.
+    } // So should be fine at this join point.
+}
diff --git a/foo54_fine.rs b/foo54_fine.rs
new file mode 100644
index 0000000..7da7a37
--- /dev/null
+++ b/foo54_fine.rs
@@ -0,0 +1,23 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub trait Float {
+    fn infinity() -> Self;
+    fn neg_infinity() -> Self;
+}
+
+pub static INFINITY: f32 = 1.0_f32/0.0_f32;
+pub static NEG_INFINITY: f32 = -1.0_f32/0.0_f32;
+
+impl Float for f32 {
+    fn infinity() -> f32 { INFINITY }
+    fn neg_infinity() -> f32 { NEG_INFINITY }
+}
+
+pub fn foo(s: f32) -> bool {
+    s == Float::infinity() || s == Float::neg_infinity()
+}
diff --git a/foo55_fine.rs b/foo55_fine.rs
new file mode 100644
index 0000000..bf762d0
--- /dev/null
+++ b/foo55_fine.rs
@@ -0,0 +1,33 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+// reduced version of foo51.rs
+#[lang="sized"] pub trait Sized { }
+
+#[lang="quiet_early_drop"]
+pub trait QuietEarlyDrop { }
+
+
+pub struct Vec<T> {
+    _len: uint,
+    _cap: uint,
+    _ptr: *mut T
+}
+
+impl<T:QuietEarlyDrop> QuietEarlyDrop for Vec<T> {}
+
+pub struct String {
+    _vec: Vec<u8>,
+}
+
+pub fn foo<T>(b: || -> bool, f: || -> String, g: || -> T) -> T {
+    let ret = if b() {
+        let _s = f();
+        g()
+    } else {
+        g()
+    };
+    f();
+    ret
+}
diff --git a/foo_no_std.rs b/foo_no_std.rs
new file mode 100644
index 0000000..6dcb847
--- /dev/null
+++ b/foo_no_std.rs
@@ -0,0 +1,13 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="sized"] pub trait Sized { }
+
+pub fn foo<T>(b: bool, x: T, f: |T| -> int) -> int {
+    if b {
+        f(x)
+    } else {
+        3
+    }
+}
diff --git a/iter1.rs b/iter1.rs
new file mode 100644
index 0000000..206e0ad
--- /dev/null
+++ b/iter1.rs
@@ -0,0 +1,50 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub fn drop<T>(_x: T) { }
+
+pub trait GreaterThan { fn gt(&self, that: &Self) -> bool; }
+
+pub enum Option<T> {
+    /// No value
+    None,
+    /// Some value `T`
+    Some(T)
+}
+
+impl<T> Option<T> {
+    pub fn map<U>(self, f: |T| -> U) -> Option<U> {
+        match self { Some(x) => Some(f(x)), None => None }
+    }
+}
+
+pub trait Iterator<A> {
+    fn fold<B>(&mut self, init: B, f: |B, A| -> B) -> B;
+
+    #[inline]
+    // originally named `max_by`
+    fn max_by<B: GreaterThan>(&mut self, f: |&A| -> B) -> Option<A> {
+        fn foo<A,B: GreaterThan>(f: |&A| -> B,
+                                 max: Option<(A, B)>,
+                                 x: A) -> Option<(A, B)> {
+            let x_val = f(&x);
+            match max {
+                None             => Some((x, x_val)),
+                Some((y, y_val)) => if x_val.gt(&y_val) {
+                    drop((y, y_val));
+                    Some((x, x_val))
+                } else {
+                    drop((x, x_val));
+                    Some((y, y_val))
+                }
+            }
+        }
+
+        self.fold(None, |max: Option<(A, B)>, x| foo(|a|f(a), max, x))
+            .map(|(x, _)| x)
+    }
+}
diff --git a/iter2.rs b/iter2.rs
new file mode 100644
index 0000000..916d092
--- /dev/null
+++ b/iter2.rs
@@ -0,0 +1,65 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub fn drop<T>(_x: T) { }
+
+pub enum Option<T> { None, Some(T), }
+
+pub struct Range<A> {
+    state: A,
+    stop: A,
+}
+
+impl<T> Option<T> {
+    fn map<A>(self, _f: |T| -> A) -> Option<A> { loop { } }
+}
+
+trait ToNums {
+    fn to_i64(&self) -> Option<i64> { loop { } }
+    fn to_u64(&self) -> Option<u64> { loop { } }
+    fn to_uint(&self) -> Option<uint> { loop { } }
+}
+
+trait CheckedSub {
+    fn checked_sub(&self, _y: &Self) -> Option<Self> { loop { } }
+}
+impl CheckedSub for i64 {}
+impl CheckedSub for u64 {}
+impl ToNums for i64 {}
+impl ToNums for u64 {}
+
+#[inline]
+pub fn foo<A:ToNums>(_self: &Range<A>) -> (uint, Option<uint>) {
+    // This first checks if the elements are representable as i64. If they aren't, try u64 (to
+    // handle cases like range(huge, huger)). We don't use uint/int because the difference of
+    // the i64/u64 might lie within their range.
+    let bound = match _self.state.to_i64() {
+        Some(a) => {
+            let sz = _self.stop.to_i64().map(|b| b.checked_sub(&a));
+            match sz {
+                Some(Some(bound)) => bound.to_uint(),
+                _ => None,
+            }
+        },
+        None => match _self.state.to_u64() {
+            Some(a) => {
+                let sz = _self.stop.to_u64().map(|b| b.checked_sub(&a));
+                match sz {
+                    Some(Some(bound)) => bound.to_uint(),
+                    _ => None
+                }
+            },
+            None => None
+        }
+    };
+
+    match bound {
+        Some(b) => (b, Some(b)),
+        // Standard fallback for unbounded/unrepresentable bounds
+        None => (0, None)
+    }
+}
diff --git a/iter3.rs b/iter3.rs
new file mode 100644
index 0000000..8468975
--- /dev/null
+++ b/iter3.rs
@@ -0,0 +1,141 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub fn drop<T>(_x: T) { }
+
+/// `MinMaxResult` is an enum returned by `min_max`. See `OrdIterator::min_max` for more detail.
+pub enum MinMaxResult<T> {
+    /// Empty iterator
+    NoElements,
+
+    /// Iterator with one element, so the minimum and maximum are the same
+    OneElement(T),
+
+    /// More than one element in the iterator, the first element is not larger than the second
+    MinMax(T, T)
+}
+
+pub trait OrdIterator<A> {
+    fn min_max(&mut self) -> MinMaxResult<A>;
+}
+
+pub fn foo<A: PartialOrd, T: Iterator<A>>(self_: &mut T) -> MinMaxResult<A> {
+    let (mut min, mut max) = match self_.next() {
+        None => return NoElements,
+        Some(x) => {
+            match self_.next() {
+                None => return OneElement(x),
+                Some(y) => if x < y {(x, y)} else {(y,x)}
+            }
+        }
+    };
+
+    loop {
+        // `first` and `second` are the two next elements we want to look at.
+        // We first compare `first` and `second` (#1). The smaller one is then compared to
+        // current minimum (#2). The larger one is compared to current maximum (#3). This
+        // way we do 3 comparisons for 2 elements.
+        let first = match self_.next() {
+            None => break,
+            Some(x) => x
+        };
+        let second = match self_.next() {
+            None => {
+                if first < min {
+                    min = first;
+                } else if first > max {
+                    max = first;
+                }
+                break;
+            }
+            Some(x) => x
+        };
+        if first < second {
+            if first < min {min = first;}
+            if max < second {max = second;}
+        } else {
+            if second < min {min = second;}
+            if max < first {max = first;}
+        }
+    }
+
+    MinMax(min, max)
+}
+
+#[lang="eq"]
+pub trait PartialEq {
+    /// This method tests for `self` and `other` values to be equal, and is used by `==`.
+    fn eq(&self, other: &Self) -> bool;
+
+    /// This method tests for `!=`.
+     fn ne(&self, other: &Self) -> bool { !self.eq(other) }
+}
+
+#[lang="ord"]
+pub trait PartialOrd: PartialEq {
+    /// This method returns an ordering between `self` and `other` values
+    /// if one exists.
+    fn partial_cmp(&self, other: &Self) -> Option<Ordering>;
+
+    /// This method tests less than (for `self` and `other`) and is used by the `<` operator.
+    fn lt(&self, other: &Self) -> bool {
+        match self.partial_cmp(other) {
+            Some(Less) => true,
+            _ => false,
+        }
+    }
+
+    /// This method tests less than or equal to (`<=`).
+    #[inline]
+    fn le(&self, other: &Self) -> bool {
+        match self.partial_cmp(other) {
+            Some(Less) | Some(Equal) => true,
+            _ => false,
+        }
+    }
+
+    /// This method tests greater than (`>`).
+    #[inline]
+    fn gt(&self, other: &Self) -> bool {
+        match self.partial_cmp(other) {
+            Some(Greater) => true,
+            _ => false,
+        }
+    }
+
+    /// This method tests greater than or equal to (`>=`).
+    #[inline]
+    fn ge(&self, other: &Self) -> bool {
+        match self.partial_cmp(other) {
+            Some(Greater) | Some(Equal) => true,
+            _ => false,
+        }
+    }
+}
+
+#[stable]
+pub enum Ordering {
+   /// An ordering where a compared value is less [than another].
+   Less = -1i,
+   /// An ordering where a compared value is equal [to another].
+   Equal = 0i,
+   /// An ordering where a compared value is greater [than another].
+   Greater = 1i,
+}
+
+pub enum Option<T> {
+    /// No value
+    None,
+    /// Some value `T`
+    Some(T)
+}
+
+#[lang="iterator"]
+pub trait Iterator<A> {
+    /// Advance the iterator and return the next value. Return `None` when the end is reached.
+    fn next(&mut self) -> Option<A>;
+}
diff --git a/num01.rs b/num01.rs
new file mode 100644
index 0000000..d4e09a1
--- /dev/null
+++ b/num01.rs
@@ -0,0 +1,23 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub fn drop<T>(_x: T) { }
+
+pub enum Ordering { Less = -1i, Equal = 0i, Greater = 1i, }
+
+pub trait Ord {
+    fn cmp(&self, _other: &Self) -> bool { loop { } }
+}
+impl Ord for int { }
+
+pub fn foo(x: &int) -> int {
+    match *x {
+        n if n.cmp(&0) => 1,
+        0 => 0,
+        _ => -1,
+    }
+}
diff --git a/option01.rs b/option01.rs
new file mode 100644
index 0000000..0192802
--- /dev/null
+++ b/option01.rs
@@ -0,0 +1,22 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub fn drop<T>(_x: T) { }
+
+pub enum Option<T> { None, Some(T), }
+
+pub fn foo<T>(x: Option<T>, optb: Option<T>) -> Option<T> {
+    match x {
+        // The use of `_` here means that this is a borrowing match of `x`...
+        Some(_) => { drop(optb); x }
+
+        // ... which means that `x` has not been dropped on this path
+        // (*even though* we know that `x` is `None` and thus is not
+        // needs-drop on this path) :(
+        None => optb
+    }
+}
diff --git a/result01.rs b/result01.rs
new file mode 100644
index 0000000..89fb53d
--- /dev/null
+++ b/result01.rs
@@ -0,0 +1,18 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub fn drop<T>(_x: T) { }
+
+pub enum Option<T> { None, Some(T), }
+pub enum Result<T, E> { Ok(T), Err(E), }
+
+pub fn foo<T,E>(s: Result<T, E>) -> Option<T> {
+    match s {
+        Ok(x)  => { Some(x) },
+        Err(_s) => { None },
+    }
+}
diff --git a/result02.rs b/result02.rs
new file mode 100644
index 0000000..2f32a3a
--- /dev/null
+++ b/result02.rs
@@ -0,0 +1,18 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub fn drop<T>(_x: T) { }
+
+pub enum Result<T, E> { Ok(T), Err(E), }
+
+// originally `Result::or`
+pub fn foo<T,E>(s: Result<T, E>, res: Result<T,E>) -> Result<T,E> {
+    match s {
+        Err(_) => { drop(s); res }
+        Ok(_) => { drop(res); s }
+    }
+}
diff --git a/result03.rs b/result03.rs
new file mode 100644
index 0000000..faf6107
--- /dev/null
+++ b/result03.rs
@@ -0,0 +1,24 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub fn drop<T>(_x: T) { }
+
+pub enum Result<T, E> { Ok(T), Err(E), }
+
+// originally `Result::or`
+pub fn foo<T,E>(s: Result<T, E>, res: Result<T,E>) -> Result<T,E> {
+    match s {
+        Err(_) => {
+            drop(s);
+            res
+        }
+        Ok(_) => {
+            drop(res);
+            s
+        }
+    }
+}
diff --git a/rfc01_fine.rs b/rfc01_fine.rs
new file mode 100644
index 0000000..43cd257
--- /dev/null
+++ b/rfc01_fine.rs
@@ -0,0 +1,76 @@
+#![feature(lang_items)]
+#![no_std]
+#![allow(dead_code)]
+#![allow(unused_variable)]
+#![allow(dead_assignment)]
+
+#![crate_type="lib"]
+
+#[lang="sized"] pub trait Sized { }
+#[lang="drop"] pub trait Drop { fn drop(&mut self); }
+pub enum Option<T> { None, Some(T), }
+
+// (PRELUDE ENDS ABOVE)
+
+struct Pair<X,Y>{ x:X, y:Y }
+
+struct D; struct S;
+
+impl Drop for D { fn drop(&mut self) { loop { } } }
+
+fn test() -> bool { loop { } }
+
+fn xform(d:D) -> D { loop { } }
+
+fn foo(mk_dd: || -> Pair<D,D>, mk_ds: || -> Pair<D,S>, mk_opt_d: || -> Option<D>) {
+    // At the outset, the set of drop obligations is
+    // just the set of moved input parameters (empty
+    // in this case).
+
+    //                                      DROP OBLIGATIONS
+    //                                  ------------------------
+    //                                  {  }
+    let mut pDD : Pair<D,D> = mk_dd();
+    //                                  { pDD.x, pDD.y }
+    let pDS : Pair<D,S> = mk_ds();
+    //                                  { pDD.x, pDD.y, pDS.x }
+    let mut some_d : Option<D> = mk_opt_d();
+    //                                  { pDD.x, pDD.y, pDS.x }
+    if test() {
+        //                                 { pDD.x, pDD.y, pDS.x }
+        {
+            let temp = xform(pDD.x);
+            //                             {        pDD.y, pDS.x, temp }
+            some_d = Some(temp);
+            //                             {        pDD.y, pDS.x, temp, some_d }
+        } // END OF SCOPE for `temp`
+        //                                 {        pDD.y, pDS.x, some_d }
+    } else {
+        {
+            //                             { pDD.x, pDD.y, pDS.x }
+            let z = D;
+            //                             { pDD.x, pDD.y, pDS.x, z }
+
+            // This drops `pDD.y` before
+            // moving `pDD.x` there.
+            pDD.y = pDD.x;
+
+            //                             {        pDD.y, pDS.x, z }
+            some_d = None;
+            //                             {        pDD.y, pDS.x, z, some_d }
+        } // END OF SCOPE for `z`
+        //                                 {        pDD.y, pDS.x, some_d }
+    }
+
+    // MERGE POINT: set of drop obligations must
+    // match on all incoming control-flow paths...
+    //
+    // ... which they do in this case.
+
+    //                                  {       pDD.y, pDS.x, some_d }
+
+    // (... some code that does not change drop obligations ...)
+    mk_dd();
+
+    //                                  {       pDD.y, pDS.x, some_d }
+}
diff --git a/rfc02_warn.rs b/rfc02_warn.rs
new file mode 100644
index 0000000..43f53d2
--- /dev/null
+++ b/rfc02_warn.rs
@@ -0,0 +1,96 @@
+#![feature(lang_items)]
+#![no_std]
+#![allow(dead_code)]
+#![allow(unused_variable)]
+#![allow(dead_assignment)]
+
+#![crate_type="lib"]
+
+#[lang="sized"] pub trait Sized { }
+#[lang="drop"] pub trait Drop { fn drop(&mut self); }
+pub enum Option<T> { None, Some(T), }
+
+// (PRELUDE ENDS ABOVE)
+
+struct Pair<X,Y>{ x:X, y:Y }
+
+struct D; struct S;
+
+impl Drop for D { fn drop(&mut self) { loop { } } }
+
+fn test() -> bool { loop { } }
+
+fn xform(d:D) -> D { loop { } }
+
+// `f2` is similar to `f1`, except that it will have differing set
+// of drop obligations at the merge point, necessitating a hidden
+// drop call.
+fn foo(mk_dd: || -> Pair<D,D>, mk_ds: || -> Pair<D,S>, mk_opt_d: || -> Option<D>) {
+    // At the outset, the set of drop obligations is
+    // just the set of moved input parameters (empty
+    // in this case).
+
+    //                                      DROP OBLIGATIONS
+    //                                  ------------------------
+    //                                  {  }
+    let mut pDD : Pair<D,D> = mk_dd();
+    //                                  {pDD.x, pDD.y}
+    let pDS : Pair<D,S> = mk_ds();
+    //                                  {pDD.x, pDD.y, pDS.x}
+    let mut some_d : Option<D> = mk_opt_d();
+    //                                  {pDD.x, pDD.y, pDS.x}
+    if test() {
+        //                                  {pDD.x, pDD.y, pDS.x}
+        {
+            let temp = xform(pDD.y);
+            //                              {pDD.x,        pDS.x, temp}
+            some_d = Some(temp);
+            //                              {pDD.x,        pDS.x, temp, some_d}
+        } // END OF SCOPE for `temp`
+        //                                  {pDD.x,        pDS.x, some_d}
+
+        // MERGE POINT PREDECESSOR 1
+
+        // implicit drops injected: drop(pDD.y)
+    } else {
+        {
+            //                              {pDD.x, pDD.y, pDS.x}
+            let z = D;
+            //                              {pDD.x, pDD.y, pDS.x, z}
+
+            // This drops `pDD.y` before
+            // moving `pDD.x` there.
+            pDD.y = pDD.x;
+
+            //                              {       pDD.y, pDS.x, z}
+            some_d = None;
+            //                              {       pDD.y, pDS.x, z, some_d}
+        } // END OF SCOPE for `z`
+        //                                  {       pDD.y, pDS.x, some_d}
+
+        // MERGE POINT PREDECESSOR 2
+
+        // implicit drops injected: drop(pDD.y)
+    }
+
+    // MERGE POINT: set of drop obligations must
+    // match on all incoming control-flow paths.
+    //
+    // For the original user code, they did not
+    // in this case.
+    //
+    // Therefore, implicit drops are injected up
+    // above, to ensure that the set of drop
+    // obligations match.
+
+    // After the implicit drops, the resulting
+    // remaining drop obligations are the
+    // following:
+
+    //                                  {              pDS.x, some_d}
+
+    // (... some code that does not change drop obligations ...)
+    mk_dd();
+
+    //                                  {              pDS.x, some_d}
+}
diff --git a/rfc03_fine.rs b/rfc03_fine.rs
new file mode 100644
index 0000000..c424d76
--- /dev/null
+++ b/rfc03_fine.rs
@@ -0,0 +1,106 @@
+#![feature(lang_items)]
+#![no_std]
+#![allow(dead_code)]
+#![allow(unused_variable)]
+#![allow(dead_assignment)]
+
+#![crate_type="lib"]
+
+#[lang="sized"] pub trait Sized { }
+#[lang="drop"] pub trait Drop { fn drop(&mut self); }
+pub enum Option<T> { None, Some(T), }
+
+// (PRELUDE ENDS ABOVE)
+
+struct Pair<X,Y>{ x:X, y:Y }
+
+struct D; struct S;
+
+impl Drop for D { fn drop(&mut self) { loop { } } }
+
+fn test() -> bool { loop { } }
+
+fn xform(d:D) -> D { loop { } }
+
+fn foo(mk_dd: || -> Pair<D,D>, mk_d: || -> D, consume: |D|) {
+    // At the outset, the set of drop obligations is
+    // just the set of moved input parameters (empty
+    // in this case).
+
+    //                                      DROP OBLIGATIONS
+    //                                  ------------------------
+    //                                  {  }
+    let mut pDD : Pair<D,D> = mk_dd();
+    //                                  {         pDD.x, pDD.y }
+    'a: loop {
+        // MERGE POINT: set of drop obligations must
+        // match on all incoming control-flow paths.
+
+        //                                  {     pDD.x, pDD.y }
+        if test() {
+            //                                  { pDD.x, pDD.y }
+            consume(pDD.x);
+            //                                  {        pDD.y }
+            break 'a;
+        }
+
+        //                                  {     pDD.x, pDD.y }
+
+        // *not* merge point (only one path flows here)
+
+        // never falls through; must merge with 'a loop.
+    }
+
+    // RESUME POINT: break 'a above flows here
+
+    //                                  {                pDD.y }
+
+    'b: loop {
+        // MERGE POINT: set of drop obligations must match on all
+        // incoming control-flow paths.
+        //
+        // There are *three* such incoming paths: (1.) the statement
+        // preceding `'b: loop`, (2.) the `continue 'b;` below, and
+        // (3.) the loop end below.
+
+        //                                  {            pDD.y }
+
+        consume(pDD.y);
+
+        //                                  {                  }
+
+        if test() {
+            //                                  {              }
+            pDD.x = mk_d();
+            //                                  {  pDD.x       }
+            break 'b;
+        }
+
+        // *not* merge point (only one path flows here)
+
+        //                                  {                  }
+
+        if test() {
+            //                                  {              }
+            pDD.y = mk_d();
+            //                                  {        pDD.y }
+            continue 'b;
+        }
+        // *not* merge point (only one path flows here)
+
+        //                                  {                  }
+
+        pDD.y = mk_d();
+
+        //                                  {            pDD.y }
+    }
+
+    // RESUME POINT: break 'b above flows here
+
+    //                                  {         pDD.x        }
+
+    // (... some code that does not change drop obligations ...)
+    mk_dd();
+
+    //                                  {               pDD.y }
+}
diff --git a/rfc03_warn.rs b/rfc03_warn.rs
new file mode 100644
index 0000000..71467d0
--- /dev/null
+++ b/rfc03_warn.rs
@@ -0,0 +1,106 @@
+#![feature(lang_items)]
+#![no_std]
+#![allow(dead_code)]
+#![allow(unused_variable)]
+#![allow(dead_assignment)]
+
+#![crate_type="lib"]
+
+#[lang="sized"] pub trait Sized { }
+#[lang="drop"] pub trait Drop { fn drop(&mut self); }
+pub enum Option<T> { None, Some(T), }
+
+// (PRELUDE ENDS ABOVE)
+
+struct Pair<X,Y>{ x:X, y:Y }
+
+struct D; struct S;
+
+impl Drop for D { fn drop(&mut self) { loop { } } }
+
+fn test() -> bool { loop { } }
+
+fn xform(d:D) -> D { loop { } }
+
+fn foo(mk_dd: || -> Pair<D,D>, mk_d: || -> D, consume: |D|) {
+    // At the outset, the set of drop obligations is
+    // just the set of moved input parameters (empty
+    // in this case).
+
+    //                                      DROP OBLIGATIONS
+    //                                  ------------------------
+    //                                  {  }
+    let mut pDD : Pair<D,D> = mk_dd();
+    //                                  {         pDD.x, pDD.y }
+    'a: loop {
+        // MERGE POINT: set of drop obligations must
+        // match on all incoming control-flow paths.
+
+        //                                  {     pDD.x, pDD.y }
+        if test() {
+            //                                  { pDD.x, pDD.y }
+            consume(pDD.x);
+            //                                  {        pDD.y }
+            break 'a;
+        }
+
+        //                                  {     pDD.x, pDD.y }
+
+        // *not* merge point (only one path flows here)
+
+        // never falls through; must merge with 'a loop.
+    }
+
+    // RESUME POINT: break 'a above flows here
+
+    //                                  {                pDD.y }
+
+    'b: loop {
+        // MERGE POINT: set of drop obligations must match on all
+        // incoming control-flow paths.
+        //
+        // There are *three* such incoming paths: (1.) the statement
+        // preceding `'b: loop`, (2.) the `continue 'b;` below, and
+        // (3.) the loop end below.
+
+        //                                  {            pDD.y }
+
+        consume(pDD.y);
+
+        //                                  {                  }
+
+        if test() {
+            //                                  {              }
+            pDD.y = mk_d();
+            //                                  {        pDD.y }
+            break 'b;
+        }
+
+        // *not* merge point (only one path flows here)
+
+        //                                  {                  }
+
+        if test() {
+            //                                  {              }
+            pDD.y = mk_d();
+            //                                  {        pDD.y }
+            continue 'b;
+        }
+        // *not* merge point (only one path flows here)
+
+        //                                  {                  }
+
+        pDD.y = mk_d();
+
+        //                                  {            pDD.y }
+    }
+
+    // RESUME POINT: break 'b above flows here
+
+    //                                  {               pDD.y }
+
+    // (... some code that does not change drop obligations ...)
+    mk_dd();
+
+    //                                  {               pDD.y }
+}
diff --git a/rfc04_fine.rs b/rfc04_fine.rs
new file mode 100644
index 0000000..71467d0
--- /dev/null
+++ b/rfc04_fine.rs
@@ -0,0 +1,106 @@
+#![feature(lang_items)]
+#![no_std]
+#![allow(dead_code)]
+#![allow(unused_variable)]
+#![allow(dead_assignment)]
+
+#![crate_type="lib"]
+
+#[lang="sized"] pub trait Sized { }
+#[lang="drop"] pub trait Drop { fn drop(&mut self); }
+pub enum Option<T> { None, Some(T), }
+
+// (PRELUDE ENDS ABOVE)
+
+struct Pair<X,Y>{ x:X, y:Y }
+
+struct D; struct S;
+
+impl Drop for D { fn drop(&mut self) { loop { } } }
+
+fn test() -> bool { loop { } }
+
+fn xform(d:D) -> D { loop { } }
+
+fn foo(mk_dd: || -> Pair<D,D>, mk_d: || -> D, consume: |D|) {
+    // At the outset, the set of drop obligations is
+    // just the set of moved input parameters (empty
+    // in this case).
+
+    //                                      DROP OBLIGATIONS
+    //                                  ------------------------
+    //                                  {  }
+    let mut pDD : Pair<D,D> = mk_dd();
+    //                                  {         pDD.x, pDD.y }
+    'a: loop {
+        // MERGE POINT: set of drop obligations must
+        // match on all incoming control-flow paths.
+
+        //                                  {     pDD.x, pDD.y }
+        if test() {
+            //                                  { pDD.x, pDD.y }
+            consume(pDD.x);
+            //                                  {        pDD.y }
+            break 'a;
+        }
+
+        //                                  {     pDD.x, pDD.y }
+
+        // *not* merge point (only one path flows here)
+
+        // never falls through; must merge with 'a loop.
+    }
+
+    // RESUME POINT: break 'a above flows here
+
+    //                                  {                pDD.y }
+
+    'b: loop {
+        // MERGE POINT: set of drop obligations must match on all
+        // incoming control-flow paths.
+        //
+        // There are *three* such incoming paths: (1.) the statement
+        // preceding `'b: loop`, (2.) the `continue 'b;` below, and
+        // (3.) the loop end below.
+
+        //                                  {            pDD.y }
+
+        consume(pDD.y);
+
+        //                                  {                  }
+
+        if test() {
+            //                                  {              }
+            pDD.y = mk_d();
+            //                                  {        pDD.y }
+            break 'b;
+        }
+
+        // *not* merge point (only one path flows here)
+
+        //                                  {                  }
+
+        if test() {
+            //                                  {              }
+            pDD.y = mk_d();
+            //                                  {        pDD.y }
+            continue 'b;
+        }
+        // *not* merge point (only one path flows here)
+
+        //                                  {                  }
+
+        pDD.y = mk_d();
+
+        //                                  {            pDD.y }
+    }
+
+    // RESUME POINT: break 'b above flows here
+
+    //                                  {               pDD.y }
+
+    // (... some code that does not change drop obligations ...)
+    mk_dd();
+
+    //                                  {               pDD.y }
+}
diff --git a/rfc04_warn.rs b/rfc04_warn.rs
new file mode 100644
index 0000000..7c3040a
--- /dev/null
+++ b/rfc04_warn.rs
@@ -0,0 +1,70 @@
+#![feature(lang_items)]
+#![no_std]
+#![allow(dead_code)]
+#![allow(unused_variable)]
+#![allow(dead_assignment)]
+
+#![crate_type="lib"]
+
+#[lang="sized"] pub trait Sized { }
+#[lang="drop"] pub trait Drop { fn drop(&mut self); }
+pub enum Option<T> { None, Some(T), }
+
+// (PRELUDE ENDS ABOVE)
+
+struct Pair<X,Y>{ x:X, y:Y }
+
+struct D; struct S;
+
+impl Drop for D { fn drop(&mut self) { loop { } } }
+
+fn test() -> bool { loop { } }
+
+fn xform(d:D) -> D { loop { } }
+
+fn foo(mk_dd: || -> Pair<D,D>, mk_d: || -> D, consume: |D|) {
+    // At the outset, the set of drop obligations is
+    // just the set of moved input parameters (empty
+    // in this case).
+
+    //                                      DROP OBLIGATIONS
+    //                                  ------------------------
+    //                                  {  }
+    let mut pDD : Pair<D,D> = mk_dd();
+    //                                  {         pDD.x, pDD.y }
+    'a: loop {
+        // MERGE POINT: set of drop obligations must
+        // match on all incoming control-flow paths.
+
+        //                                  {     pDD.x, pDD.y }
+        if test() {
+            //                                  { pDD.x, pDD.y }
+            consume(pDD.x);
+            //                                  {        pDD.y }
+            break 'a;
+        }
+
+        //                                  {     pDD.x, pDD.y }
+
+        // *not* merge point (only one path flows here)
+
+        if test() {
+            //                                  { pDD.x, pDD.y }
+            break 'a;
+        }
+
+        // never falls through; must merge with 'a loop.
+    }
+
+    // MERGE POINT: both `break 'a;` statements above flow here ...
+    //
+    // ... and their drop obligations do not match, so we get a
+    // warning here.
+
+    //                                  {                pDD.y }
+
+    // (... some code that does not change drop obligations ...)
+    mk_dd();
+
+    //                                  {               pDD.y }
+}
diff --git a/rfc05_deny.rs b/rfc05_deny.rs
new file mode 100644
index 0000000..a1a79615
--- /dev/null
+++ b/rfc05_deny.rs
@@ -0,0 +1,30 @@
+#![feature(lang_items)]
+#![no_std]
+#![allow(dead_code)]
+#![allow(unused_variable)]
+#![allow(dead_assignment)]
+
+#![crate_type="lib"]
+
+#[lang="sized"] pub trait Sized { }
+#[lang="drop"] pub trait Drop { fn drop(&mut self); }
+pub enum Option<T> { None, Some(T), }
+
+// (PRELUDE ENDS ABOVE)
+
+pub enum Pairy<X> { Two(X,X), One(X,X) }
+pub fn foo<A>(c: || -> Pairy<A>,
+              dA: |A| -> i8,
+              dR: |&A| -> i8) -> i8 {
+    let s = c();
+    let ret = match s {
+        Two(ref r1, ref r2) => {
+            dR(r1) + dR(r2)
+        }
+        One(a1, a2) => {
+            dA(a1) + dA(a2)
+        }
+    };
+    c();
+    ret
+}
diff --git a/rfc06_fine.rs b/rfc06_fine.rs
new file mode 100644
index 0000000..6158786
--- /dev/null
+++ b/rfc06_fine.rs
@@ -0,0 +1,31 @@
+#![feature(lang_items)]
+#![no_std]
+#![allow(dead_code)]
+#![allow(unused_variable)]
+#![allow(dead_assignment)]
+
+#![crate_type="lib"]
+
+#[lang="sized"] pub trait Sized { }
+#[lang="drop"] pub trait Drop { fn drop(&mut self); }
+pub enum Option<T> { None, Some(T), }
+
+// (PRELUDE ENDS ABOVE)
+
+pub enum Pairy<X> { Two(X,X), One(X,X) }
+pub fn foo<A>(c: || -> Pairy<A>,
+              dA: |A| -> i8,
+              dR: |&A| -> i8,
+              dS: |Pairy<A>| -> i8) -> i8 {
+    let s = c();
+    let ret = match s {
+        One(a1, a2) => {
+            dA(a1) + dA(a2)
+        }
+        Two(_, _) => {
+            dS(s)
+        }
+    };
+    c();
+    ret
+}
diff --git a/rfc07_fine.rs b/rfc07_fine.rs
new file mode 100644
index 0000000..61d160f
--- /dev/null
+++ b/rfc07_fine.rs
@@ -0,0 +1,48 @@
+#![feature(lang_items)]
+#![no_std]
+#![allow(dead_code)]
+#![allow(unused_variable)]
+#![allow(dead_assignment)]
+
+#![crate_type="lib"]
+
+#[lang="sized"] pub trait Sized { }
+#[lang="drop"] pub trait Drop { fn drop(&mut self); }
+pub enum Option<T> { None, Some(T), }
+
+// (PRELUDE ENDS ABOVE)
+
+pub struct D;
+impl Drop for D { fn drop(&mut self) { } }
+
+pub fn foo(b: || -> bool, c: || -> D, f: |D| -> i8) -> i8 {
+
+    //                                      DROP OBLIGATIONS
+    //                                  ------------------------
+    //                                  {       }
+
+    let x = c();
+    //                                  {     x }
+    let y = c();
+    //                                  {     x, y }
+
+    if b() {
+        //                                  { x, y }
+        let ret = f(x);
+        //                                  {    y }
+        return ret; // emits code to drop `y`
+    }
+    // *not* merge point (only one path, the else branch, flows here)
+
+    //                                  {     x, y }
+    if b() {
+        //                                  { x, y }
+        let ret = f(y);
+        //                                  { x    }
+        return ret; // emits code to drop `x`
+    }
+
+    //                                  {     x, y }
+
+    return 0; // emits code to drop `x` and `y`
+}
diff --git a/src/etc/rustc-wrapper.macosx.sh b/src/etc/rustc-wrapper.macosx.sh
new file mode 100755
index 0000000..7f63eb7
--- /dev/null
+++ b/src/etc/rustc-wrapper.macosx.sh
@@ -0,0 +1,4 @@
+DIR=$(dirname $0)
+CMD="DYLD_LIBRARY_PATH=$DIR/lib:$DYLD_LIBRARY_PATH exec $DIR/bin/rustc $@"
+# echo $CMD
+eval "$CMD"
diff --git a/src/liballoc/rc.rs b/src/liballoc/rc.rs
index ec19844..f524834 100644
--- a/src/liballoc/rc.rs
+++ b/src/liballoc/rc.rs
@@ -154,7 +154,7 @@ use core::default::Default;
 use core::fmt;
 use core::kinds::marker;
 use core::mem::{transmute, min_align_of, size_of, forget};
-use core::ops::{Deref, Drop};
+use core::ops::{Deref, Drop, QuietEarlyDrop};
 use core::option::{Option, Some, None};
 use core::ptr;
 use core::ptr::RawPtr;
@@ -179,6 +179,8 @@ pub struct Rc<T> {
     _noshare: marker::NoSync
 }
 
+impl<T:QuietEarlyDrop> QuietEarlyDrop for Rc<T> { }
+
 #[stable]
 impl<T> Rc<T> {
     /// Constructs a new reference-counted pointer.
diff --git a/src/libcollections/vec.rs b/src/libcollections/vec.rs
index a7005cf..363b031 100644
--- a/src/libcollections/vec.rs
+++ b/src/libcollections/vec.rs
@@ -18,6 +18,7 @@ use core::default::Default;
 use core::fmt;
 use core::mem;
 use core::num;
+use core::ops::QuietEarlyDrop;
 use core::ptr;
 use core::raw::Slice as RawSlice;
 use core::uint;
@@ -1529,6 +1530,8 @@ impl<T: Clone, V: Slice<T>> Add<V, Vec<T>> for Vec<T> {
     }
 }
 
+impl<T:QuietEarlyDrop> QuietEarlyDrop for Vec<T> {}
+
 #[unsafe_destructor]
 impl<T> Drop for Vec<T> {
     fn drop(&mut self) {
diff --git a/src/libcore/cell.rs b/src/libcore/cell.rs
index 1cad9a3..35fbe0c 100644
--- a/src/libcore/cell.rs
+++ b/src/libcore/cell.rs
@@ -158,7 +158,7 @@
 use clone::Clone;
 use cmp::PartialEq;
 use kinds::{marker, Copy};
-use ops::{Deref, DerefMut, Drop};
+use ops::{Deref, DerefMut, Drop, QuietEarlyDrop};
 use option::{None, Option, Some};
 
 /// A mutable memory location that admits only `Copy` data.
@@ -216,6 +216,8 @@ pub struct RefCell<T> {
     noshare: marker::NoSync,
 }
 
+impl<T:QuietEarlyDrop> QuietEarlyDrop for RefCell<T> { }
+
 // Values [1, MAX-1] represent the number of `Ref` active
 // (will not outgrow its range since `uint` is the size of the address space)
 type BorrowFlag = uint;
@@ -340,6 +342,8 @@ impl<'b, T> Drop for Ref<'b, T> {
     }
 }
 
+impl<'b,T:QuietEarlyDrop> QuietEarlyDrop for Ref<'b,T> { }
+
 #[unstable = "waiting for `Deref` to become stable"]
 impl<'b, T> Deref<T> for Ref<'b, T> {
     #[inline]
diff --git a/src/libcore/ops.rs b/src/libcore/ops.rs
index 836285b..966230e 100644
--- a/src/libcore/ops.rs
+++ b/src/libcore/ops.rs
@@ -87,6 +87,22 @@ pub trait Drop {
 
 /**
  *
+ * The `QuietEarlyDrop` trait is used to tag types whose drop
+ * invocations can be safely moved to earlier than the end of their
+ * scope without significant potential for interference with other
+ * side-effects in user code.  For example, a type whose drop method
+ * solely deallocates storage is a likely candidate for implementing
+ * `QuietEarlyDrop`.
+ *
+ * See also the `quiet_early_drop` and `unmarked_early_drop` lints.
+ */
+#[lang="quiet_early_drop"]
+pub trait QuietEarlyDrop {
+    // empty
+}
+
+/**
+ *
  * The `Add` trait is used to specify the functionality of `+`.
  *
  * # Example
diff --git a/src/libcore/option.rs b/src/libcore/option.rs
index 537d78a..b1e353c 100644
--- a/src/libcore/option.rs
+++ b/src/libcore/option.rs
@@ -148,6 +148,7 @@ use default::Default;
 use slice::Slice;
 use iter::{Iterator, DoubleEndedIterator, FromIterator, ExactSize};
 use mem;
+use ops::QuietEarlyDrop;
 use slice;
 
 // Note that this is not a lang item per se, but it has a hidden dependency on
@@ -165,6 +166,8 @@ pub enum Option<T> {
     Some(T)
 }
 
+impl<T:QuietEarlyDrop> QuietEarlyDrop for Option<T> {}
+
 /////////////////////////////////////////////////////////////////////////////
 // Type implementation
 /////////////////////////////////////////////////////////////////////////////
diff --git a/src/libcore/result.rs b/src/libcore/result.rs
index bf351ec..c672564 100644
--- a/src/libcore/result.rs
+++ b/src/libcore/result.rs
@@ -282,6 +282,7 @@ use std::fmt::Show;
 use slice;
 use slice::Slice;
 use iter::{Iterator, DoubleEndedIterator, FromIterator, ExactSize};
+use ops::QuietEarlyDrop;
 use option::{None, Option, Some};
 
 /// `Result` is a type that represents either success (`Ok`) or failure (`Err`).
@@ -298,6 +299,8 @@ pub enum Result<T, E> {
     Err(E)
 }
 
+impl<T:QuietEarlyDrop,E:QuietEarlyDrop> QuietEarlyDrop for Result<T,E> { }
+
 /////////////////////////////////////////////////////////////////////////////
 // Type implementation
 /////////////////////////////////////////////////////////////////////////////
diff --git a/src/librustc/diagnostics.rs b/src/librustc/diagnostics.rs
index 079e01c..4167320 100644
--- a/src/librustc/diagnostics.rs
+++ b/src/librustc/diagnostics.rs
@@ -170,5 +170,6 @@ register_diagnostics!(
     E0158,
     E0159,
     E0160,
-    E0161
+    E0161,
+    E0162  // QuietEarlyDrop is only for struct/enum/unboxed-closures
 )
diff --git a/src/librustc/driver/config.rs b/src/librustc/driver/config.rs
index 8f4f54c..32751a7 100644
--- a/src/librustc/driver/config.rs
+++ b/src/librustc/driver/config.rs
@@ -188,6 +188,7 @@ debugging_opts!(
         FLOWGRAPH_PRINT_LOANS,
         FLOWGRAPH_PRINT_MOVES,
         FLOWGRAPH_PRINT_ASSIGNS,
+        FLOWGRAPH_PRINT_NEEDS_DROP,
         FLOWGRAPH_PRINT_ALL
     ]
     0
@@ -231,6 +232,8 @@ pub fn debugging_opts_map() -> Vec<(&'static str, &'static str, u64)> {
                        --pretty flowgraph output", FLOWGRAPH_PRINT_MOVES),
      ("flowgraph-print-assigns", "Include assignment analysis data in \
                        --pretty flowgraph output", FLOWGRAPH_PRINT_ASSIGNS),
+     ("flowgraph-print-needs-drop", "Include needs-drop analysis data in \
+                       --pretty flowgraph output", FLOWGRAPH_PRINT_NEEDS_DROP),
      ("flowgraph-print-all", "Include all dataflow analysis data in \
                        --pretty flowgraph output", FLOWGRAPH_PRINT_ALL))
 }
diff --git a/src/librustc/driver/driver.rs b/src/librustc/driver/driver.rs
index 4c71c2d..24c9a7f 100644
--- a/src/librustc/driver/driver.rs
+++ b/src/librustc/driver/driver.rs
@@ -30,6 +30,7 @@ use util::nodemap::{NodeSet};
 
 use serialize::{json, Encodable};
 
+use std::from_str::FromStr;
 use std::io;
 use std::io::fs;
 use arena::TypedArena;
diff --git a/src/librustc/driver/pretty.rs b/src/librustc/driver/pretty.rs
index a3227e4..8400650 100644
--- a/src/librustc/driver/pretty.rs
+++ b/src/librustc/driver/pretty.rs
@@ -313,6 +313,7 @@ fn gather_flowgraph_variants(sess: &Session) -> Vec<borrowck_dot::Variant> {
     let print_loans   = config::FLOWGRAPH_PRINT_LOANS;
     let print_moves   = config::FLOWGRAPH_PRINT_MOVES;
     let print_assigns = config::FLOWGRAPH_PRINT_ASSIGNS;
+    let print_needs_drop = config::FLOWGRAPH_PRINT_NEEDS_DROP;
     let print_all     = config::FLOWGRAPH_PRINT_ALL;
     let opt = |print_which| sess.debugging_opt(print_which);
     let mut variants = Vec::new();
@@ -325,6 +326,9 @@ fn gather_flowgraph_variants(sess: &Session) -> Vec<borrowck_dot::Variant> {
     if opt(print_all) || opt(print_assigns) {
         variants.push(borrowck_dot::Assigns);
     }
+    if opt(print_all) || opt(print_needs_drop) {
+        variants.push(borrowck_dot::NeedsDrop);
+    }
     variants
 }
 
diff --git a/src/librustc/driver/session.rs b/src/librustc/driver/session.rs
index 135e21e..5b2ac9f 100644
--- a/src/librustc/driver/session.rs
+++ b/src/librustc/driver/session.rs
@@ -82,6 +82,12 @@ impl Session {
     pub fn abort_if_errors(&self) {
         self.diagnostic().handler().abort_if_errors()
     }
+    pub fn opt_span_warn(&self, opt_sp: Option<Span>, msg: &str) {
+        match opt_sp {
+            Some(sp) => self.span_warn(sp, msg),
+            None => self.warn(msg),
+        }
+    }
     pub fn span_warn(&self, sp: Span, msg: &str) {
         self.diagnostic().span_warn(sp, msg)
     }
@@ -103,6 +109,12 @@ impl Session {
     pub fn note(&self, msg: &str) {
         self.diagnostic().handler().note(msg)
     }
+    pub fn opt_span_bug(&self, opt_sp: Option<Span>, msg: &str) -> ! {
+        match opt_sp {
+            Some(sp) => self.span_bug(sp, msg),
+            None => self.bug(msg),
+        }
+    }
     pub fn span_bug(&self, sp: Span, msg: &str) -> ! {
         self.diagnostic().span_bug(sp, msg)
     }
diff --git a/src/librustc/lint/builtin.rs b/src/librustc/lint/builtin.rs
index c3c4cf5..ded7044 100644
--- a/src/librustc/lint/builtin.rs
+++ b/src/librustc/lint/builtin.rs
@@ -618,6 +618,7 @@ impl LintPass for UnusedAttribute {
             "must_use",
             "stable",
             "unstable",
+            "quiet_early_drop",
         ];
 
         static CRATE_ATTRS: &'static [&'static str] = &[
@@ -954,7 +955,7 @@ impl LintPass for NonSnakeCase {
         match &p.node {
             &ast::PatIdent(_, ref path1, _) => {
                 match cx.tcx.def_map.borrow().find(&p.id) {
-                    Some(&def::DefLocal(_, _)) | Some(&def::DefBinding(_, _)) |
+                    Some(&def::DefLocal(_, _)) | Some(&def::DefBinding(_, _, _)) |
                             Some(&def::DefArg(_, _)) => {
                         self.check_snake_case(cx, "variable", path1.node, p.span);
                     }
@@ -1554,6 +1555,12 @@ declare_lint!(pub VISIBLE_PRIVATE_TYPES, Warn,
 declare_lint!(pub UNREACHABLE_CODE, Warn,
               "detects unreachable code")
 
+declare_lint!(pub QUIET_EARLY_DROP, Allow,
+              "detect (soon to be) early drops of #[quiet_early_drop] types")
+
+declare_lint!(pub UNMARKED_EARLY_DROP, Warn,
+              "detect (soon to be) early drops of non-#[quiet_early_drop] types")
+
 declare_lint!(pub WARNINGS, Warn,
               "mass-change the level for lints which produce warnings")
 
@@ -1582,6 +1589,8 @@ impl LintPass for HardwiredLints {
             UNUSED_VARIABLE,
             DEAD_ASSIGNMENT,
             DEAD_CODE,
+            QUIET_EARLY_DROP,
+            UNMARKED_EARLY_DROP,
             VISIBLE_PRIVATE_TYPES,
             UNREACHABLE_CODE,
             WARNINGS,
diff --git a/src/librustc/middle/astencode.rs b/src/librustc/middle/astencode.rs
index 0e64be3..fea4a12 100644
--- a/src/librustc/middle/astencode.rs
+++ b/src/librustc/middle/astencode.rs
@@ -476,7 +476,10 @@ impl tr for def::Def {
           def::DefTy(did) => def::DefTy(did.tr(xcx)),
           def::DefPrimTy(p) => def::DefPrimTy(p),
           def::DefTyParam(s, did, v) => def::DefTyParam(s, did.tr(xcx), v),
-          def::DefBinding(nid, bm) => def::DefBinding(xcx.tr_id(nid), bm),
+          def::DefBinding(nid, bm, def::Original) => def::DefBinding(xcx.tr_id(nid), bm, def::Original),
+          def::DefBinding(nid, bm, def::Aliasing(oid)) => {
+            def::DefBinding(xcx.tr_id(nid), bm, def::Aliasing(xcx.tr_id(oid)))
+          },
           def::DefUse(did) => def::DefUse(did.tr(xcx)),
           def::DefUpvar(nid1, def, nid2, nid3) => {
             def::DefUpvar(xcx.tr_id(nid1),
diff --git a/src/librustc/middle/borrowck/check_drops.rs b/src/librustc/middle/borrowck/check_drops.rs
new file mode 100644
index 0000000..b3d5527
--- /dev/null
+++ b/src/librustc/middle/borrowck/check_drops.rs
@@ -0,0 +1,676 @@
+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT
+// file at the top-level directory of this distribution and at
+// http://rust-lang.org/COPYRIGHT.
+//
+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
+// option. This file may not be copied, modified, or distributed
+// except according to those terms.
+
+#![allow(unused_imports)]
+#![allow(unused_variable)]
+
+use metadata::csearch;
+use middle::borrowck::*;
+use middle::borrowck::move_data::{Assignment, Move};
+use middle::expr_use_visitor as euv;
+use lint;
+use middle::mem_categorization as mc;
+use middle::dataflow;
+use middle::graph;
+use middle::lang_items::QuietEarlyDropTraitLangItem;
+use middle::cfg;
+use middle::subst::Subst;
+use middle::subst;
+use middle::ty;
+use middle::ty::TypeContents;
+use middle::typeck::check;
+use middle::typeck::infer;
+use middle::typeck;
+use middle::typeck::check::vtable::relate_trait_refs; // FIXME
+use middle::typeck::check::vtable::connect_trait_tps; // FIXME
+use middle::typeck::check::vtable::fixup_substs; // FIXME
+use middle::typeck::check::vtable::fixup_ty; // FIXME
+use middle::typeck::check::vtable::lookup_vtable_from_bounds; // FIXME
+use middle::typeck::check::vtable::lookup_vtable; // FIXME
+// use middle::typeck::check::vtable; // FIXME for some reason this is failing.  :(
+use middle::typeck::check;
+use util::ppaux::Repr;
+use util::nodemap::DefIdMap;
+
+use std::cell::RefCell;
+use std::rc::Rc;
+use std::collections::hashmap::HashMap;
+use std::sync::atomics;
+use syntax::{ast,ast_map,ast_util,codemap};
+use syntax::attr::AttrMetaMethods;
+
+static mut warning_count: atomics::AtomicUint = atomics::INIT_ATOMIC_UINT;
+
+pub fn check_drops(bccx: &BorrowckCtxt,
+                   flowed_move_data: &move_data::FlowedMoveData,
+                   id: ast::NodeId,
+                   cfg: &cfg::CFG,
+                   decl: &ast::FnDecl,
+                   body: &ast::Block) {
+    debug!("check_drops(body id={:?})", body.id);
+
+    let param_env;
+
+    let mut cursor_id = id;
+    loop {
+        match bccx.tcx.map.find(cursor_id) {
+            Some(ast_map::NodeItem(..)) => {
+                let fn_pty = ty::lookup_item_type(bccx.tcx, ast_util::local_def(cursor_id));
+                let generics = &fn_pty.generics;
+                param_env = ty::construct_parameter_environment(bccx.tcx, generics, body.id);
+                break;
+            }
+
+            // FIXME (pnkfelix): There used to be cut-and-pasted code
+            // here that did the same thing as NodeItem case above,
+            // but for NodeMethod and NodeTraitMethod. Those variants
+            // do not exist anymore, but presumably they are still
+            // separate cases under a different name.
+
+            Some(_) => {
+                cursor_id = bccx.tcx.map.get_parent(cursor_id);
+                continue;
+            }
+            None => {
+                fail!("could not find param_env for node {}", id);
+            }
+        }
+    };
+
+    cfg.graph.each_node(|node_index, node| {
+        // Special case: do not flag violations for control flow from
+        // return expressions.  Each return can be prefixed with
+        // separate destructor invocation code specialized to whatever
+        // paths need dropping.
+        if node_index == cfg.exit {
+            return true;
+        }
+
+        // Do not bother doing the query for unreachable portions of
+        // the control flow graph.
+        if !cfg.is_reachable(node_index) {
+            return true;
+        }
+
+        // First, figure out if there is >1 incoming edge.
+        {
+            let mut how_many = 0u;
+            cfg.graph.each_incoming_edge(node_index, |_edge_index, _edge| {
+                how_many += 1;
+                how_many <= 1 // keep looking until we see >1.
+            });
+
+            if how_many <= 1 {
+                return true;
+            }
+        }
+
+        // Okay, >1 incoming edge.
+        //
+        // Now we need to verify that all predecessor nodes establish
+        // the same set of destruction obligations for the current
+        // scope.
+        //
+        // We could just do a pairwise comparison, e.g. assume that the
+        // first incoming edge is correct, then compare (1st, 2nd);
+        // (2nd, 3rd); etc, until we encounter a difference, and then
+        // report that as an error.
+        //
+        // However, under the (not yet validated) assumption that most
+        // errors that we see will be missing calls to drop, we adopt
+        // a different strategy: First, compute the intersection `I`
+        // of the destruction obligations for all incoming edges.
+        // Then compare each edge's destruction obligations against
+        // `I`, and report all extra entries as needing to be
+        // explicitly dropped on this edge (or to be reconstructed on
+        // the edges where it was moved away).
+
+        let move_data = &flowed_move_data.move_data;
+        let needs_drop = &flowed_move_data.dfcx_needs_drop;
+        let ignore_drop = &flowed_move_data.dfcx_ignore_drop;
+        let path_count = move_data.paths.borrow().len();
+
+        let intersection = needs_drop.bitset_for(dataflow::Entry, node_index);
+
+        // In theory, that should be all we need to do; i.e. at this
+        // point we should be able to compare each incoming node's
+        // exit state with the computed intersection, and report any
+        // deviation we see.
+        //
+        // HOWEVER: match arms complicate things.  In principle the
+        // bindings introduced by the bindings on a match arm are
+        // scoped to the match arm, and so for code like this:
+        //
+        //    match s {
+        //        Ok(x)  => { Some(x) },
+        //        Err(s) => { None },
+        //    }
+        //
+        // you might expect that the `s` on the `Err(s)` branch is
+        // dropped at the end of that arm.
+        //
+        // That's not how things are represented in the compiler,
+        // unfortunately for us here; instead, the compiler see's the
+        // lifetime of `s` as being the entire match expression, with
+        // the drop of `s` tied to the flowgraph node for the match
+        // itself, not each arm.
+        //
+        // pnkfelix tried to hack in support for representing the
+        // narrower scope of each arm that fits his mental model, but
+        // encountered some problems.
+        //
+        // So instead, we take this approach: instead of comparing
+        // each incoming edge to the intersection above directly, now
+        // compare each incoming edge to the intersection *after*
+        // applying the kill bits for this merge point to both sides.
+        // pnkfelix calls this "equivalence modulo merge-kills"
+        //
+        // This should take care of match patterns that will be
+        // automatically destroyed, while leaving paths with a broader
+        // scope than the match preserved.
+        //
+        // UPDATE: There is actually a more general principle we can
+        // apply here, without worrying about match-arms: simply
+        // walking forward looking if the end-of-scope for the
+        // variable comes before any other side-effect.  If so, then
+        // we can safely auto-drop without warning the user, since the
+        // net effect is the same as if we still had a drop-flag.
+
+        let mut intersection = intersection;
+        needs_drop.apply_gen_kill(node_index, intersection.as_mut_slice());
+        let intersection = intersection;
+
+        cfg.graph.each_incoming_edge(node_index, |edge_index, edge| {
+            let source = edge.source();
+            let mut temp = needs_drop.bitset_for(dataflow::Exit, source);
+
+            // see note above about "equivalence modulo merge-kills"
+            //
+            // But also, this hack can probably go away with new
+            // "scan-ahead-for-scope-end" rule
+            needs_drop.apply_gen_kill(node_index, temp.as_mut_slice());
+
+            if temp != intersection {
+                let source_id = cfg.graph.node(source).data.id;
+                let opt_source_span = bccx.tcx.map.opt_span(source_id);
+                needs_drop.each_bit_for_node(dataflow::Exit, source, |bit_idx| {
+                    if !cfg.is_reachable(source) ||
+                        dataflow::is_bit_set(intersection.as_slice(), bit_idx) {
+                        return true;
+                    }
+
+                    let paths = move_data.paths.borrow();
+                    let path = paths.get(bit_idx);
+                    let lp = &path.loan_path;
+
+                    let ignored_paths = ignore_drop.bitset_for(dataflow::Exit, source);
+                    if dataflow::is_bit_set(ignored_paths.as_slice(), bit_idx) {
+                        debug!("check_drops can ignore lp={} as it is non-drop on this path.",
+                               lp.repr(bccx.tcx));
+                        return true;
+                    }
+
+                    // Check if there is a single effect-free
+                    // successor chain that leads to the end of the
+                    // scope of the local variable at the base of `lp`
+                    // (and therefore we can safely auto-drop `lp`
+                    // without warning the user)
+                    let kill_id = lp.kill_id(bccx.tcx);
+                    match scan_forward_for_kill_id(bccx, cfg, node_index, kill_id)
+                    {
+                        FoundScopeEndPure => {
+                            debug!("check_drops can ignore lp={} as its scope-end is imminent.",
+                                   lp.repr(bccx.tcx));
+                            return true;
+                        }
+                        AbandonedScan => {}
+                    }
+
+                    // At this point, we are committed to reporting a warning to the user
+                    let count = unsafe {
+                        warning_count.fetch_add(1, atomics::Relaxed) + 1
+                    };
+
+                    let loan_path_str = bccx.loan_path_to_string(lp.deref());
+
+                    let cfgidx_and_id = format!(" (cfgidx={}, id={})", source, source_id);
+                    let where_ = if bccx.tcx.sess.verbose() {
+                        cfgidx_and_id.as_slice()
+                    } else {
+                        ""
+                    };
+
+                    let msg = format!("Storage at `{:s}` is left initialized on some paths \
+                                       exiting here{:s}, but uninitialized on others. \
+                                       (Consider either using Option, or calling `drop()` \
+                                       on it or reinitializing it as necessary); count: {}",
+                                      loan_path_str, where_, count);
+
+                    // Check if type of `lp` has #[quiet_early_drop]
+                    // attribute or implements `QuietEarlyDrop`;
+                    // select the appropriate lint to signal.
+                    let lint_category = if is_quiet_early_drop_lp(bccx.tcx, &param_env, &**lp) {
+                        lint::builtin::QUIET_EARLY_DROP
+                    } else {
+                        lint::builtin::UNMARKED_EARLY_DROP
+                    };
+                    bccx.tcx.sess.add_lint(lint_category,
+                                           source_id,
+                                           opt_source_span.unwrap_or(codemap::DUMMY_SP),
+                                           msg);
+
+                    if false { cfg.graph.each_incoming_edge(node_index, |edge_index, edge| {
+                        let source2 = edge.source();
+                        if !cfg.is_reachable(source2) {
+                            return true;
+                        }
+
+                        let temp2 = needs_drop.bitset_for(dataflow::Exit, source2);
+                        let mut count = 0u;
+                        if !dataflow::is_bit_set(temp2.as_slice(), bit_idx) {
+                            count += 1;
+                            let source2_id = cfg.graph.node(source2).data.id;
+                            let opt_source2_span = bccx.tcx.map.opt_span(source2_id);
+                            let cfgidx_and_id = format!(" (cfgidx={}, id={})",
+                                                        source2, source2_id);
+                            let where_ = if bccx.tcx.sess.verbose() {
+                                cfgidx_and_id.as_slice()
+                            } else {
+                                ""
+                            };
+                            let msg = format!("Path {:u} here{:s} leaves `{:s}` \
+                                               uninitialized.",
+                                              count, where_, loan_path_str);
+                            match opt_source2_span {
+                                Some(span) => bccx.tcx.sess.span_note(span, msg.as_slice()),
+                                None => bccx.tcx.sess.note(msg.as_slice()),
+                            }
+                        }
+                        true
+                    }); }
+
+                    true
+                });
+            }
+
+            true
+        });
+
+        true
+    });
+}
+
+// This uses an enum rather than a bool to support future handling of
+// walking over paths with potentially significant effects; e.g. see
+// notes below with ExprPath.
+#[deriving(PartialEq)]
+enum ForwardScanResult {
+    FoundScopeEndPure,
+    AbandonedScan,
+}
+
+fn scan_forward_for_kill_id(bccx: &BorrowckCtxt,
+                            cfg: &cfg::CFG,
+                            start: cfg::CFGIndex,
+                            kill_id: ast::NodeId) -> ForwardScanResult {
+    //! returns true only if there is a unique effect-free successor
+    //! chain from `start` to `kill_id` or to `cfg.exit`
+
+    let mut cursor = start;
+    loop {
+        debug!("fwd-scan for kill_id={} cursor={}", kill_id, cursor);
+        let mut count = 0u;
+        let mut successor = None;
+        cfg.graph.each_outgoing_edge(cursor, |edge_index, edge| {
+            debug!("fwd-scan cursor={} edge.target={}", cursor, edge.target());
+            successor = Some(edge_index);
+            count += 1;
+            count <= 1
+        });
+
+        if count != 1 {
+            debug!("fwd-scan: broken successor chain; give up");
+            return AbandonedScan;
+        }
+
+        cursor = cfg.graph.edge(successor.unwrap()).target();
+        if cursor == cfg.exit {
+            debug!("fwd-scan: success (hit exit), no need for warning");
+            return FoundScopeEndPure;
+        }
+
+        let successor_id = cfg.graph.node(cursor).data.id;
+        if successor_id == ast::DUMMY_NODE_ID {
+            debug!("fwd-scan: dummy node in flow graph; give up");
+            return AbandonedScan;
+        }
+
+        if successor_id == kill_id {
+            debug!("fwd-scan: success (hit {}), no need for warning", kill_id);
+            return FoundScopeEndPure;
+        }
+
+        match bccx.tcx.map.get(successor_id) {
+            // See notes below about ExprPath handling.  Note that
+            // NodeLocal and NodeArg correespond to binding sites, not
+            // uses. Skipping these is likely to not matter too much
+            // until some ExprPath's are treated as pure.
+            ast_map::NodeLocal(_) |
+            ast_map::NodeArg(_)   |
+            ast_map::NodeBlock(_) => {
+                debug!("fwd-scan: node {} effect-free; continue looking",
+                       successor_id);
+                continue;
+            }
+
+            ast_map::NodeExpr(e) => {
+                // Keep in mind when reading these cases that the
+                // NodeId associated with an expression node like
+                // ExprIf is at the *end* of the expression, where the
+                // two arms of the if meet.
+                match e.node {
+                    // node is where arms of match meet.
+                    ast::ExprMatch(..) |
+                    // node is where block exits.
+                    ast::ExprBlock(..) |
+                    // (<expr>) is definitely pure.
+                    ast::ExprParen(..) |
+                    // node is after arg is evaluated; before return itself.
+                    ast::ExprRet(..)   |
+                    // node is where arms of if meet.
+                    ast::ExprIf(..) => {
+                        debug!("fwd-scan: expr {} effect-free; \
+                                continue looking",
+                               successor_id);
+                        continue;
+                    }
+
+                    // variable lookup
+                    ast::ExprPath(ref p) => {
+                        // Strictly speaking, this is an observable
+                        // effect. In particular, if a destructor has
+                        // access to the address of this path and
+                        // imperatively overwrites it, then a client
+                        // will care about the drop order.
+                        //
+                        // A captured `&mut`-ref cannot actually alias
+                        // such a path, according to Rust's borrowing
+                        // rules. Therefore, the scenario only arises
+                        // with either (1.) a `*mut`-pointer or (2.) a
+                        // `&`-ref to a type with interior mutability
+                        // (type_interior_is_unsafe). Still, it can
+                        // arise.
+                        //
+                        // The easy conservative approach is to simply
+                        // treat this as an effect and abandon the
+                        // forward-scan.
+
+                        // FIXME: A less-conservative but still sound
+                        // approach would be to treat reads of
+                        // non-local variables that had never been
+                        // borrowed as effect-free as well, and it
+                        // would probably cover many cases of
+                        // interest.  We can put that in later
+                        // (pnkfelix).
+
+                        // FIXME: A "less sound" but potentially
+                        // useful approach would be to further tier
+                        // the lint structure here to allow the user
+                        // to specify whether all variable-reads
+                        // should be treated as pure.  But I am
+                        // hesistant to make that part of the default
+                        // set of lints, at least for now (pnkfelix).
+
+                        debug!("fwd-scan: expr {} path read {} \
+                                potentially effectful; give up",
+                               successor_id, p);
+
+                        return AbandonedScan;
+                    }
+
+                    _ => {
+                        debug!("fwd-scan: expr {} potentially effectful; \
+                                give up",
+                               successor_id);
+                        return AbandonedScan;
+                    }
+
+                }
+            }
+
+            ast_map::NodeStmt(_)       |
+            ast_map::NodePat(_) |
+            ast_map::NodeStructCtor(_) => {
+                debug!("fwd-scan: node {} potentially effectful; give up",
+                       successor_id);
+                return AbandonedScan;
+            }
+
+            ast_map::NodeItem(_)        | ast_map::NodeForeignItem(_) |
+            ast_map::NodeVariant(_)     | ast_map::NodeLifetime(_) => {
+                bccx.tcx.sess.bug("unexpected node")
+            }
+        }
+    }
+}
+
+fn is_quiet_early_drop_lp(tcx: &ty::ctxt,
+                          param_env: &ty::ParameterEnvironment,
+                          lp: &LoanPath) -> bool {
+    let t = lp.to_type(tcx);
+    let ret = is_quiet_early_drop_ty(tcx, param_env, t);
+    debug!("is_quiet_early_drop_lp: {} is {}", lp.repr(tcx), ret);
+    ret
+}
+
+
+fn is_quiet_early_drop_ty(tcx: &ty::ctxt,
+                          param_env: &ty::ParameterEnvironment,
+                          t: ty::t) -> bool {
+    match ty::get(t).sty {
+        ty::ty_struct(did, _) |
+        ty::ty_enum(did, _) => {
+            let found_attr = with_attrs_for_did(tcx, did, |attrs| {
+                for attr in attrs.iter() {
+                    if attr.check_name("quiet_early_drop") {
+                        return true
+                    }
+                }
+                return false;
+            });
+            if found_attr {
+                return true;
+            }
+        }
+        _ => {}
+    }
+
+    // Okay, so far we know that the type does not have the
+    // `quiet_early_drop` attribute marker.
+
+    let opt_trait_did = tcx.lang_items.require(QuietEarlyDropTraitLangItem);
+    let trait_did = match opt_trait_did {
+        Ok(trait_did) => trait_did,
+        Err(_) => {
+            // if there is no `QuietEarlyDrop` lang item, then
+            // just do not bother trying to handle this case.
+            return false;
+        }
+    };
+    is_quiet_early_drop_ty_recur(tcx, param_env, trait_did, t)
+}
+
+fn is_quiet_early_drop_ty_recur(tcx: &ty::ctxt,
+                                param_env: &ty::ParameterEnvironment,
+                                trait_did: ast::DefId,
+                                t: ty::t) -> bool {
+
+    // The main base case: if the type implements `QuietEarlyDrop`,
+    // then we stop looking.
+    let implements = type_implements_trait(tcx, param_env, t, trait_did);
+    debug!("is_quiet_early_drop_ty_recur: type_implements_trait({}) is {}",
+           t.repr(tcx), implements);
+    if implements {
+        return true;
+    }
+
+    // If it does not implement the QuietEarlyDrop trait, then we need
+    // to emulate the traversal done by `type_contents`, looking at
+    // the substructure of the type to see if the type (or any part of
+    // it) "drops loudly", i.e., implements Drop but does not
+    // implement QuietEarlyDrop.
+
+    let drops_quiet = || {
+        let ret = true;
+        debug!("is_quiet_early_drop_ty_recur: {} fallthru base case: {}", t.repr(tcx), ret);
+        ret
+    };
+
+    let drops_loud = || {
+        let ret = false;
+        debug!("is_quiet_early_drop_ty_recur: {} fallthru base case: {}", t.repr(tcx), ret);
+        ret
+    };
+
+    let drops_recur = |f:|| -> bool| {
+        debug!("is_quiet_early_drop_ty_recur: {} fallthru recur entry", t.repr(tcx));
+        let ret = f();
+        debug!("is_quiet_early_drop_ty_recur: {} fallthru recur ret: {}", t.repr(tcx), ret);
+        ret
+    };
+
+    let recur = |ty| is_quiet_early_drop_ty_recur(tcx, param_env, trait_did, ty);
+
+    match ty::get(t).sty {
+        ty::ty_nil |
+        ty::ty_bot |
+        ty::ty_bool |
+        ty::ty_char |
+        ty::ty_int(_) |
+        ty::ty_uint(_) |
+        ty::ty_float(_) |
+        ty::ty_str |
+        ty::ty_bare_fn(_) |
+        ty::ty_rptr(_, _) |
+        ty::ty_err => drops_quiet(),
+
+        ty::ty_box(_) |
+        ty::ty_uniq(_) |
+        ty::ty_ptr(_) |
+        ty::ty_infer(_) |
+        ty::ty_unboxed_closure(..) => drops_loud(),
+
+        ty::ty_param(_) => drops_loud(),
+
+        ty::ty_trait(_) => drops_loud(),
+
+        ty::ty_closure(ref f) => {
+            match f.store {
+                // by-ref closure
+                ty::RegionTraitStore(..) => drops_quiet(),
+                ty::UniqTraitStore => drops_loud(),
+            }
+        }
+
+        // (Below are all the potentially recursive cases)
+
+        ty::ty_tup(ref tys) => drops_recur(|| tys.iter().all(|&ty| recur(ty))),
+        ty::ty_vec(ty, opt_len) => drops_recur(|| recur(ty)),
+
+        ty::ty_enum(def_id, ref substs) => {
+            // if this type *itself* has a dtor, but does not
+            // implment `QuietEarlyDrop`, then it must drop loudly.
+            if ty::has_dtor(tcx, def_id) {
+                drops_loud()
+            } else {
+                let variants = ty::substd_enum_variants(tcx, def_id, substs);
+                drops_recur(|| variants.iter()
+                            .flat_map(|v| v.args.iter())
+                            .all(|&ty| recur(ty)))
+            }
+        }
+
+        ty::ty_struct(def_id, ref substs) => {
+            // if this type *itself* has a dtor, but does not
+            // implment `QuietEarlyDrop`, then it must drop loudly.
+            if ty::has_dtor(tcx, def_id) {
+                drops_loud()
+            } else {
+                drops_recur(|| ty::struct_fields(tcx, def_id, substs).iter()
+                            .map(|field| field.mt.ty)
+                            .all(|ty| recur(ty)))
+            }
+        }
+
+    }
+}
+
+fn with_attrs_for_did<A>(tcx: &ty::ctxt,
+                         did: ast::DefId,
+                         f: |&[ast::Attribute]| -> A) -> A {
+    if ast_util::is_local(did) {
+        match tcx.map.get(did.node) {
+            ast_map::NodeItem(it) => f(it.attrs.as_slice()),
+            _ => fail!("must have entry for struct or enum"),
+        }
+    } else {
+        // FIXME: interface of `get_item_attrs` could be generalized
+        // to support this directly.
+        let mut result = None;
+        csearch::get_item_attrs(&tcx.sess.cstore, did, |attrs| {
+            result = Some(f(attrs.as_slice()))
+        });
+        result.unwrap()
+    }
+}
+
+fn type_implements_trait(tcx: &ty::ctxt,
+                         param_env: &ty::ParameterEnvironment,
+                         ty: ty::t,
+                         trait_did: ast::DefId) -> bool {
+    // largely modelled after lookup_vtable
+
+    let infcx = infer::new_infer_ctxt(tcx);
+    let span = codemap::DUMMY_SP;
+    let substs = subst::Substs::empty();
+
+    let trait_def = ty::lookup_trait_def(tcx, trait_did);
+    let trait_ref = &trait_def.trait_ref;
+
+    debug!("type_implements_trait ty={} trait_ref={}",
+           ty.repr(tcx),
+           trait_ref.repr(tcx));
+
+    ty::populate_implementations_for_trait_if_necessary(tcx, trait_ref.def_id);
+
+    let substs = substs.with_self_ty(ty);
+
+    // Substitute the values of the type parameters that may
+    // appear in the bound.
+    debug!("about to subst: {}, {}", trait_ref.repr(tcx), substs.repr(tcx));
+    let trait_ref = trait_ref.subst(tcx, &substs);
+
+    debug!("after subst: {}", trait_ref.repr(tcx));
+
+    let unboxed_closures = RefCell::new(DefIdMap::new());
+
+    let vcx = check::vtable::VtableContext {
+        infcx: &infcx,
+        param_bounds: &param_env.bounds,
+        unboxed_closures: &unboxed_closures,
+        is_early: check::vtable::NotEarly,
+        if_missing_ty_param: check::vtable::IfMissingTyParamGiveUp,
+    };
+
+    match lookup_vtable(&vcx, span, ty, trait_ref) {
+        Ok(Some(_)) => true,
+        Ok(None) | Err(_) => false,
+    }
+}
diff --git a/src/librustc/middle/borrowck/check_loans.rs b/src/librustc/middle/borrowck/check_loans.rs
index df637e7..2e3357d 100644
--- a/src/librustc/middle/borrowck/check_loans.rs
+++ b/src/librustc/middle/borrowck/check_loans.rs
@@ -44,7 +44,7 @@ fn owned_ptr_base_path<'a>(loan_path: &'a LoanPath) -> &'a LoanPath {
 
     fn owned_ptr_base_path_helper<'a>(loan_path: &'a LoanPath) -> Option<&'a LoanPath> {
         match *loan_path {
-            LpVar(_) | LpUpvar(_) => None,
+            LpVar(_) | LpUpvar(..) => None,
             LpExtend(ref lp_base, _, LpDeref(mc::OwnedPtr)) => {
                 match owned_ptr_base_path_helper(&**lp_base) {
                     v @ Some(_) => v,
@@ -67,7 +67,7 @@ fn owned_ptr_base_path_rc(loan_path: &Rc<LoanPath>) -> Rc<LoanPath> {
 
     fn owned_ptr_base_path_helper(loan_path: &Rc<LoanPath>) -> Option<Rc<LoanPath>> {
         match **loan_path {
-            LpVar(_) | LpUpvar(_) => None,
+            LpVar(_) | LpUpvar(..) => None,
             LpExtend(ref lp_base, _, LpDeref(mc::OwnedPtr)) => {
                 match owned_ptr_base_path_helper(lp_base) {
                     v @ Some(_) => v,
@@ -98,6 +98,12 @@ impl<'a, 'tcx> euv::Delegate for CheckLoanCtxt<'a, 'tcx> {
         self.consume_common(consume_id, consume_span, cmt, mode);
     }
 
+    fn matched_pat(&mut self,
+                   _matched_pat: &ast::Pat,
+                   _cmt: mc::cmt,
+                   _mode: euv::MatchMode) { }
+
+
     fn consume_pat(&mut self,
                    consume_pat: &ast::Pat,
                    cmt: mc::cmt,
@@ -123,7 +129,7 @@ impl<'a, 'tcx> euv::Delegate for CheckLoanCtxt<'a, 'tcx> {
                borrow_id, cmt.repr(self.tcx()), loan_region,
                bk, loan_cause);
 
-        match opt_loan_path(&cmt) {
+        match opt_loan_path(&cmt, self.tcx()) {
             Some(lp) => {
                 let moved_value_use_kind = match loan_cause {
                     euv::ClosureCapture(_) => MovedInCapture,
@@ -146,7 +152,7 @@ impl<'a, 'tcx> euv::Delegate for CheckLoanCtxt<'a, 'tcx> {
         debug!("mutate(assignment_id={}, assignee_cmt={})",
                assignment_id, assignee_cmt.repr(self.tcx()));
 
-        match opt_loan_path(&assignee_cmt) {
+        match opt_loan_path(&assignee_cmt, self.tcx()) {
             Some(lp) => {
                 match mode {
                     euv::Init | euv::JustWrite => {
@@ -294,9 +300,13 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {
         let mut loan_path = loan_path;
         loop {
             match *loan_path {
-                LpVar(_) | LpUpvar(_) => {
+                LpVar(_) | LpUpvar(..) => {
                     break;
                 }
+                LpDowncast(ref lp_base, _) => {
+                    loan_path = &**lp_base;
+                    continue;
+                }
                 LpExtend(ref lp_base, _, _) => {
                     loan_path = &**lp_base;
                 }
@@ -526,7 +536,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {
                       span: Span,
                       cmt: mc::cmt,
                       mode: euv::ConsumeMode) {
-        match opt_loan_path(&cmt) {
+        match opt_loan_path(&cmt, self.tcx()) {
             Some(lp) => {
                 let moved_value_use_kind = match mode {
                     euv::Copy => {
@@ -687,9 +697,13 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {
          */
 
         match **lp {
-            LpVar(_) | LpUpvar(_) => {
+            LpVar(_) | LpUpvar(..) => {
                 // assigning to `x` does not require that `x` is initialized
             }
+            LpDowncast(ref lp_base, _) => {
+                self.check_if_assigned_path_is_moved(id, span,
+                                                     use_kind, lp_base);
+            }
             LpExtend(ref lp_base, _, LpInterior(_)) => {
                 // assigning to `P.f` is ok if assigning to `P` is ok
                 self.check_if_assigned_path_is_moved(id, span,
@@ -732,7 +746,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {
         // if they cannot already have been assigned
         if self.is_local_variable_or_arg(assignee_cmt.clone()) {
             assert!(assignee_cmt.mutbl.is_immutable()); // no "const" locals
-            let lp = opt_loan_path(&assignee_cmt).unwrap();
+            let lp = opt_loan_path(&assignee_cmt, self.tcx()).unwrap();
             self.move_data.each_assignment_of(assignment_id, &lp, |assign| {
                 self.bccx.report_reassigned_immutable_variable(
                     assignment_span,
@@ -744,7 +758,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {
         }
 
         // Otherwise, just a plain error.
-        match opt_loan_path(&assignee_cmt) {
+        match opt_loan_path(&assignee_cmt, self.tcx()) {
             Some(lp) => {
                 self.bccx.span_err(
                     assignment_span,
@@ -804,7 +818,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {
                         cmt = b;
                     }
 
-                    mc::cat_downcast(b) |
+                    mc::cat_downcast(b, _) |
                     mc::cat_interior(b, _) => {
                         assert_eq!(cmt.mutbl, mc::McInherited);
                         cmt = b;
@@ -864,7 +878,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {
             //! Check for assignments that violate the terms of an
             //! outstanding loan.
 
-            let loan_path = match opt_loan_path(&assignee_cmt) {
+            let loan_path = match opt_loan_path(&assignee_cmt, this.tcx()) {
                 Some(lp) => lp,
                 None => { return; /* no loan path, can't be any loans */ }
             };
diff --git a/src/librustc/middle/borrowck/gather_loans/gather_moves.rs b/src/librustc/middle/borrowck/gather_loans/gather_moves.rs
index f58cc95..f007a0f 100644
--- a/src/librustc/middle/borrowck/gather_loans/gather_moves.rs
+++ b/src/librustc/middle/borrowck/gather_loans/gather_moves.rs
@@ -13,8 +13,9 @@
  */
 
 use middle::borrowck::*;
-use middle::borrowck::gather_loans::move_error::MoveSpanAndPath;
 use middle::borrowck::gather_loans::move_error::{MoveError, MoveErrorCollector};
+use middle::borrowck::gather_loans::move_error::{MoveSpanAndIdent, MoveTarget};
+use middle::borrowck::gather_loans::move_error::{MoveTargetIdent, MoveTargetWildcard};
 use middle::borrowck::move_data::*;
 use middle::expr_use_visitor as euv;
 use middle::mem_categorization as mc;
@@ -29,7 +30,7 @@ struct GatherMoveInfo {
     id: ast::NodeId,
     kind: MoveKind,
     cmt: mc::cmt,
-    span_path_opt: Option<MoveSpanAndPath>
+    span_path_opt: Option<MoveTarget>
 }
 
 pub fn gather_decl(bccx: &BorrowckCtxt,
@@ -60,6 +61,35 @@ pub fn gather_move_from_expr(bccx: &BorrowckCtxt,
     gather_move(bccx, move_data, move_error_collector, move_info);
 }
 
+pub fn gather_match_variant(bccx: &BorrowckCtxt,
+                                move_data: &MoveData,
+                                _move_error_collector: &MoveErrorCollector,
+                                move_pat: &ast::Pat,
+                                cmt: mc::cmt,
+                                mode: euv::MatchMode) {
+    debug!("gather_match_variant(move_pat={}, cmt={}, mode={})",
+           move_pat.id, cmt.repr(bccx.tcx), mode);
+
+    let opt_lp = opt_loan_path(&cmt, bccx.tcx);
+    let opt_base_lp = match cmt.cat {
+        mc::cat_downcast(ref base_cmt, _variant_def_id) => opt_loan_path(base_cmt, bccx.tcx),
+        _ => fail!("should only encounter move_into_variant on cat_downcast."),
+    };
+    match (opt_lp, opt_base_lp) {
+        (Some(loan_path), Some(base_loan_path)) => {
+            move_data.add_variant_match(bccx.tcx,
+                                        loan_path,
+                                        move_pat.id,
+                                        base_loan_path,
+                                        mode);
+        }
+        (lp, base_lp) => {
+            debug!("add_variant_match body for ({:?}, {:?}) NOT YET IMPLEMENTED", lp, base_lp);
+        }
+    }
+
+}
+
 pub fn gather_move_from_pat(bccx: &BorrowckCtxt,
                             move_data: &MoveData,
                             move_error_collector: &MoveErrorCollector,
@@ -67,8 +97,11 @@ pub fn gather_move_from_pat(bccx: &BorrowckCtxt,
                             cmt: mc::cmt) {
     let pat_span_path_opt = match move_pat.node {
         ast::PatIdent(_, ref path1, _) => {
-            Some(MoveSpanAndPath{span: move_pat.span,
-                                 ident: path1.node})
+            Some(MoveTargetIdent(MoveSpanAndIdent{span: move_pat.span,
+                                                  ident: path1.node}))
+        },
+        ast::PatWild(k) => {
+            Some(MoveTargetWildcard(move_pat.span, move_pat.id, k))
         },
         _ => None,
     };
@@ -101,7 +134,7 @@ fn gather_move(bccx: &BorrowckCtxt,
         None => ()
     }
 
-    match opt_loan_path(&move_info.cmt) {
+    match opt_loan_path(&move_info.cmt, bccx.tcx) {
         Some(loan_path) => {
             move_data.add_move(bccx.tcx, loan_path,
                                move_info.id, move_info.kind);
@@ -152,7 +185,7 @@ fn check_and_get_illegal_move_origin(bccx: &BorrowckCtxt,
             None
         }
 
-        mc::cat_downcast(ref b) |
+        mc::cat_downcast(ref b, _) |
         mc::cat_interior(ref b, _) => {
             match ty::get(b.ty).sty {
                 ty::ty_struct(did, _) | ty::ty_enum(did, _) => {
diff --git a/src/librustc/middle/borrowck/gather_loans/lifetime.rs b/src/librustc/middle/borrowck/gather_loans/lifetime.rs
index e13717e..103a099 100644
--- a/src/librustc/middle/borrowck/gather_loans/lifetime.rs
+++ b/src/librustc/middle/borrowck/gather_loans/lifetime.rs
@@ -81,7 +81,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {
                 Ok(())
             }
 
-            mc::cat_downcast(ref base) |
+            mc::cat_downcast(ref base, _) |
             mc::cat_deref(ref base, _, mc::OwnedPtr) |     // L-Deref-Send
             mc::cat_interior(ref base, _) |                // L-Field
             mc::cat_deref(ref base, _, mc::GcPtr) => {
@@ -185,7 +185,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {
             mc::cat_deref(_, _, mc::Implicit(_, r)) => {
                 r
             }
-            mc::cat_downcast(ref cmt) |
+            mc::cat_downcast(ref cmt, _) |
             mc::cat_deref(ref cmt, _, mc::OwnedPtr) |
             mc::cat_deref(ref cmt, _, mc::GcPtr) |
             mc::cat_interior(ref cmt, _) |
diff --git a/src/librustc/middle/borrowck/gather_loans/mod.rs b/src/librustc/middle/borrowck/gather_loans/mod.rs
index 1118939..26788ea 100644
--- a/src/librustc/middle/borrowck/gather_loans/mod.rs
+++ b/src/librustc/middle/borrowck/gather_loans/mod.rs
@@ -84,6 +84,25 @@ impl<'a, 'tcx> euv::Delegate for GatherLoanCtxt<'a, 'tcx> {
         }
     }
 
+    fn matched_pat(&mut self,
+                   matched_pat: &ast::Pat,
+                   cmt: mc::cmt,
+                   mode: euv::MatchMode) {
+        debug!("matched_pat(matched_pat={}, cmt={}, mode={})",
+               matched_pat.repr(self.tcx()),
+               cmt.repr(self.tcx()),
+               mode);
+
+        match cmt.cat {
+            mc::cat_downcast(..) =>
+                gather_moves::gather_match_variant(
+                    self.bccx, &self.move_data, &self.move_error_collector,
+                    matched_pat, cmt, mode),
+            _ => {}
+        }
+    }
+
+
     fn consume_pat(&mut self,
                    consume_pat: &ast::Pat,
                    cmt: mc::cmt,
@@ -133,7 +152,7 @@ impl<'a, 'tcx> euv::Delegate for GatherLoanCtxt<'a, 'tcx> {
         debug!("mutate(assignment_id={}, assignee_cmt={})",
                assignment_id, assignee_cmt.repr(self.tcx()));
 
-        match opt_loan_path(&assignee_cmt) {
+        match opt_loan_path(&assignee_cmt, self.tcx()) {
             Some(lp) => {
                 gather_moves::gather_assignment(self.bccx, &self.move_data,
                                                 assignment_id, assignment_span,
@@ -398,9 +417,12 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {
 
         match *loan_path {
             LpVar(local_id) |
-            LpUpvar(ty::UpvarId{ var_id: local_id, closure_expr_id: _ }) => {
+            LpUpvar(ty::UpvarId{ var_id: local_id, closure_expr_id: _ }, _) => {
                 self.tcx().used_mut_nodes.borrow_mut().insert(local_id);
             }
+            LpDowncast(ref base, _) => {
+                self.mark_loan_path_as_mutated(&**base);
+            }
             LpExtend(ref base, mc::McInherited, _) => {
                 self.mark_loan_path_as_mutated(&**base);
             }
diff --git a/src/librustc/middle/borrowck/gather_loans/move_error.rs b/src/librustc/middle/borrowck/gather_loans/move_error.rs
index 4f9e51a..ae59e72 100644
--- a/src/librustc/middle/borrowck/gather_loans/move_error.rs
+++ b/src/librustc/middle/borrowck/gather_loans/move_error.rs
@@ -40,12 +40,12 @@ impl MoveErrorCollector {
 
 pub struct MoveError {
     move_from: mc::cmt,
-    move_to: Option<MoveSpanAndPath>
+    move_to: Option<MoveTarget>
 }
 
 impl MoveError {
     pub fn with_move_info(move_from: mc::cmt,
-                          move_to: Option<MoveSpanAndPath>)
+                          move_to: Option<MoveTarget>)
                           -> MoveError {
         MoveError {
             move_from: move_from,
@@ -55,14 +55,39 @@ impl MoveError {
 }
 
 #[deriving(Clone)]
-pub struct MoveSpanAndPath {
+pub enum MoveTarget {
+    MoveTargetIdent(MoveSpanAndIdent),
+    MoveTargetWildcard(codemap::Span, ast::NodeId, ast::PatWildKind),
+}
+
+impl MoveTarget {
+    fn span(&self) -> codemap::Span {
+        match *self {
+            MoveTargetIdent(span_and_ident) => span_and_ident.span,
+            MoveTargetWildcard(span, _, _) => span,
+        }
+    }
+    fn name(&self) -> String {
+        match *self {
+            MoveTargetIdent(span_and_ident) =>
+                pprust::ident_to_string(&span_and_ident.ident),
+            MoveTargetWildcard(_, _, ast::PatWildSingle) =>
+                "_".to_string(),
+            MoveTargetWildcard(_, _, ast::PatWildMulti) =>
+                "..".to_string(),
+        }
+    }
+}
+
+#[deriving(Clone)]
+pub struct MoveSpanAndIdent {
     pub span: codemap::Span,
     pub ident: ast::Ident
 }
 
 pub struct GroupedMoveErrors {
     move_from: mc::cmt,
-    move_to_places: Vec<MoveSpanAndPath>
+    move_to_places: Vec<MoveTarget>
 }
 
 fn report_move_errors(bccx: &BorrowckCtxt, errors: &Vec<MoveError>) {
@@ -71,8 +96,7 @@ fn report_move_errors(bccx: &BorrowckCtxt, errors: &Vec<MoveError>) {
         report_cannot_move_out_of(bccx, error.move_from.clone());
         let mut is_first_note = true;
         for move_to in error.move_to_places.iter() {
-            note_move_destination(bccx, move_to.span,
-                                  &move_to.ident, is_first_note);
+            note_move_destination(bccx, move_to, is_first_note);
             is_first_note = false;
         }
     }
@@ -124,7 +148,7 @@ fn report_cannot_move_out_of(bccx: &BorrowckCtxt, move_from: mc::cmt) {
                         bccx.cmt_to_string(&*move_from)).as_slice());
         }
 
-        mc::cat_downcast(ref b) |
+        mc::cat_downcast(ref b, _) |
         mc::cat_interior(ref b, _) => {
             match ty::get(b.ty).sty {
                 ty::ty_struct(did, _)
@@ -143,10 +167,10 @@ fn report_cannot_move_out_of(bccx: &BorrowckCtxt, move_from: mc::cmt) {
 }
 
 fn note_move_destination(bccx: &BorrowckCtxt,
-                         move_to_span: codemap::Span,
-                         pat_ident: &ast::Ident,
+                         move_to: &MoveTarget,
                          is_first_note: bool) {
-    let pat_name = pprust::ident_to_string(pat_ident);
+    let move_to_span = move_to.span();
+    let pat_name = move_to.name();
     if is_first_note {
         bccx.span_note(
             move_to_span,
diff --git a/src/librustc/middle/borrowck/gather_loans/restrictions.rs b/src/librustc/middle/borrowck/gather_loans/restrictions.rs
index 90e17e4..7487f19 100644
--- a/src/librustc/middle/borrowck/gather_loans/restrictions.rs
+++ b/src/librustc/middle/borrowck/gather_loans/restrictions.rs
@@ -75,7 +75,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {
 
             mc::cat_upvar(upvar_id, _) => {
                 // R-Variable, captured into closure
-                let lp = Rc::new(LpUpvar(upvar_id));
+                let lp = Rc::new(LpUpvar(upvar_id, CaptureByRef));
                 SafeIf(lp.clone(), vec![lp])
             }
 
@@ -85,7 +85,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {
                 SafeIf(lp.clone(), vec![lp])
             }
 
-            mc::cat_downcast(cmt_base) => {
+            mc::cat_downcast(cmt_base, _) => {
                 // When we borrow the interior of an enum, we have to
                 // ensure the enum itself is not mutated, because that
                 // could cause the type of the memory to change.
diff --git a/src/librustc/middle/borrowck/graphviz.rs b/src/librustc/middle/borrowck/graphviz.rs
index e75378d..48aed81 100644
--- a/src/librustc/middle/borrowck/graphviz.rs
+++ b/src/librustc/middle/borrowck/graphviz.rs
@@ -31,14 +31,18 @@ pub enum Variant {
     Loans,
     Moves,
     Assigns,
+    NeedsDrop,
+    IgnoreDrop,
 }
 
 impl Variant {
     pub fn short_name(&self) -> &'static str {
         match *self {
-            Loans   => "loans",
-            Moves   => "moves",
-            Assigns => "assigns",
+            Loans      => "loans",
+            Moves      => "moves",
+            Assigns    => "assigns",
+            NeedsDrop  => "needs_drop",
+            IgnoreDrop => "ignore_drop",
         }
     }
 }
@@ -68,9 +72,11 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {
     fn dataflow_for_variant(&self, e: EntryOrExit, n: &Node, v: Variant) -> String {
         let cfgidx = n.val0();
         match v {
-            Loans   => self.dataflow_loans_for(e, cfgidx),
-            Moves   => self.dataflow_moves_for(e, cfgidx),
-            Assigns => self.dataflow_assigns_for(e, cfgidx),
+            Loans      => self.dataflow_loans_for(e, cfgidx),
+            Moves      => self.dataflow_moves_for(e, cfgidx),
+            Assigns    => self.dataflow_assigns_for(e, cfgidx),
+            NeedsDrop  => self.dataflow_needs_drop_for(e, cfgidx),
+            IgnoreDrop => self.dataflow_ignore_drop_for(e, cfgidx),
         }
     }
 
@@ -124,6 +130,24 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {
         };
         self.build_set(e, cfgidx, dfcx, assign_index_to_path)
     }
+
+    fn dataflow_needs_drop_for(&self, e: EntryOrExit, cfgidx: CFGIndex) -> String {
+        let dfcx = &self.analysis_data.move_data.dfcx_needs_drop;
+        let needs_drop_index_to_path = |needs_drop_index| {
+            let move_data = &self.analysis_data.move_data.move_data;
+            move_data.path_loan_path(borrowck::move_data::MovePathIndex(needs_drop_index))
+        };
+        self.build_set(e, cfgidx, dfcx, needs_drop_index_to_path)
+    }
+
+    fn dataflow_ignore_drop_for(&self, e: EntryOrExit, cfgidx: CFGIndex) -> String {
+        let dfcx = &self.analysis_data.move_data.dfcx_ignore_drop;
+        let ignore_drop_index_to_path = |ignore_drop_index| {
+            let move_data = &self.analysis_data.move_data.move_data;
+            move_data.path_loan_path(borrowck::move_data::MovePathIndex(ignore_drop_index))
+        };
+        self.build_set(e, cfgidx, dfcx, ignore_drop_index_to_path)
+    }
 }
 
 impl<'a, 'tcx> dot::Labeller<'a, Node<'a>, Edge<'a>> for DataflowLabeller<'a, 'tcx> {
diff --git a/src/librustc/middle/borrowck/mod.rs b/src/librustc/middle/borrowck/mod.rs
index f4d3678..64c1aad 100644
--- a/src/librustc/middle/borrowck/mod.rs
+++ b/src/librustc/middle/borrowck/mod.rs
@@ -20,6 +20,7 @@ use middle::def;
 use middle::expr_use_visitor as euv;
 use middle::mem_categorization as mc;
 use middle::ty;
+use middle::subst::Subst;
 use util::ppaux::{note_and_explain_region, Repr, UserString};
 
 use std::cell::{Cell};
@@ -55,6 +56,8 @@ pub mod graphviz;
 
 pub mod move_data;
 
+pub mod check_drops;
+
 #[deriving(Clone)]
 pub struct LoanDataFlowOperator;
 
@@ -139,6 +142,8 @@ fn borrowck_fn(this: &mut BorrowckCtxt,
                        move_data:flowed_moves } =
         build_borrowck_dataflow_data(this, fk, decl, &cfg, body, sp, id);
 
+    check_drops::check_drops(this, &flowed_moves, id, &cfg, decl, body);
+
     check_loans::check_loans(this, &loan_dfcx, flowed_moves,
                              all_loans.as_slice(), decl, body);
 
@@ -274,16 +279,284 @@ impl Loan {
 }
 
 #[deriving(PartialEq, Eq, Hash)]
+pub enum CaptureKind { CaptureByVal, CaptureByRef }
+
+#[deriving(PartialEq, Eq, Hash)]
 pub enum LoanPath {
-    LpVar(ast::NodeId),               // `x` in doc.rs
-    LpUpvar(ty::UpvarId),             // `x` captured by-value into closure
-    LpExtend(Rc<LoanPath>, mc::MutabilityCategory, LoanPathElem)
+    LpVar(ast::NodeId),                   // `x` in doc.rs
+    LpUpvar(ty::UpvarId, CaptureKind),    // `x` captured by-value into closure
+    LpDowncast(Rc<LoanPath>, ast::DefId), // `x` downcast to particular enum variant
+    LpExtend(Rc<LoanPath>, mc::MutabilityCategory, LoanPathElem),
+}
+
+impl LoanPath {
+    fn kill_id(&self, tcx: &ty::ctxt) -> ast::NodeId {
+        //! Returns the lifetime of the local variable that forms the base of this path.
+        match *self {
+            LpVar(id) =>
+                tcx.region_maps.var_scope(id),
+            LpUpvar(ty::UpvarId { var_id: _, closure_expr_id }, _) => 
+                closure_to_block(closure_expr_id, tcx),
+            LpDowncast(ref base_lp, _) | LpExtend(ref base_lp, _, _) =>
+                base_lp.kill_id(tcx),
+        }
+    }
+
+    fn to_type(&self, tcx: &ty::ctxt) -> ty::t {
+        use middle::mem_categorization::InteriorElement as Element;
+        use middle::mem_categorization::InteriorField as Field;
+
+        debug!("lp.to_type() for lp={:s}", self.repr(tcx));
+        let ty = match *self {
+            LpUpvar(ty::UpvarId { var_id: id, closure_expr_id: _ }, capture) => {
+                ty::node_id_to_type_opt(tcx, id).map(|t| {
+                    match capture {
+                        CaptureByVal => t,
+                        CaptureByRef =>
+                            ty::mk_ptr(tcx, ty::mt{ty: t,
+                                                   // making up immut here.
+                                                   // Hopefully won't matter.
+                                                   mutbl: ast::MutImmutable}),
+                    }}).unwrap_or_else(|| {
+                    let id = self.kill_scope(tcx);
+                    let msg = format!("no type found for LpUpvar={:s}", self.repr(tcx));
+                    let opt_span = tcx.map.opt_span(id);
+                    tcx.sess.opt_span_bug(opt_span, msg.as_slice());
+                })
+            }
+
+            LpVar(id) => {
+                ty::node_id_to_type_opt(tcx, id).unwrap_or_else(|| {
+                    let id = self.kill_scope(tcx);
+                    let msg = format!("no type found for LpVar={:s}", self.repr(tcx));
+                    let opt_span = tcx.map.opt_span(id);
+                    tcx.sess.opt_span_bug(opt_span, msg.as_slice());
+                })
+            }
+
+            // treat the downcasted enum as having the enum's type;
+            // extracting the particular types within the variant is
+            // handled by `LpExtend` cases.
+            LpDowncast(ref lp, _variant_did) => lp.to_type(tcx),
+
+            LpExtend(ref lp, _mc, ref loan_path_elem) => {
+                let (opt_variant_did, lp) = match **lp {
+                    LpDowncast(ref sub_lp, variant_did) =>
+                        (Some(variant_did), sub_lp),
+                    LpVar(..) | LpUpvar(..) | LpExtend(..) =>
+                        (None, lp)
+                };
+
+                let t = lp.to_type(tcx);
+                let t_sty = &ty::get(t).sty;
+
+                let base_deref_t = match **lp {
+                    LpExtend(ref lp2, _, LpDeref(_)) => Some(lp2.to_type(tcx)),
+                    _                                => None,
+                };
+                let base_elem_t =
+                    base_deref_t.and_then(|t|ty::array_element_ty(t));
+
+                match (loan_path_elem, t_sty) {
+
+                    (&LpDeref(_), &ty::ty_ptr(ty::mt{ty: t, ..})) |
+                    (&LpDeref(_), &ty::ty_rptr(_, ty::mt{ty: t, ..})) |
+                    (&LpDeref(_), &ty::ty_box(t)) |
+                    (&LpDeref(_), &ty::ty_uniq(t)) => t,
+
+                    (&LpInterior(Field(mc::NamedField(ast_name))),
+                     _) => ty::named_element_ty(tcx, t, ast_name, opt_variant_did)
+                        .unwrap_or_else(|| {
+                            let id = self.kill_scope(tcx);
+                            let msg = format!("no type found for LpExtend LpInterior NamedField={:s}", self.repr(tcx));
+                            let opt_span = tcx.map.opt_span(id);
+                            tcx.sess.opt_span_bug(opt_span, msg.as_slice());
+                        }),
+
+                    (&LpInterior(Field(mc::PositionalField(idx))),
+                     _) => ty::positional_element_ty(tcx, t, idx, opt_variant_did)
+                        .unwrap_or_else(|| {
+                            let id = self.kill_scope(tcx);
+                            let msg = format!("no type found for LpExtend LpInterior PositionalField={:s}", self.repr(tcx));
+                            let opt_span = tcx.map.opt_span(id);
+                            tcx.sess.opt_span_bug(opt_span, msg.as_slice());
+                        }),
+
+                    // FIXME: Complete hack; array_element_ty does not
+                    // yet do Dynamically Sized Types (DST); (instead
+                    // it returns none for `[T]`).  So catch such
+                    // cases ahead of time, instead of returning a
+                    // type that we cannot actually handle recursively
+                    // (which is what the subsequent clauses would
+                    // do).  Though we should strongly consider just
+                    // revising array_element_ty to also map input
+                    // `[T]` to `Some(T)` rather than `None` (FSK).
+                    (&LpInterior(Element(_)), _) if base_elem_t.is_some() =>
+                        base_elem_t.unwrap(),
+
+                    // FIXME: At one point I was deliberately
+                    // eschewing ty::array_element_ty because I
+                    // thought it was presuming r-value context and
+                    // loan-path structure kept element-access
+                    // separate from deref.  But now I am not so sure
+                    // what is appropriate here anymore.  So I am
+                    // trying ty::array_element_ty out of desperation
+                    // mostly.  See also the complete hack in the
+                    // clause above (FSK).
+
+                    // FIXME I could at least merge the two clauses (FSK).
+
+                    (&LpInterior(Element(_)), _) => ty::array_element_ty(t)
+                        .unwrap_or_else(|| {
+                            // Once, we would get into this case when
+                            // we are given a `&[T]`, rather than a
+                            // `[T, ..N]`.  But now that is handled up
+                            // above.
+                            let id = self.kill_scope(tcx);
+                            let msg = format!("no array elem type found for \
+                                               LpExtend LpInterior Element={:s} t={}",
+                                              self.repr(tcx), t.repr(tcx));
+                            let opt_span = tcx.map.opt_span(id);
+                            tcx.sess.opt_span_bug(opt_span, msg.as_slice());
+                        }),
+
+                    (lp_elem, _) => {
+                        let id = self.kill_scope(tcx);
+                        let msg =
+                            format!("Unexpected combination of LpExtend \
+                                     with LoanPathElem={:?} and base t = {}",
+                                    lp_elem, t.repr(tcx));
+                        let opt_span = tcx.map.opt_span(id);
+                        tcx.sess.opt_span_bug(opt_span, msg.as_slice())
+                    }
+                }
+            }
+        };
+        debug!("lp.to_type() for lp={:s} returns ty={:s}",
+               self.repr(tcx), ty.repr(tcx));
+        ty
+    }
+
+    fn needs_drop(&self, tcx: &ty::ctxt) -> bool {
+        //! Returns true if this loan path needs drop glue.  I.e.,
+        //! does assigning to this loan path introduce a new drop
+        //! obligation.
+
+        debug!("needs_drop(tcx) self={}", self.repr(tcx));
+
+        match *self {
+            LpVar(_) | LpUpvar(..) =>
+                // Variables are the easiest case: just use their
+                // types to determine whether they introduce a drop
+                // obligation when assigned.  (FSK well, at the
+                // *moment* they are easy; we may put in
+                // flow-sensitivity in some form.  Or maybe not, we
+                // will see.)
+                self.to_type(tcx).needs_drop_call(tcx),
+
+            LpExtend(_, _, LpDeref(mc::BorrowedPtr(..))) |
+            LpExtend(_, _, LpDeref(mc::Implicit(..)))    =>
+                // A path through a `&` or `&mut` reference cannot
+                // introduce a drop obligation; e.g. the assignment
+                // `*p = box 3u` installs a pointer elsewhere that is
+                // the responsibility of someone else (e.g. a caller).
+                false,
+
+            LpExtend(_, _, LpDeref(mc::OwnedPtr)) =>
+                // However, an assignment to a deref of a Box<T> is
+                // conceptually owned by the parent and thus does
+                // introduce a drop obligation.
+                true,
+
+            LpExtend(_, _, LpDeref(mc::GcPtr))     |
+            LpExtend(_, _, LpDeref(mc::UnsafePtr(_))) =>
+                // An assignment through a GcPtr or UnsafePtr cannot
+                // affect the local drop obligation state.
+                false,
+
+            LpExtend(ref base_lp, _cat, LpInterior(_)) =>
+                // 1. Ensure base_lp does not nullify the drop
+                //    obligation (e.g. if it is through a LpDeref,
+                //    such as an example like `*x.p = box 3u` (which
+                //    in the source code may look like `x.p = box 3u`
+                //    due to autoderef).
+                base_lp.needs_drop(tcx) &&
+
+                // 2. Even if the base_lp needs drop, this particular
+                //    field might not.  E.g. for `x.q = 3u`, `x` may
+                //    itself introduce a drop obligation, but the type
+                //    of `q` means that that particular field does not
+                //    affect dropping.
+                self.to_type(tcx).needs_drop_call(tcx),
+
+            LpDowncast(ref lp, def_id) => self.enum_variant_needs_drop(tcx, lp, def_id),
+        }
+    }
+
+    fn enum_variant_needs_drop(&self,
+                               tcx: &ty::ctxt,
+                               lp: &Rc<LoanPath>,
+                               variant_def_id: ast::DefId) -> bool {
+        //! Handle a particular enum variant as a special case, since
+        //! the type of an enum variant, like `None` has type
+        //! `Option<T>`, can indicate that it needs-drop, even though
+        //! that particular variant does not introduce a
+        //! drop-obligation.
+
+        let lp_type = lp.to_type(tcx);
+        match ty::get(lp_type).sty {
+            ty::ty_enum(enum_def_id, ref substs) => {
+                let variant_info = ty::enum_variant_with_id(tcx, enum_def_id, variant_def_id);
+                let type_contents = ty::TypeContents::union(
+                    variant_info.args.as_slice(),
+                    |arg_ty| {
+                        let arg_ty_subst = arg_ty.subst(tcx, substs);
+                        debug!("needs_drop(tcx) self={} arg_ty={:s} arg_ty_subst={:s}",
+                               self.repr(tcx), arg_ty.repr(tcx), arg_ty_subst.repr(tcx));
+                        ty::type_contents(tcx, arg_ty_subst)
+                    });
+
+                type_contents.needs_drop_call(tcx)
+            }
+            _ => {
+                debug!("needs_drop encountered LpDowncast on non-enum base type: {}",
+                       lp_type.repr(tcx));
+                let msg = format!("encountered LpDowncast on non-enum base type: {}.",
+                                  lp_type.repr(tcx));
+                tcx.sess.opt_span_warn(tcx.map.opt_span(self.kill_id(tcx)),
+                                       msg.as_slice());
+                false
+            }
+        }
+    }
+}
+
+trait NeedsDropCallArg {
+    fn needs_drop_call(&self, tcx: &ty::ctxt) -> bool;
+}
+impl NeedsDropCallArg for ty::TypeContents {
+    fn needs_drop_call(&self, tcx: &ty::ctxt) -> bool {
+        // self.needs_drop(tcx)
+        self.moves_by_default(tcx)
+    }
+}
+impl NeedsDropCallArg for ty::t {
+    fn needs_drop_call(&self, tcx: &ty::ctxt) -> bool {
+        ty::type_contents(tcx, *self).needs_drop_call(tcx)
+    }
 }
 
 #[deriving(PartialEq, Eq, Hash)]
 pub enum LoanPathElem {
     LpDeref(mc::PointerKind),    // `*LV` in doc.rs
     LpInterior(mc::InteriorKind) // `LV.f` in doc.rs
+    // LpInterior(mc::InteriorKind, Box<InteriorInfo>) // `LV.f` in doc.rs
+}
+
+pub enum InteriorInfo {
+    StructInterior(ty::t),
+    TupleIndexInterior(Vec<ty::t>),
+    EnumVariantInterior(ty::VariantInfo),
 }
 
 pub fn closure_to_block(closure_id: ast::NodeId,
@@ -303,21 +576,24 @@ impl LoanPath {
     pub fn kill_scope(&self, tcx: &ty::ctxt) -> ast::NodeId {
         match *self {
             LpVar(local_id) => tcx.region_maps.var_scope(local_id),
-            LpUpvar(upvar_id) =>
+            LpUpvar(upvar_id, _) =>
                 closure_to_block(upvar_id.closure_expr_id, tcx),
+            LpDowncast(ref base, _) |
             LpExtend(ref base, _, _) => base.kill_scope(tcx),
         }
     }
 }
 
-pub fn opt_loan_path(cmt: &mc::cmt) -> Option<Rc<LoanPath>> {
+pub fn opt_loan_path(cmt: &mc::cmt, tcx: &ty::ctxt) -> Option<Rc<LoanPath>> {
     //! Computes the `LoanPath` (if any) for a `cmt`.
     //! Note that this logic is somewhat duplicated in
     //! the method `compute()` found in `gather_loans::restrictions`,
     //! which allows it to share common loan path pieces as it
     //! traverses the CMT.
 
-    match cmt.cat {
+    debug!("opt_loan_path(cmt={})", cmt.repr(tcx));
+
+    let ret = match cmt.cat {
         mc::cat_rvalue(..) |
         mc::cat_static_item |
         mc::cat_copied_upvar(mc::CopiedUpvar { onceness: ast::Many, .. }) => {
@@ -329,31 +605,49 @@ pub fn opt_loan_path(cmt: &mc::cmt) -> Option<Rc<LoanPath>> {
             Some(Rc::new(LpVar(id)))
         }
 
-        mc::cat_upvar(ty::UpvarId {var_id: id, closure_expr_id: proc_id}, _) |
+        mc::cat_upvar(ty::UpvarId {var_id: id, closure_expr_id: proc_id}, _) => {
+            let upvar_id = ty::UpvarId{ var_id: id, closure_expr_id: proc_id };
+            Some(Rc::new(LpUpvar(upvar_id, CaptureByRef)))
+        }
         mc::cat_copied_upvar(mc::CopiedUpvar { upvar_id: id,
                                                onceness: _,
                                                capturing_proc: proc_id }) => {
             let upvar_id = ty::UpvarId{ var_id: id, closure_expr_id: proc_id };
-            Some(Rc::new(LpUpvar(upvar_id)))
+            Some(Rc::new(LpUpvar(upvar_id, CaptureByVal)))
         }
 
         mc::cat_deref(ref cmt_base, _, pk) => {
-            opt_loan_path(cmt_base).map(|lp| {
-                Rc::new(LpExtend(lp, cmt.mutbl, LpDeref(pk)))
+            opt_loan_path(cmt_base, tcx).map(|lp| {
+                let lp : LoanPath =
+                    LpExtend(lp, cmt.mutbl, LpDeref(pk)); 
+                Rc::new(lp)
             })
         }
 
         mc::cat_interior(ref cmt_base, ik) => {
-            opt_loan_path(cmt_base).map(|lp| {
-                Rc::new(LpExtend(lp, cmt.mutbl, LpInterior(ik)))
+            opt_loan_path(cmt_base, tcx).map(|lp| {
+                let lp : LoanPath =
+                    LpExtend(lp, cmt.mutbl, LpInterior(ik));
+                Rc::new(lp)
             })
         }
 
-        mc::cat_downcast(ref cmt_base) |
-        mc::cat_discr(ref cmt_base, _) => {
-            opt_loan_path(cmt_base)
-        }
-    }
+        mc::cat_downcast(ref cmt_base, variant_def_id) =>
+            opt_loan_path(cmt_base, tcx)
+            .map(|lp| {
+                debug!("opt_loan_path cat_downcast \
+                        cmt.ty={} ({:?}) \
+                        cmt_base.ty={} ({:?})",
+                       cmt.ty.repr(tcx), cmt.ty,
+                       cmt_base.ty.repr(tcx), cmt_base.ty);
+                Rc::new(LpDowncast(lp, variant_def_id))
+            }),
+        mc::cat_discr(ref cmt_base, _) => opt_loan_path(cmt_base, tcx),
+    };
+
+    debug!("opt_loan_path(cmt={}) => {}", cmt.repr(tcx), ret.repr(tcx));
+
+    ret
 }
 
 ///////////////////////////////////////////////////////////////////////////
@@ -531,17 +825,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {
             move_data::Declared => {}
 
             move_data::MoveExpr => {
-                let (expr_ty, expr_span) = match self.tcx.map.find(move.id) {
-                    Some(ast_map::NodeExpr(expr)) => {
-                        (ty::expr_ty_adjusted(self.tcx, &*expr), expr.span)
-                    }
-                    r => {
-                        self.tcx.sess.bug(format!("MoveExpr({:?}) maps to \
-                                                   {:?}, not Expr",
-                                                  move.id,
-                                                  r).as_slice())
-                    }
-                };
+                let (expr_ty, expr_span) = move.ty_and_span(self.tcx);
                 let suggestion = move_suggestion(self.tcx, expr_ty,
                         "moved by default (use `copy` to override)");
                 self.tcx.sess.span_note(
@@ -553,8 +837,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {
             }
 
             move_data::MovePat => {
-                let pat_ty = ty::node_id_to_type(self.tcx, move.id);
-                self.tcx.sess.span_note(self.tcx.map.span(move.id),
+                let (pat_ty, pat_span) = move.ty_and_span(self.tcx);
+                self.tcx.sess.span_note(pat_span,
                     format!("`{}` moved here because it has type `{}`, \
                              which is moved by default (use `ref` to \
                              override)",
@@ -563,17 +847,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {
             }
 
             move_data::Captured => {
-                let (expr_ty, expr_span) = match self.tcx.map.find(move.id) {
-                    Some(ast_map::NodeExpr(expr)) => {
-                        (ty::expr_ty_adjusted(self.tcx, &*expr), expr.span)
-                    }
-                    r => {
-                        self.tcx.sess.bug(format!("Captured({:?}) maps to \
-                                                   {:?}, not Expr",
-                                                  move.id,
-                                                  r).as_slice())
-                    }
-                };
+                let (expr_ty, expr_span) = move.ty_and_span(self.tcx);
                 let suggestion = move_suggestion(self.tcx, expr_ty,
                         "moved by default (make a copy and \
                          capture that instead to override)");
@@ -630,7 +904,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {
     pub fn bckerr_to_string(&self, err: &BckError) -> String {
         match err.code {
             err_mutbl => {
-                let descr = match opt_loan_path(&err.cmt) {
+                let descr = match opt_loan_path(&err.cmt, self.tcx) {
                     None => {
                         format!("{} {}",
                                 err.cmt.mutbl.to_user_str(),
@@ -662,7 +936,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {
                 }
             }
             err_out_of_scope(..) => {
-                let msg = match opt_loan_path(&err.cmt) {
+                let msg = match opt_loan_path(&err.cmt, self.tcx) {
                     None => "borrowed value".to_string(),
                     Some(lp) => {
                         format!("`{}`", self.loan_path_to_string(&*lp))
@@ -671,7 +945,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {
                 format!("{} does not live long enough", msg)
             }
             err_borrowed_pointer_too_short(..) => {
-                let descr = match opt_loan_path(&err.cmt) {
+                let descr = match opt_loan_path(&err.cmt, self.tcx) {
                     Some(lp) => {
                         format!("`{}`", self.loan_path_to_string(&*lp))
                     }
@@ -769,7 +1043,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {
             }
 
             err_borrowed_pointer_too_short(loan_scope, ptr_scope) => {
-                let descr = match opt_loan_path(&err.cmt) {
+                let descr = match opt_loan_path(&err.cmt, self.tcx) {
                     Some(lp) => {
                         format!("`{}`", self.loan_path_to_string(&*lp))
                     }
@@ -794,11 +1068,19 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {
                                    loan_path: &LoanPath,
                                    out: &mut String) {
         match *loan_path {
-            LpUpvar(ty::UpvarId{ var_id: id, closure_expr_id: _ }) |
+            LpUpvar(ty::UpvarId{ var_id: id, closure_expr_id: _ }, _) |
             LpVar(id) => {
                 out.push_str(ty::local_var_name_str(self.tcx, id).get());
             }
 
+            LpDowncast(ref lp_base, variant_def_id) => {
+                out.push_char('(');
+                self.append_loan_path_to_string(&**lp_base, out);
+                out.push_str("->");
+                out.push_str(ty::item_path_str(self.tcx, variant_def_id).as_slice());
+                out.push_char(')');
+            }
+
             LpExtend(ref lp_base, _, LpInterior(mc::InteriorField(fname))) => {
                 self.append_autoderefd_loan_path_to_string(&**lp_base, out);
                 match fname {
@@ -829,6 +1111,14 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {
                                               loan_path: &LoanPath,
                                               out: &mut String) {
         match *loan_path {
+            LpDowncast(ref lp_base, variant_def_id) => {
+                out.push_char('(');
+                self.append_autoderefd_loan_path_to_string(&**lp_base, out);
+                out.push_char(':');
+                out.push_str(ty::item_path_str(self.tcx, variant_def_id).as_slice());
+                out.push_char(')');
+            }
+
             LpExtend(ref lp_base, _, LpDeref(_)) => {
                 // For a path like `(*x).f` or `(*x)[3]`, autoderef
                 // rules would normally allow users to omit the `*x`.
@@ -898,7 +1188,7 @@ impl Repr for LoanPath {
                 format!("$({})", tcx.map.node_to_string(id))
             }
 
-            &LpUpvar(ty::UpvarId{ var_id, closure_expr_id }) => {
+            &LpUpvar(ty::UpvarId{ var_id, closure_expr_id }, _) => {
                 let s = tcx.map.node_to_string(var_id);
                 format!("$({} captured by id={})", s, closure_expr_id)
             }
@@ -910,6 +1200,15 @@ impl Repr for LoanPath {
             &LpExtend(ref lp, _, LpInterior(ref interior)) => {
                 format!("{}.{}", lp.repr(tcx), interior.repr(tcx))
             }
+
+            &LpDowncast(ref lp, variant_def_id) => {
+                let variant_str = if variant_def_id.krate == ast::LOCAL_CRATE {
+                    ty::item_path_str(tcx, variant_def_id)
+                } else {
+                    variant_def_id.repr(tcx)
+                };
+                format!("({}->{})", lp.repr(tcx), variant_str)
+            }
         }
     }
 }
diff --git a/src/librustc/middle/borrowck/move_data.rs b/src/librustc/middle/borrowck/move_data.rs
index fdd16c8..fd25c71 100644
--- a/src/librustc/middle/borrowck/move_data.rs
+++ b/src/librustc/middle/borrowck/move_data.rs
@@ -28,6 +28,7 @@ use middle::expr_use_visitor as euv;
 use middle::mem_categorization as mc;
 use middle::ty;
 use syntax::ast;
+use syntax::ast_map;
 use syntax::ast_util;
 use syntax::codemap::Span;
 use util::ppaux::Repr;
@@ -52,8 +53,22 @@ pub struct MoveData {
     /// kill move bits.
     pub path_assignments: RefCell<Vec<Assignment>>,
 
+    /// Enum variant matched within a pattern on some match arm, like
+    /// `SomeStruct{ f: Variant1(x, y) } => ...`
+    pub variant_matches: RefCell<Vec<VariantMatch>>,
+
     /// Assignments to a variable or path, like `x = foo`, but not `x += foo`.
     pub assignee_ids: RefCell<HashSet<ast::NodeId>>,
+
+    /// During move_data construction, `fragments` tracks paths that
+    /// *might* be needs-drop leftovers.  When move_data has been
+    /// completed, `fragments` tracks paths that are *definitely*
+    /// needs-drop left-overs.
+    pub fragments: RefCell<Vec<MovePathIndex>>,
+
+    /// `nonfragments` always tracks paths that have been definitely
+    /// used directly in moves).
+    pub nonfragments: RefCell<Vec<MovePathIndex>>,
 }
 
 pub struct FlowedMoveData<'a, 'tcx: 'a> {
@@ -64,12 +79,20 @@ pub struct FlowedMoveData<'a, 'tcx: 'a> {
     // We could (and maybe should, for efficiency) combine both move
     // and assign data flow into one, but this way it's easier to
     // distinguish the bits that correspond to moves and assignments.
-    pub dfcx_assign: AssignDataFlow<'a, 'tcx>
+    pub dfcx_assign: AssignDataFlow<'a, 'tcx>,
+
+    pub dfcx_needs_drop: NeedsDropDataFlow<'a, 'tcx>,
+
+    /// If we match a variant for which no drop is necessary, then on
+    /// this branch (alone), no-drop is necessary for the original
+    /// path.  That flow-sensitive inforamtion is tracked here.
+    pub dfcx_ignore_drop: IgnoreDropDataFlow<'a, 'tcx>,
 }
 
 /// Index into `MoveData.paths`, used like a pointer
 #[deriving(PartialEq)]
-pub struct MovePathIndex(uint);
+// FIXME: should not be `pub`. Revise dataflow to support abstractions like this.
+pub struct MovePathIndex(pub uint);
 
 impl MovePathIndex {
     fn get(&self) -> uint {
@@ -151,6 +174,20 @@ pub struct Assignment {
     pub span: Span,
 }
 
+pub struct VariantMatch {
+    /// downcast to the variant.
+    pub path: MovePathIndex,
+
+    /// path being downcast to the variant.
+    pub base_path: MovePathIndex,
+
+    /// id where variant's pattern occurs
+    pub id: ast::NodeId,
+
+    /// says if variant established by move (and why), by copy, or by borrow.
+    pub mode: euv::MatchMode
+}
+
 #[deriving(Clone)]
 pub struct MoveDataFlowOperator;
 
@@ -161,9 +198,17 @@ pub struct AssignDataFlowOperator;
 
 pub type AssignDataFlow<'a, 'tcx> = DataFlowContext<'a, 'tcx, AssignDataFlowOperator>;
 
+#[deriving(Clone)]
+pub struct NeedsDropDataFlowOperator;
+pub type NeedsDropDataFlow<'a, 'tcx> = DataFlowContext<'a, 'tcx, NeedsDropDataFlowOperator>;
+
+#[deriving(Clone)]
+pub struct IgnoreDropDataFlowOperator;
+pub type IgnoreDropDataFlow<'a, 'tcx> = DataFlowContext<'a, 'tcx, IgnoreDropDataFlowOperator>;
+
 fn loan_path_is_precise(loan_path: &LoanPath) -> bool {
     match *loan_path {
-        LpVar(_) | LpUpvar(_) => {
+        LpVar(_) | LpUpvar(..) => {
             true
         }
         LpExtend(_, _, LpInterior(mc::InteriorElement(_))) => {
@@ -174,6 +219,78 @@ fn loan_path_is_precise(loan_path: &LoanPath) -> bool {
         LpExtend(ref lp_base, _, _) => {
             loan_path_is_precise(&**lp_base)
         }
+        LpDowncast(ref lp_base, _) => {
+            loan_path_is_precise(&**lp_base)
+        }
+    }
+}
+
+impl Move {
+    pub fn ty_and_span(&self, tcx: &ty::ctxt) -> (ty::t, Span) {
+        match self.kind {
+            Declared  => unimplemented!(),
+            MovePat => (ty::node_id_to_type(tcx, self.id), tcx.map.span(self.id)),
+            MoveExpr | Captured => match tcx.map.find(self.id) {
+                Some(ast_map::NodeExpr(expr)) =>
+                    (ty::expr_ty_adjusted(tcx, &*expr), expr.span),
+                r => tcx.sess.bug(format!("{:?}({:?}) maps to {:?}, not Expr",
+                                          self.kind, self.id, r).as_slice())
+            },
+        }
+    }
+
+    pub fn ty(&self, tcx: &ty::ctxt) -> ty::t {
+        self.ty_and_span(tcx).val0()
+    }
+
+    pub fn to_string(&self, move_data: &MoveData, tcx: &ty::ctxt) -> String {
+        format!("Move{:s} path: {}, id: {}, kind: {:?} {:s}",
+                "{",
+                move_data.path_loan_path(self.path).repr(tcx),
+                self.id,
+                self.kind,
+                "}")
+    }
+}
+
+impl Assignment {
+    pub fn ty_and_span(&self, tcx: &ty::ctxt) -> (ty::t, Span) {
+        match tcx.map.find(self.id) {
+            Some(ast_map::NodeExpr(expr)) =>
+                (ty::expr_ty_adjusted(tcx, &*expr), expr.span),
+            Some(ast_map::NodeLocal(pat)) =>
+                (ty::node_id_to_type(tcx, pat.id), tcx.map.span(pat.id)),
+            r => tcx.sess.bug(format!("{:?} maps to {:?}, not Expr", self, r).as_slice())
+        }
+    }
+    pub fn ty(&self, tcx: &ty::ctxt) -> ty::t {
+        self.ty_and_span(tcx).val0()
+    }
+    pub fn to_string(&self, move_data: &MoveData, tcx: &ty::ctxt) -> String {
+        format!("Assignment{:s} path: {}, id: {} {:s}",
+                "{",
+                move_data.path_loan_path(self.path).repr(tcx),
+                self.id,
+                "}")
+    }
+}
+
+impl VariantMatch {
+    pub fn ty_and_span(&self, tcx: &ty::ctxt) -> (ty::t, Span) {
+        match tcx.map.find(self.id) {
+            Some(ast_map::NodePat(pat)) => (ty::pat_ty(tcx, &*pat), pat.span),
+            r => tcx.sess.bug(format!("{:?} maps to {:?}, not Pat", self, r).as_slice())
+        }
+    }
+    pub fn ty(&self, tcx: &ty::ctxt) -> ty::t {
+        self.ty_and_span(tcx).val0()
+    }
+    pub fn to_string(&self, move_data: &MoveData, tcx: &ty::ctxt) -> String {
+        format!("VariantMatch{:s} path: {}, id: {} {:s}",
+                "{",
+                move_data.path_loan_path(self.path).repr(tcx),
+                self.id,
+                "}")
     }
 }
 
@@ -185,7 +302,10 @@ impl MoveData {
             moves: RefCell::new(Vec::new()),
             path_assignments: RefCell::new(Vec::new()),
             var_assignments: RefCell::new(Vec::new()),
+            variant_matches: RefCell::new(Vec::new()),
             assignee_ids: RefCell::new(HashSet::new()),
+            fragments: RefCell::new(Vec::new()),
+            nonfragments: RefCell::new(Vec::new()),
         }
     }
 
@@ -201,10 +321,42 @@ impl MoveData {
         self.paths.borrow().get(index.get()).first_move
     }
 
+    /// Returns true iff `index` itself cannot be directly split into
+    /// child fragments.  This means it is an atomic value (like a
+    /// pointer or an integer), or it a non-downcasted enum (and so we
+    /// can only split off subparts when we narrow it to a particular
+    /// variant), or it is a struct whose fields are never accessed in
+    /// the function being compiled.
+    fn path_is_leaf(&self, index: MovePathIndex, _tcx: &ty::ctxt) -> bool {
+        let first_child = self.path_first_child(index);
+        if first_child == InvalidMovePathIndex {
+            true
+        } else {
+            match *self.path_loan_path(first_child) {
+                LpDowncast(..) => true,
+                LpExtend(..) => false,
+                LpVar(..) | LpUpvar(..) => false,
+            }
+        }
+    }
+
+    /// Returns true iff `index` represents downcast to an enum variant (i.e. LpDowncast).
+    fn path_is_downcast_to_variant(&self, index: MovePathIndex) -> bool {
+        match *self.path_loan_path(index) {
+            LpDowncast(..) => true,
+            _ => false,
+        }
+    }
+
+    /// Returns the index of first child, or `InvalidMovePathIndex` if
+    /// `index` is leaf.
     fn path_first_child(&self, index: MovePathIndex) -> MovePathIndex {
         self.paths.borrow().get(index.get()).first_child
     }
 
+    /// Returns index for next sibling, or `InvalidMovePathIndex` if
+    /// `index` has no remaining siblings in the list.  (The head of
+    /// the list is the parent's first child; see `path_first_child`).
     fn path_next_sibling(&self, index: MovePathIndex) -> MovePathIndex {
         self.paths.borrow().get(index.get()).next_sibling
     }
@@ -231,7 +383,7 @@ impl MoveData {
         self.path_parent(index) == InvalidMovePathIndex
     }
 
-    pub fn move_path(&self,
+    fn move_path(&self,
                      tcx: &ty::ctxt,
                      lp: Rc<LoanPath>) -> MovePathIndex {
         /*!
@@ -262,6 +414,7 @@ impl MoveData {
                 index
             }
 
+            LpDowncast(ref base, _) |
             LpExtend(ref base, _, _) => {
                 let parent_index = self.move_path(tcx, base.clone());
 
@@ -320,6 +473,9 @@ impl MoveData {
             None => {
                 match **lp {
                     LpVar(..) | LpUpvar(..) => { }
+                    LpDowncast(ref b, _) => {
+                        self.add_existing_base_paths(b, result);
+                    }
                     LpExtend(ref b, _, _) => {
                         self.add_existing_base_paths(b, result);
                     }
@@ -344,9 +500,11 @@ impl MoveData {
                id,
                kind);
 
-        let path_index = self.move_path(tcx, lp);
+        let path_index = self.move_path(tcx, lp.clone());
         let move_index = MoveIndex(self.moves.borrow().len());
 
+        self.nonfragments.borrow_mut().push(path_index);
+
         let next_move = self.path_first_move(path_index);
         self.set_path_first_move(path_index, move_index);
 
@@ -356,6 +514,8 @@ impl MoveData {
             kind: kind,
             next_move: next_move
         });
+
+        self.add_fragment_siblings(tcx, lp, id);
     }
 
     pub fn add_assignment(&self,
@@ -375,6 +535,8 @@ impl MoveData {
 
         let path_index = self.move_path(tcx, lp.clone());
 
+        self.nonfragments.borrow_mut().push(path_index);
+
         match mode {
             euv::Init | euv::JustWrite => {
                 self.assignee_ids.borrow_mut().insert(assignee_id);
@@ -401,65 +563,338 @@ impl MoveData {
         }
     }
 
+    pub fn add_variant_match(&self,
+                         tcx: &ty::ctxt,
+                         lp: Rc<LoanPath>,
+                         pattern_id: ast::NodeId,
+                         base_lp: Rc<LoanPath>,
+                         mode: euv::MatchMode) {
+        /*!
+         * Adds a new record for an match of `base_lp`, downcast to
+         * variant `lp`, that occurs at location `pattern_id`.  (One
+         * should be able to recover the span info from the
+         * `pattern_id` and the ast_map, I think.)
+         */
+        debug!("add_variant_match(lp={}, pattern_id={:?})",
+               lp.repr(tcx), pattern_id);
+
+        let path_index = self.move_path(tcx, lp.clone());
+        let base_path_index = self.move_path(tcx, base_lp.clone());
+
+        self.nonfragments.borrow_mut().push(path_index);
+        let variant_match = VariantMatch {
+            path: path_index,
+            base_path: base_path_index,
+            id: pattern_id,
+            mode: mode,
+        };
+
+        self.variant_matches.borrow_mut().push(variant_match);
+    }
+
+    fn add_fragment_siblings(&self,
+                             tcx: &ty::ctxt,
+                             lp: Rc<LoanPath>,
+                             origin_id: ast::NodeId) {
+        /*! Adds all of the precisely-tracked siblings of `lp` as
+         * potential move paths of interest. For example, if `lp`
+         * represents `s.x.j`, then adds moves paths for `s.x.i` and
+         * `s.x.k`, the siblings of `s.x.j`.
+         */
+        debug!("add_fragment_siblings(lp={}, origin_id={})",
+               lp.repr(tcx), origin_id);
+
+        match *lp {
+            LpVar(_) | LpUpvar(..) => {} // Local variables have no siblings.
+
+            LpDowncast(..) => {} // an enum variant (on its own) has no siblings.
+
+            // *LV for OwnedPtr consumes the contents of the box (at
+            // least when it is non-copy...), so propagate inward.
+            LpExtend(ref loan_parent, _, LpDeref(mc::OwnedPtr)) => {
+                self.add_fragment_siblings(tcx, loan_parent.clone(), origin_id);
+            }
+
+            // *LV has no siblings
+            LpExtend(_, _, LpDeref(_)) => {}
+
+            // LV[j] is not tracked precisely
+            LpExtend(_, _, LpInterior(mc::InteriorElement(_))) => {}
+
+            // field access LV.x and tuple access LV#k are the cases
+            // we are interested in
+            LpExtend(ref loan_parent, mc,
+                     LpInterior(mc::InteriorField(ref field_name))) => {
+                let enum_variant_info = match **loan_parent {
+                    LpDowncast(ref loan_parent_2, variant_def_id) =>
+                        Some((variant_def_id, loan_parent_2.clone())),
+                    LpExtend(..) | LpVar(..) | LpUpvar(..) =>
+                        None,
+                };
+                self.add_fragment_siblings_for_extension(
+                    tcx, loan_parent, mc, field_name, &lp, origin_id, enum_variant_info);
+            }
+        }
+    }
+
+    fn add_fragment_siblings_for_extension(&self,
+                                           tcx: &ty::ctxt,
+                                           parent_lp: &Rc<LoanPath>,
+                                           mc: mc::MutabilityCategory,
+                                           origin_field_name: &mc::FieldName,
+                                           origin_lp: &Rc<LoanPath>,
+                                           origin_id: ast::NodeId,
+                                           enum_variant_info: Option<(ast::DefId, Rc<LoanPath>)>) {
+        /*! We have determined that `origin_lp` destructures to
+         * LpExtend(parent, original_field_name). Based on this,
+         * add move paths for all of the siblings of `origin_lp`.
+         */
+        let parent_ty = parent_lp.to_type(tcx);
+
+        let add_fragment_sibling = |field_name, _field_type| {
+            self.add_fragment_sibling(
+                tcx, parent_lp.clone(), mc, field_name, origin_lp);
+        };
+
+        match (&ty::get(parent_ty).sty, enum_variant_info) {
+            (&ty::ty_tup(ref v), None) => {
+                let tuple_idx = match *origin_field_name {
+                    mc::PositionalField(tuple_idx) => tuple_idx,
+                    mc::NamedField(_) =>
+                        fail!("tuple type {} should not have named fields.",
+                              parent_ty.repr(tcx)),
+                };
+                let tuple_len = v.len();
+                for i in range(0, tuple_len) {
+                    if i == tuple_idx { continue }
+                    let field_type =
+                        // v[i];
+                        ();
+                    let field_name = mc::PositionalField(i);
+                    add_fragment_sibling(field_name, field_type);
+                }
+            }
+
+            (&ty::ty_struct(def_id, ref _substs), None) => {
+                let fields = ty::lookup_struct_fields(tcx, def_id);
+                match *origin_field_name {
+                    mc::NamedField(ast_name) => {
+                        for f in fields.iter() {
+                            if f.name == ast_name {
+                                continue;
+                            }
+                            let field_name = mc::NamedField(f.name);
+                            let field_type = ();
+                            add_fragment_sibling(field_name, field_type);
+                        }
+                    }
+                    mc::PositionalField(tuple_idx) => {
+                        for (i, _f) in fields.iter().enumerate() {
+                            if i == tuple_idx {
+                                continue
+                            }
+                            let field_name = mc::PositionalField(i);
+                            let field_type = ();
+                            add_fragment_sibling(field_name, field_type);
+                        }
+                    }
+                }
+            }
+
+            (&ty::ty_enum(enum_def_id, ref substs), ref enum_variant_info) => {
+                let variant_info = {
+                    let mut variants = ty::substd_enum_variants(tcx, enum_def_id, substs);
+                    match *enum_variant_info {
+                        Some((variant_def_id, ref _lp2)) =>
+                            variants.iter()
+                            .find(|variant| variant.id == variant_def_id)
+                            .expect("enum_variant_with_id(): no variant exists with that ID")
+                            .clone(),
+                        None => {
+                            assert_eq!(variants.len(), 1);
+                            variants.pop().unwrap()
+                        }
+                    }
+                };
+                match *origin_field_name {
+                    mc::NamedField(ast_name) => {
+                        let variant_arg_names = variant_info.arg_names.as_ref().unwrap();
+                        let variant_arg_types = &variant_info.args;
+                        for (variant_arg_ident, _variant_arg_ty) in variant_arg_names.iter().zip(variant_arg_types.iter()) {
+                            if variant_arg_ident.name == ast_name {
+                                continue;
+                            }
+                            let field_name = mc::NamedField(variant_arg_ident.name);
+                            let field_type = ();
+                            add_fragment_sibling(field_name, field_type);
+                        }
+                    }
+                    mc::PositionalField(tuple_idx) => {
+                        let variant_arg_types = &variant_info.args;
+                        for (i, _variant_arg_ty) in variant_arg_types.iter().enumerate() {
+                            if tuple_idx == i {
+                                continue;
+                            }
+                            let field_name = mc::PositionalField(i);
+                            let field_type = ();
+                            add_fragment_sibling(field_name, field_type);
+                        }
+                    }
+                }
+            }
+
+            ref sty_and_variant_info => {
+                let msg = format!("type {} ({:?}) is not fragmentable",
+                                  parent_ty.repr(tcx), sty_and_variant_info);
+                tcx.sess.opt_span_bug(tcx.map.opt_span(origin_id),
+                                      msg.as_slice())
+            }
+        }
+    }
+
+    fn add_fragment_sibling(&self,
+                            tcx: &ty::ctxt,
+                            parent: Rc<LoanPath>,
+                            mc: mc::MutabilityCategory,
+                            new_field_name: mc::FieldName,
+                            origin_lp: &Rc<LoanPath>) -> MovePathIndex {
+        /*! Adds the single sibling `LpExtend(parent, new_field_name)`
+         * of `origin_lp` (the original loan-path).
+         */
+        let loan_path_elem = LpInterior(mc::InteriorField(new_field_name));
+        let lp : LoanPath = LpExtend(parent, mc, loan_path_elem);
+        debug!("add_fragment_sibling(lp={}, origin_lp={})",
+               lp.repr(tcx), origin_lp.repr(tcx));
+        let mp = self.move_path(tcx, Rc::new(lp));
+
+        // Do not worry about checking for duplicates here; if
+        // necessary, we will sort and dedup after all are added.
+        self.fragments.borrow_mut().push(mp);
+
+        mp
+    }
+
     fn add_gen_kills(&self,
                      tcx: &ty::ctxt,
                      dfcx_moves: &mut MoveDataFlow,
-                     dfcx_assign: &mut AssignDataFlow) {
+                     dfcx_assign: &mut AssignDataFlow,
+                     dfcx_needs_drop: &mut NeedsDropDataFlow,
+                     dfcx_ignore_drop: &mut IgnoreDropDataFlow) {
         /*!
          * Adds the gen/kills for the various moves and
          * assignments into the provided data flow contexts.
          * Moves are generated by moves and killed by assignments and
          * scoping. Assignments are generated by assignment to variables and
-         * killed by scoping. See `doc.rs` for more details.
+         * killed by scoping.  Drop obligations (aka "Needs-Drop") are
+         * generated by assignments and killed by moves and scoping. by
+         * See `doc.rs` for more details.
          */
 
+        {
+            let mut nonfragments = {
+                let mut nonfragments = self.nonfragments.borrow_mut();
+                nonfragments.sort_by(|a, b| a.get().cmp(&b.get()));
+                nonfragments.dedup();
+                nonfragments
+            };
+            let mut fragments = {
+                let mut maybe_fragments = self.fragments.borrow_mut();
+                maybe_fragments.sort_by(|a, b| a.get().cmp(&b.get()));
+                maybe_fragments.dedup();
+
+                // FIXME: why does rustc say that the below code means
+                // `nonfragments` must be declared mut?  Potential
+                // fallout from recent closure changes?
+                maybe_fragments.retain(|f| !nonfragments.contains(f));
+
+                maybe_fragments
+            };
+
+            // See FIXME above: being forced to declare `nonfragments` as mut
+            for (i, &nf) in nonfragments.iter().enumerate() {
+                let lp = self.path_loan_path(nf);
+                debug!("add_gen_kills nonfragment {:u}: {:s}", i, lp.repr(tcx));
+            }
+
+            // See FIXME above: being forced to declare `fragments` as mut
+            for (i, &f) in fragments.iter().enumerate() {
+                let lp = self.path_loan_path(f);
+                debug!("add_gen_kills fragment {:u}: {:s}", i, lp.repr(tcx));
+            }
+        }
+
         for (i, move) in self.moves.borrow().iter().enumerate() {
             dfcx_moves.add_gen(move.id, i);
+            debug!("remove_drop_obligations move {}", move.to_string(self, tcx));
+            self.remove_drop_obligations(tcx, move, dfcx_needs_drop);
+            // FIXME: do I need to also remove_ignored_drops here? (FSK)
+        }
+
+        for variant_match in self.variant_matches.borrow().iter() {
+            match variant_match.mode {
+                euv::NonBindingMatch |
+                euv::BorrowingMatch |
+                euv::CopyingMatch => {}
+                euv::MovingMatch => {
+                    debug!("remove_drop_obligations variant_match {}", variant_match.to_string(self, tcx));
+                    self.remove_drop_obligations(tcx, variant_match, dfcx_needs_drop);
+                    // FIXME: do I need to also remove_ignored_drops here? (FSK)
+                    debug!("add_drop_obligations variant_match {}", variant_match.to_string(self, tcx));
+                    self.add_drop_obligations(tcx, variant_match, dfcx_needs_drop);
+                }
+            }
+
+            debug!("add_ignored_drops variant_match {}", variant_match.to_string(self, tcx));
+            self.add_ignored_drops(tcx, variant_match, dfcx_ignore_drop);
         }
 
         for (i, assignment) in self.var_assignments.borrow().iter().enumerate() {
             dfcx_assign.add_gen(assignment.id, i);
             self.kill_moves(assignment.path, assignment.id, dfcx_moves);
+            debug!("add_drop_obligations var_assignment {}", assignment.to_string(self, tcx));
+            self.add_drop_obligations(tcx, assignment, dfcx_needs_drop);
         }
 
         for assignment in self.path_assignments.borrow().iter() {
             self.kill_moves(assignment.path, assignment.id, dfcx_moves);
+            debug!("add_drop_obligations path_assignment {}", assignment.to_string(self, tcx));
+            self.add_drop_obligations(tcx, assignment, dfcx_needs_drop);
         }
 
-        // Kill all moves related to a variable `x` when it goes out
-        // of scope:
+        // Kill all moves and drop-obligations related to a variable `x` when
+        // it goes out of scope:
         for path in self.paths.borrow().iter() {
             match *path.loan_path {
                 LpVar(id) => {
                     let kill_id = tcx.region_maps.var_scope(id);
-                    let path = *self.path_map.borrow().get(&path.loan_path);
-                    self.kill_moves(path, kill_id, dfcx_moves);
+                    let move_path_index =
+                        *self.path_map.borrow().get(&path.loan_path);
+                    self.kill_moves(move_path_index, kill_id, dfcx_moves);
+                    debug!("remove_drop_obligations scope {} {}",
+                           kill_id, path.loan_path.repr(tcx));
+                    let rm = Removed { where_: kill_id, what_path: move_path_index };
+                    self.remove_drop_obligations(tcx, &rm, dfcx_needs_drop);
+                    // FIXME: do I need to also remove_ignored_drops here? (FSK)
                 }
-                LpUpvar(ty::UpvarId { var_id: _, closure_expr_id }) => {
+                LpUpvar(ty::UpvarId { var_id: _, closure_expr_id }, _) => {
                     let kill_id = closure_to_block(closure_expr_id, tcx);
-                    let path = *self.path_map.borrow().get(&path.loan_path);
-                    self.kill_moves(path, kill_id, dfcx_moves);
+                    let move_path_index = *self.path_map.borrow().get(&path.loan_path);
+                    self.kill_moves(move_path_index, kill_id, dfcx_moves);
+                    debug!("remove_drop_obligations scope {} {}",
+                           kill_id, path.loan_path.repr(tcx));
+                    let rm = Removed { where_: kill_id, what_path: move_path_index };
+                    self.remove_drop_obligations(tcx, &rm, dfcx_needs_drop);
+                    // FIXME: do I need to also remove_ignored_drops here? (FSK)
                 }
+                LpDowncast(..) => {} // FIXME: is this right, or should this loop to top?
                 LpExtend(..) => {}
             }
         }
 
         // Kill all assignments when the variable goes out of scope:
-        for (assignment_index, assignment) in
-                self.var_assignments.borrow().iter().enumerate() {
-            match *self.path_loan_path(assignment.path) {
-                LpVar(id) => {
-                    let kill_id = tcx.region_maps.var_scope(id);
-                    dfcx_assign.add_kill(kill_id, assignment_index);
-                }
-                LpUpvar(ty::UpvarId { var_id: _, closure_expr_id }) => {
-                    let kill_id = closure_to_block(closure_expr_id, tcx);
-                    dfcx_assign.add_kill(kill_id, assignment_index);
-                }
-                LpExtend(..) => {
-                    tcx.sess.bug("var assignment for non var path");
-                }
-            }
+        for (assignment_index, assignment) in self.var_assignments.borrow().iter().enumerate() {
+            let kill_id = self.path_loan_path(assignment.path).kill_id(tcx);
+            dfcx_assign.add_kill(kill_id, assignment_index);
         }
     }
 
@@ -529,6 +964,257 @@ impl MoveData {
             });
         }
     }
+
+
+    // A digression on needs-drop design.
+    //
+    // Lets assume we had a pre-existing drop obligation ND = { s.a, s2 }, where:
+    // ```
+    // struct S { a: A, b: B, c: C }
+    // struct A { i: I, j: J, k: K }
+    // struct J { x: X, y: Y, z: Z }
+    // ```
+    // and `s : S` (and `s2 : S` as well).
+    //
+    // Moving `s.a.j.x` implies that:
+    // * We no longer have a drop-obligation for s.a in its entirety: ND' := ND \ { s.a }
+    // * We now do have drop-obligations for the portions of `s.a` that were not moved:
+    //   ND' := ND + { s.a.i, s.a.k }
+    // * Likewise, we also have drop-obligations for the portions of `s.a.j` that were
+    //   not moved:
+    //   ND' := ND + { s.a.j.y, s.a.j.z }
+    //
+    // Altogether, the above modifications accumulate to:
+    // ND' := ND \ { s.a } + { s.a.i, s.a.j.y, s.a.j.z, s.a.k }
+    //
+    // To simplify constructions like the above let us define taking the derivative
+    // of a path P with respect to an appropriate subpath suffix S: d/d{S}(P)
+    //
+    // So for example, d/d{.j.x}(s.a) := { s.a.i, s.a.j.y, s.a.j.z, s.a.k }
+    //
+    // TODO: Write definition of d/d{S}(P), presumably by induction on suffix S.
+    //
+    // For d/d{.j.x}(s.a), S = .j.x and P = s.a:
+    //
+    // 1. P_0 = s.a      : remove obligation s.a, if present
+    //
+    // 2. P_1 = s.a.j    : assert obligation s.a.j not present; add
+    //                     all needs-drop fields of s.a, then remove s.a.j.
+    // 3. P_2 = s.a.j.x  : assert obligation s.a.j.x not present; add
+    //                     all needs-drop fields of s.a.j, then remove s.a.j.x.
+    //
+    // Big Question: Under the kill/gen paradigm, how do I ensure that
+    // I only add the bits associated with d/d{.j.x}(s.a) and not the
+    // bits associated with d/d{.a.j.x}(s) ?  I.e. the explanation
+    // above makes assumptions about computations I will be able to do
+    // as part the transfer function, but I need to encode those
+    // computations as gen+kill bits.
+    //
+    // ==> one way to resolve this problem while remaining under the
+    //     gen/kill paradigm is to carry-on with a suggestion I made
+    //     to Niko a while back, namely to treat the path `s` as a
+    //     shorthand for
+    //
+    //      `{ s.a.i, s.a.j.x, s.a.j.y, s.a.j.z, s.a.k, s.b, s.c }`,
+    //
+    //     and likewise `s.a` as as shorthand for
+    //
+    //      `{ s.a.i, s.a.j.x, s.a.j.y, s.a.j.z, s.a.k }`
+    //
+    //     That is, put these paths through a normalization process that
+    //     unrolls them to their leaves (or at least, their leaves with
+    //     respect to a given piece of code.
+    //
+    //     I might even be able to implement this independently of
+    //     the other dataflow analyses, since happenstance led me
+    //     to make the needs-drop analysis separate from the
+    //     loans/moves/assigns analyses.
+    //
+    // UPDATE: The above is in fact the strategy that Felix went with.
+    // The above comment should be revised/shortened to a succinct
+    // summary.
+
+    fn path_needs_drop(&self, tcx: &ty::ctxt, move_path_index: MovePathIndex) -> bool {
+        //! Returns true iff move_path_index needs drop.
+        self.path_loan_path(move_path_index).needs_drop(tcx)
+    }
+
+    fn type_moves_by_default(&self, tcx: &ty::ctxt, move_path_index: MovePathIndex) -> bool {
+        //! Returns true iff move_path_index needs moves by default.
+        let path_type = self.path_loan_path(move_path_index).to_type(tcx);
+        ty::type_contents(tcx, path_type).moves_by_default(tcx)
+    }
+
+    fn for_each_leaf(&self,
+                     tcx: &ty::ctxt,
+                     root: MovePathIndex,
+                     found_leaf: |MovePathIndex|,
+                     _found_variant: |MovePathIndex|) {
+        //! Here we normalize a path so that it is unraveled to its
+        //! consituent droppable pieces that might be independently
+        //! handled by the function being compiled: e.g. `s.a.j`
+        //! unravels to `{ s.a.j.x, s.a.j.y, s.a.j.z }` (assuming the
+        //! function never moves out any part of those unraveled
+        //! elements).
+        //!
+        //! Note that the callback is only invoked on unraveled leaves
+        //! that also need to be dropped.
+
+        let root_lp = self.path_loan_path(root);
+        debug!("for_each_leaf(root_lp={:s})", root_lp.repr(tcx));
+
+        if self.path_is_leaf(root, tcx) {
+            found_leaf(root);
+            return;
+        }
+
+        let mut stack = vec![];
+        stack.push(root);
+        loop {
+            let top = match stack.pop() { None => break, Some(elem) => elem };
+            assert!(!self.path_is_leaf(top, tcx));
+            let mut child = self.path_first_child(top);
+            while child != InvalidMovePathIndex {
+                {
+                    let top_lp = self.path_loan_path(top);
+                    let child_lp = self.path_loan_path(child);
+                    debug!("for_each_leaf(root_lp={:s}){:s} top_lp={:s} child_lp={:s}",
+                           root_lp.repr(tcx),
+                           " ".repeat(stack.len()),
+                           top_lp.repr(tcx),
+                           child_lp.repr(tcx));
+                }
+
+                if self.path_is_leaf(child, tcx) {
+                    found_leaf(child);
+                } else {
+                    stack.push(child);
+                }
+
+                child = self.path_next_sibling(child);
+            }
+        }
+    }
+
+    fn add_drop_obligations<A:AddNeedsDropArg>(&self,
+                                               tcx: &ty::ctxt,
+                                               a: &A,
+                                               dfcx_needs_drop: &mut NeedsDropDataFlow) {
+        let a_id = a.node_id_adding_obligation();
+        let a_path = a.path_being_established();
+
+        let add_gen = |move_path_index| {
+            if self.path_is_downcast_to_variant(a_path) {
+                debug!("add_drop_obligations(a={}) {} is variant on match arm",
+                       a.to_string_(self, tcx),
+                       self.path_loan_path(move_path_index).repr(tcx));
+            }
+
+            if self.path_needs_drop(tcx, move_path_index) {
+                debug!("add_drop_obligations(a={}) adds {}",
+                       a.to_string_(self, tcx),
+                       self.path_loan_path(move_path_index).repr(tcx));
+                dfcx_needs_drop.add_gen(a_id, move_path_index.get());
+            } else {
+                debug!("add_drop_obligations(a={}) skips non-drop {}",
+                       a.to_string_(self, tcx),
+                       self.path_loan_path(move_path_index).repr(tcx));
+            }
+        };
+
+        let report_variant = |move_path_index| {
+            debug!("add_drop_obligations(a={}) skips variant {}",
+                   a.to_string_(self, tcx),
+                   self.path_loan_path(move_path_index).repr(tcx));
+        };
+
+        self.for_each_leaf(tcx, a_path, add_gen, report_variant);
+    }
+
+    fn remove_drop_obligations<A:RemoveNeedsDropArg>(&self,
+                                                     tcx: &ty::ctxt,
+                                                     a: &A,
+                                                     dfcx_needs_drop: &mut NeedsDropDataFlow) {
+        //! Kills all of the fragment leaves of path.
+        //!
+        //! Also kills all parents of path: while we do normalize a
+        //! path to its fragment leaves, (e.g. `a.j` to `{a.j.x,
+        //! a.j.y, a.j.z}`, an enum variant's path `(b:Variant1).x`
+        //! has the parent `b` that is itself considered a "leaf" for
+        //! the purposes of tracking drop obligations.
+
+        let id = a.node_id_removing_obligation();
+        let path : MovePathIndex = a.path_being_moved();
+
+        let add_kill = |move_path_index| {
+            if self.type_moves_by_default(tcx, move_path_index) {
+                debug!("remove_drop_obligations(id={}) removes {}",
+                       id, self.path_loan_path(move_path_index).repr(tcx));
+                dfcx_needs_drop.add_kill(id, move_path_index.get());
+            } else {
+                debug!("remove_drop_obligations(id={}) skips copyable {}",
+                       id, self.path_loan_path(move_path_index).repr(tcx));
+            }
+        };
+
+        let report_variant = |move_path_index| {
+            debug!("remove_drop_obligations(id={}) skips variant {}",
+                   id, self.path_loan_path(move_path_index).repr(tcx));
+        };
+
+        self.for_each_leaf(tcx, path, add_kill, report_variant);
+    }
+
+    fn add_ignored_drops(&self,
+                         tcx: &ty::ctxt,
+                         variant_match: &VariantMatch,
+                         dfcx_ignore_drop: &mut IgnoreDropDataFlow) {
+        let path_lp = self.path_loan_path(variant_match.path);
+        let base_path_lp = self.path_loan_path(variant_match.base_path);
+
+        if !self.path_needs_drop(tcx, variant_match.path) {
+            debug!("add_ignored_drops(id={} lp={}) adds {}",
+                   variant_match.id, path_lp.repr(tcx), base_path_lp.repr(tcx));
+            dfcx_ignore_drop.add_gen(variant_match.id, variant_match.base_path.get());
+        } else {
+            debug!("add_ignored_drops(id={} lp={}) skipped {}",
+                   variant_match.id, path_lp.repr(tcx), base_path_lp.repr(tcx));
+        }
+    }
+}
+
+trait AddNeedsDropArg {
+    fn node_id_adding_obligation(&self) -> ast::NodeId;
+    fn path_being_established(&self) -> MovePathIndex;
+    fn to_string_(&self, move_data: &MoveData, tcx: &ty::ctxt) -> String;
+}
+impl AddNeedsDropArg for Assignment {
+    fn node_id_adding_obligation(&self) -> ast::NodeId { self.id }
+    fn path_being_established(&self) -> MovePathIndex { self.path }
+    fn to_string_(&self, md: &MoveData, tcx: &ty::ctxt) -> String { self.to_string(md, tcx) }
+}
+impl AddNeedsDropArg for VariantMatch {
+    fn node_id_adding_obligation(&self) -> ast::NodeId { self.id }
+    fn path_being_established(&self) -> MovePathIndex { self.path }
+    fn to_string_(&self, md: &MoveData, tcx: &ty::ctxt) -> String { self.to_string(md, tcx) }
+}
+
+trait RemoveNeedsDropArg {
+    fn node_id_removing_obligation(&self) -> ast::NodeId;
+    fn path_being_moved(&self) -> MovePathIndex;
+}
+struct Removed { where_: ast::NodeId, what_path: MovePathIndex }
+impl RemoveNeedsDropArg for Removed {
+    fn node_id_removing_obligation(&self) -> ast::NodeId { self.where_ }
+    fn path_being_moved(&self) -> MovePathIndex { self.what_path }
+}
+impl<'a> RemoveNeedsDropArg for Move {
+    fn node_id_removing_obligation(&self) -> ast::NodeId { self.id }
+    fn path_being_moved(&self) -> MovePathIndex { self.path }
+}
+impl<'a> RemoveNeedsDropArg for VariantMatch {
+    fn node_id_removing_obligation(&self) -> ast::NodeId { self.id }
+    fn path_being_moved(&self) -> MovePathIndex { self.base_path }
 }
 
 impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {
@@ -555,16 +1241,45 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {
                                  AssignDataFlowOperator,
                                  id_range,
                                  move_data.var_assignments.borrow().len());
-        move_data.add_gen_kills(tcx, &mut dfcx_moves, &mut dfcx_assign);
+        let mut dfcx_needs_drop =
+            DataFlowContext::new(tcx,
+                                 "flowed_move_data_needs_drop",
+                                 Some(decl),
+                                 cfg,
+                                 NeedsDropDataFlowOperator,
+                                 id_range,
+                                 move_data.paths.borrow().len());
+        let mut dfcx_ignore_drop =
+            DataFlowContext::new(tcx,
+                                 "flowed_move_data_ignore_drop",
+                                 Some(decl),
+                                 cfg,
+                                 IgnoreDropDataFlowOperator,
+                                 id_range,
+                                 move_data.paths.borrow().len());
+
+        move_data.add_gen_kills(tcx,
+                                &mut dfcx_moves,
+                                &mut dfcx_assign,
+                                &mut dfcx_needs_drop,
+                                &mut dfcx_ignore_drop);
+
         dfcx_moves.add_kills_from_flow_exits(cfg);
         dfcx_assign.add_kills_from_flow_exits(cfg);
+        dfcx_needs_drop.add_kills_from_flow_exits(cfg);
+        dfcx_ignore_drop.add_kills_from_flow_exits(cfg);
+
         dfcx_moves.propagate(cfg, body);
         dfcx_assign.propagate(cfg, body);
+        dfcx_needs_drop.propagate(cfg, body);
+        dfcx_ignore_drop.propagate(cfg, body);
 
         FlowedMoveData {
             move_data: move_data,
             dfcx_moves: dfcx_moves,
             dfcx_assign: dfcx_assign,
+            dfcx_needs_drop: dfcx_needs_drop,
+            dfcx_ignore_drop: dfcx_ignore_drop,
         }
     }
 
@@ -732,3 +1447,157 @@ impl DataFlowOperator for AssignDataFlowOperator {
         false // no assignments in scope by default
     }
 }
+
+impl BitwiseOperator for NeedsDropDataFlowOperator {
+    #[inline]
+    fn join(&self, succ: uint, pred: uint) -> uint {
+        // In principle, for correct code, the fixed-point solution
+        // to the dataflow equations will have succ == pred here.
+        //
+        // But of course need to deal with states before we hit the
+        // fixed point.  Consider the following while-loop:
+        //
+        //   `{ let a = box 3; while <cond> { <body> } <rest> }`
+        // where <cond> and <body> do not move or drop `a`:
+        //
+        //                    [let a = box 3;]
+        //                      |
+        //                      v 1
+        //                  [loopback] <--+ 5
+        //                      |         |
+        //                      v 2       |
+        //              +-----[cond]      |
+        //              |       |         |
+        //              |       v 4       |
+        //              |     [body] -----+
+        //              v 3
+        //            [rest]
+        //
+        // we need to ensure that the fixed-point solution registers
+        // that `a` is needs-drop on all of the above edges.  (Note
+        // that choosing logical-and and a false initial value would
+        // cause the fixed point solution to falsely claim that `a` is
+        // only needs-drop on edge 1, because edge 5 would start as
+        // false and then the merge between edge 1 and edge 5 would be
+        // logically anded to false on edge 2, and so on.)
+        //
+        // We could use logical-or here (and a false initial value)
+        // like the other analyses.  Or, we can (and do) use
+        // logical-and and a true initial value.  For correct code,
+        // they will both end with the same fixed point.
+        //
+        // The reason to use logical-and instead of logical-or is
+        // error reporting.  In particular, we start with an
+        // assumption.
+        //
+        // ASSUMPTION: When there is a discrepancy between the set of
+        // drop-obligations for two paths at a merge point, we assume
+        // for the purposes of error reporting that the error was that
+        // the user forgot to include a drop of the resource, *not*
+        // that the user intended to re-establish the resource on the
+        // path where it had been dropped.
+        //
+        // Consider the following example:
+        //
+        //                       [let a = box 3;]             
+        //                             +                      
+        //                             |                      
+        //                             v                      
+        //                    +---+[cond 1]+--+               
+        //    (a needs drop)  |               | (a needs drop)
+        //                    v               |               
+        //             +-+[cond 2]+-+         |               
+        //             |            |         |               
+        //             v            v         v               
+        //     [no use of a]   [consume a]   [consume a]      
+        //                +         +         |               
+        // (a needs drop) |         |  ()     | ()            
+        //                v         v         |               
+        //              [merge point 1]       |               
+        //                    +               |               
+        //                (*) |               |               
+        //                    +---------+     |               
+        //                              |     |               
+        //                              v     v               
+        //                          [merge point 2]           
+        //
+        // At `[merge point 1]`, we obviously report a discrepancy
+        // between the two incoming paths.  The question: What do we
+        // want the set of drop obligations to be at the exit of
+        // `[merge point 1]`, where the `(*)` is marked.  There are
+        // two possible choices for `(*)`: `()`, and `(a needs drop)`.
+        //
+        // Choosing `(a needs drop)` corresponds to an assumption that
+        // on the path where `a` was dropped, the programmer probably
+        // meant to re-establish `a`.  To get this choice, one would
+        // use logical-or here.
+        //
+        // Choosing `()` corresponds to an assumption that on the path
+        // where `a` was not dropped, the programmer probably meant to
+        // drop it.  To get this choice, we use logical-and here.
+        //
+        // Each choice for `(*)` also has implications for when
+        // check_drops considers `[merge point 2]`: Choosing `()`
+        // means that nothing is reported for `[merge point 2]`, since
+        // the two incoming paths have the same set of drop
+        // obligations.  Choosing `(a needs drop)` means that we get a
+        // similar error report to the one for `[merge point 1]`,
+        // which may be frustrating to the programmer who already
+        // probably saw that they would need to add the drop of `a` on
+        // the far left path.
+        //
+        // (One could argue that the above example is artificial,
+        // since a small alteration of the graph above has a path on
+        // the far right-hand side that does not consume `a`, and in
+        // that situation, choosing `(a needs drop)` for `(*)` will
+        // produce fewer error messages.  However, we are *not*
+        // selecting logical-and over logical-or solely based on some
+        // expectation of the number of error messages encountered.
+        // Instead, it is based on our starting assumption: if in
+        // example above the far right path is missing a drop of a,
+        // then by our assumption, we *should* issue two error
+        // reports, since there are *two* places where the programmer
+        // needs to add calls to drop: the far left-hand path, and the
+        // far right-hand path.)
+
+        succ & pred
+    }
+}
+
+impl DataFlowOperator for NeedsDropDataFlowOperator {
+    #[inline]
+    fn initial_value(&self) -> bool {
+        // For non-entry nodes, assume paths need dropping until
+        // proven otherwise.
+        //
+        // See extensive discussion in impl BitwiseOperator for
+        // NeedsDropDataFlowOperator.
+        true
+    }
+
+    #[inline]
+    fn entry_initial_value(&self) -> bool {
+        false
+    }
+}
+
+impl BitwiseOperator for IgnoreDropDataFlowOperator {
+    #[inline]
+    fn join(&self, succ: uint, pred: uint) -> uint {
+        // You can only ignore a drop if both incoming paths agree that you can do so
+        succ & pred
+    }
+}
+
+impl DataFlowOperator for IgnoreDropDataFlowOperator {
+    #[inline]
+    fn initial_value(&self) -> bool {
+        // For non-entry nodes, assume you can ignore a drop until proven otherwise.
+        true
+    }
+
+    #[inline]
+    fn entry_initial_value(&self) -> bool {
+        false
+    }
+}
diff --git a/src/librustc/middle/borrowck/needs_drop.rs b/src/librustc/middle/borrowck/needs_drop.rs
new file mode 100644
index 0000000..94f2de6
--- /dev/null
+++ b/src/librustc/middle/borrowck/needs_drop.rs
@@ -0,0 +1,169 @@
+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT
+// file at the top-level directory of this distribution and at
+// http://rust-lang.org/COPYRIGHT.
+//
+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
+// option. This file may not be copied, modified, or distributed
+// except according to those terms.
+
+/// Data structures for tracking which paths are scheduled for
+/// eventual dropping (as opposed to paths that has been moved, and
+/// thus the drop obligation has been shifted to the receiver of the
+/// move).
+///
+/// The goal is to identify control-flow join points where one
+/// predecessor node has a path that needs to be eventually dropped
+/// while that same path has been moved away on another predecessor
+/// node. Such join points will probably become illegal in the future
+/// (so that the set of dropped state is equivalent on all
+/// control-flow paths, and thus the drop-flag can be removed from
+/// droppable structures).
+
+use std::collections::{HashMap, HashSet};
+use middle::borrowck::*;
+use middle::cfg;
+use middle::dataflow::DataFlowContext;
+use middle::dataflow::BitwiseOperator;
+use middle::dataflow;
+use euv = middle::expr_use_visitor;
+use mc = middle::mem_categorization;
+use middle::ty;
+use syntax::ast;
+use syntax::ast_util;
+use syntax::codemap::Span;
+
+struct NeedsDropCtxt<'a> {
+    paths: uint,
+}
+
+impl<'a> euv::Delegate for NeedsDropCtxt<'a> {
+    // The value found at `cmt` is either copied or moved, depending
+    // on mode.
+    fn consume(&mut self,
+               consume_id: ast::NodeId,
+               consume_span: Span,
+               cmt: mc::cmt,
+               mode: euv::ConsumeMode) {
+        debug!("consume(consume_id={}, cmt={}, mode={})",
+               consume_id, cmt.repr(self.tcx()), mode);
+
+        unimplemented!()
+    }
+
+    // The value found at `cmt` is either copied or moved via the
+    // pattern binding `consume_pat`, depending on mode.
+    fn consume_pat(&mut self,
+                   consume_pat: &ast::Pat,
+                   cmt: mc::cmt,
+                   mode: euv::ConsumeMode) {
+        debug!("consume_pat(consume_pat={}, cmt={}, mode={})",
+               consume_pat.repr(self.tcx()),
+               cmt.repr(self.tcx()),
+               mode);
+
+        unimplemented!()
+    }
+
+    // The value found at `borrow` is being borrowed at the point
+    // `borrow_id` for the region `loan_region` with kind `bk`.
+    fn borrow(&mut self,
+              borrow_id: ast::NodeId,
+              borrow_span: Span,
+              cmt: mc::cmt,
+              loan_region: ty::Region,
+              bk: ty::BorrowKind,
+              loan_cause: euv::LoanCause) {
+        debug!("borrow(borrow_id={}, cmt={}, loan_region={}, \
+               bk={}, loan_cause={:?})",
+               borrow_id, cmt.repr(self.tcx()), loan_region,
+               bk, loan_cause);
+
+        unimplemented!()
+    }
+
+    // The local variable `id` is declared but not initialized.
+    fn decl_without_init(&mut self,
+                         id: ast::NodeId,
+                         span: Span) {
+        debug!("decl_without_init(id={})", id);
+
+        unimplemented!()
+    }
+
+    // The path at `cmt` is being assigned to.
+    fn mutate(&mut self,
+              assignment_id: ast::NodeId,
+              assignment_span: Span,
+              assignee_cmt: mc::cmt,
+              mode: euv::MutateMode) {
+        debug!("mutate(assignment_id={}, assignee_cmt={})",
+               assignment_id, assignee_cmt.repr(self.tcx()));
+
+        unimplemented!()
+    }
+}
+
+#[deriving(Clone)]
+pub struct Operator;
+
+pub type NeedsDropDataFlow<'a> = DataFlowContext<'a, Operator>;
+
+
+
+pub struct NeedsDropData<'a> {
+    pub dfcx: NeedsDropDataFlow<'a>,
+}
+
+impl<'a> NeedsDropData<'a> {
+    pub fn new(bccx: &mut BorrowckCtxt<'a>,
+               id_range: ast_util::IdRange,
+               decl: &ast::FnDecl,
+               cfg: &cfg::CFG,
+               body: &ast::Block) -> NeedsDropData<'a> {
+        debug!("needs_drop::check_control_paths(body id={:?})", body.id);
+
+        let mut ndcx = NeedsDropCtxt {
+            paths: 0,
+        };
+
+        {
+            let mut euv = euv::ExprUseVisitor::new(&mut ndcx, bccx.tcx);
+            euv.walk_fn(decl, body);
+        }
+
+        let len = ndcx.paths;
+
+        let mut dfcx =
+            DataFlowContext::new(bccx.tcx,
+                                 "needs_drop",
+                                 Some(decl),
+                                 cfg,
+                                 Operator,
+                                 id_range,
+                                 len);
+
+        NeedsDropData {
+            dfcx: dfcx,
+        }
+    }
+}
+
+impl dataflow::BitwiseOperator for Operator {
+    /// Joins two predecessor bits together, typically either `|` or `&`
+    fn join(&self, succ: uint, pred: uint) -> uint {
+        succ | pred
+    }
+}
+
+impl dataflow::DataFlowOperator for Operator {
+    /// Specifies the initial value for each bit in the `on_entry` set
+    fn initial_value(&self) -> bool {
+        // nothing needs to be dropped until it is initialized.
+        // E.g. `let x;` should be initialized as not needing to be
+        // dropped.  (Other things like function parameters are of
+        // course implicitly initialized and are handled accordingly.)
+        false
+    }
+}
diff --git a/src/librustc/middle/cfg/construct.rs b/src/librustc/middle/cfg/construct.rs
index ec414b8..789c563 100644
--- a/src/librustc/middle/cfg/construct.rs
+++ b/src/librustc/middle/cfg/construct.rs
@@ -17,6 +17,7 @@ use syntax::ast;
 use syntax::ast_util;
 use util::nodemap::NodeMap;
 
+use std::collections::bitv::Bitv;
 use std::gc::Gc;
 
 struct CFGBuilder<'a, 'tcx: 'a> {
@@ -55,10 +56,36 @@ pub fn construct(tcx: &ty::ctxt,
     block_exit = cfg_builder.block(blk, entry);
     cfg_builder.add_contained_edge(block_exit, fn_exit);
     let CFGBuilder {exit_map, graph, ..} = cfg_builder;
+
+    let mut reachable = Bitv::with_capacity(graph.all_nodes().len(), false);
+    mark_reachable(&graph, entry, &mut reachable);
     CFG {exit_map: exit_map,
          graph: graph,
          entry: entry,
-         exit: fn_exit}
+         exit: fn_exit,
+         reachable: reachable}
+}
+
+fn mark_reachable(graph: &CFGGraph,
+                  entry: CFGIndex,
+                  reachable: &mut Bitv) {
+    let mut stack = vec![];
+    stack.push(entry);
+    loop {
+        let n = match stack.pop() {
+            None => return,
+            Some(n) => n,
+        };
+
+        reachable.set(n.node_id(), true);
+        graph.each_outgoing_edge(n, |_edge_index, edge| {
+            let target = edge.target();
+            if !reachable.get(target.node_id()) {
+                stack.push(target);
+            }
+            true
+        });
+    }
 }
 
 fn add_initial_dummy_node(g: &mut CFGGraph) -> CFGIndex {
@@ -121,31 +148,28 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {
             ast::PatBox(ref subpat) |
             ast::PatRegion(ref subpat) |
             ast::PatIdent(_, _, Some(ref subpat)) => {
-                let subpat_exit = self.pat(&**subpat, pred);
-                self.add_node(pat.id, [subpat_exit])
+                let pat_head_exit = self.add_node(pat.id, [pred]);
+                self.pat(&**subpat, pat_head_exit)
             }
 
             ast::PatEnum(_, Some(ref subpats)) |
             ast::PatTup(ref subpats) => {
-                let pats_exit =
-                    self.pats_all(subpats.iter().map(|p| p.clone()), pred);
-                self.add_node(pat.id, [pats_exit])
+                let pat_head_exit = self.add_node(pat.id, [pred]);
+                self.pats_all(subpats.iter().map(|p| p.clone()), pat_head_exit)
             }
 
             ast::PatStruct(_, ref subpats, _) => {
-                let pats_exit =
-                    self.pats_all(subpats.iter().map(|f| f.pat.clone()), pred);
-                self.add_node(pat.id, [pats_exit])
+                let pat_head_exit = self.add_node(pat.id, [pred]);
+                self.pats_all(subpats.iter().map(|f| f.pat.clone()), pat_head_exit)
             }
 
             ast::PatVec(ref pre, ref vec, ref post) => {
+                let pat_head_exit = self.add_node(pat.id, [pred]);
                 let pre_exit =
-                    self.pats_all(pre.iter().map(|p| *p), pred);
+                    self.pats_all(pre.iter().map(|p| *p), pat_head_exit);
                 let vec_exit =
                     self.pats_all(vec.iter().map(|p| *p), pre_exit);
-                let post_exit =
-                    self.pats_all(post.iter().map(|p| *p), vec_exit);
-                self.add_node(pat.id, [post_exit])
+                self.pats_all(post.iter().map(|p| *p), vec_exit)
             }
 
             ast::PatMac(_) => {
@@ -345,8 +369,9 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {
                 //  [guard1]   |
                 //     |       |
                 //     |       |
-                //     v 5     v
-                //  [body1]  [cond2]
+                //     v 5     |
+                //  [body1]    V
+                //     |     [cond2]
                 //     |      /  \
                 //     |    ...  ...
                 //     |     |    |
diff --git a/src/librustc/middle/cfg/mod.rs b/src/librustc/middle/cfg/mod.rs
index bb758ec..e3f88c7 100644
--- a/src/librustc/middle/cfg/mod.rs
+++ b/src/librustc/middle/cfg/mod.rs
@@ -20,6 +20,8 @@ use middle::ty;
 use syntax::ast;
 use util::nodemap::NodeMap;
 
+use std::collections::bitv::Bitv;
+
 mod construct;
 pub mod graphviz;
 
@@ -28,6 +30,7 @@ pub struct CFG {
     pub graph: CFGGraph,
     pub entry: CFGIndex,
     pub exit: CFGIndex,
+    pub reachable: Bitv,
 }
 
 pub struct CFGNodeData {
@@ -51,4 +54,8 @@ impl CFG {
                blk: &ast::Block) -> CFG {
         construct::construct(tcx, blk)
     }
+
+    pub fn is_reachable(&self, cfg_index: CFGIndex) -> bool {
+        self.reachable.get(cfg_index.node_id())
+    }
 }
diff --git a/src/librustc/middle/check_match.rs b/src/librustc/middle/check_match.rs
index 6676ea9..f8770b5 100644
--- a/src/librustc/middle/check_match.rs
+++ b/src/librustc/middle/check_match.rs
@@ -12,7 +12,7 @@ use middle::const_eval::{compare_const_vals, const_bool, const_float, const_nil,
 use middle::const_eval::{const_expr_to_pat, eval_const_expr, lookup_const_by_id};
 use middle::def::*;
 use middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, Init};
-use middle::expr_use_visitor::{JustWrite, LoanCause, MutateMode};
+use middle::expr_use_visitor::{JustWrite, LoanCause, MatchMode, MutateMode};
 use middle::expr_use_visitor::{WriteAndRead};
 use middle::mem_categorization::cmt;
 use middle::pat_util::*;
@@ -977,6 +977,7 @@ struct MutationChecker<'a, 'tcx: 'a> {
 
 impl<'a, 'tcx> Delegate for MutationChecker<'a, 'tcx> {
     fn consume(&mut self, _: NodeId, _: Span, _: cmt, _: ConsumeMode) {}
+    fn matched_pat(&mut self, _: &Pat, _: cmt, _: MatchMode) {}
     fn consume_pat(&mut self, _: &Pat, _: cmt, _: ConsumeMode) {}
     fn borrow(&mut self,
               _: NodeId,
diff --git a/src/librustc/middle/check_rvalues.rs b/src/librustc/middle/check_rvalues.rs
index f851ddb..9851f0c 100644
--- a/src/librustc/middle/check_rvalues.rs
+++ b/src/librustc/middle/check_rvalues.rs
@@ -57,6 +57,11 @@ impl<'a, 'tcx> euv::Delegate for RvalueContext<'a, 'tcx> {
         }
     }
 
+    fn matched_pat(&mut self,
+                   matched_pat: &ast::Pat,
+                   cmt: mc::cmt,
+                   mode: euv::MatchMode) {}
+
     fn consume_pat(&mut self,
                    _consume_pat: &ast::Pat,
                    _cmt: mc::cmt,
diff --git a/src/librustc/middle/dataflow.rs b/src/librustc/middle/dataflow.rs
index c32f8db..22da628 100644
--- a/src/librustc/middle/dataflow.rs
+++ b/src/librustc/middle/dataflow.rs
@@ -77,7 +77,20 @@ pub trait BitwiseOperator {
 /// Parameterization for the precise form of data flow that is used.
 pub trait DataFlowOperator : BitwiseOperator {
     /// Specifies the initial value for each bit in the `on_entry` set
+    /// for every node (except `cfg.entry`) in the flowgraph `cfg`
+    /// that is being analyzed.
+    ///
+    /// See also `entry_initial_value`.
     fn initial_value(&self) -> bool;
+
+    /// Specifies the initial value for each bit in the `on_entry` set
+    /// for `cfg.entry` in the flowgraph `cfg` that is being analyzed.
+    ///
+    /// Defaults to `self.initial_value()`, since many dataflow
+    /// analyses use the same setting in both contexts.
+    fn entry_initial_value(&self) -> bool {
+        self.initial_value()
+    }
 }
 
 struct PropagationContext<'a, 'b: 'a, 'tcx: 'b, O: 'a> {
@@ -108,7 +121,8 @@ impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O
             pprust::NodeExpr(expr) => expr.id,
             pprust::NodeBlock(blk) => blk.id,
             pprust::NodeItem(_) => 0,
-            pprust::NodePat(pat) => pat.id
+            pprust::NodePat(pat) => pat.id,
+            pprust::NodeMethod(m) => m.id,
         };
 
         if self.has_bitset_for_nodeid(id) {
@@ -199,15 +213,15 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {
                analysis_name, id_range, bits_per_id, words_per_id,
                num_nodes);
 
-        let entry = if oper.initial_value() { uint::MAX } else {0};
+        let init_most = if oper.initial_value() { uint::MAX } else {0};
 
         let gens = Vec::from_elem(num_nodes * words_per_id, 0);
         let kills = Vec::from_elem(num_nodes * words_per_id, 0);
-        let on_entry = Vec::from_elem(num_nodes * words_per_id, entry);
+        let on_entry = Vec::from_elem(num_nodes * words_per_id, init_most);
 
         let nodeid_to_index = build_nodeid_to_index(decl, cfg);
 
-        DataFlowContext {
+        let mut dfcx = DataFlowContext {
             tcx: tcx,
             analysis_name: analysis_name,
             words_per_id: words_per_id,
@@ -217,7 +231,22 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {
             gens: gens,
             kills: kills,
             on_entry: on_entry
+        };
+
+        if dfcx.words_per_id == 0 {
+            return dfcx;
+        }
+
+        let init_first = if dfcx.oper.entry_initial_value() { uint::MAX } else {0};
+        if init_first != init_most {
+            let (start, end) = dfcx.compute_id_range(cfg.entry);
+            let on_entry_to_entry = dfcx.on_entry.mut_slice(start, end);
+            for elem in on_entry_to_entry.mut_iter() {
+                *elem = init_first;
+            }
         }
+
+        dfcx
     }
 
     pub fn add_gen(&mut self, id: ast::NodeId, bit: uint) {
@@ -246,11 +275,13 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {
         set_bit(kills, bit);
     }
 
-    fn apply_gen_kill(&self, cfgidx: CFGIndex, bits: &mut [uint]) {
+    pub fn apply_gen_kill(&self, cfgidx: CFGIndex, bits: &mut [uint]) {
         //! Applies the gen and kill sets for `cfgidx` to `bits`
         debug!("{:s} apply_gen_kill(cfgidx={}, bits={}) [before]",
                self.analysis_name, cfgidx, mut_bits_to_string(bits));
-        assert!(self.bits_per_id > 0);
+        if self.bits_per_id == 0 {
+            return;
+        }
 
         let (start, end) = self.compute_id_range(cfgidx);
         let gens = self.gens.slice(start, end);
@@ -275,6 +306,19 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {
         (start, end)
     }
 
+    pub fn bitset_for(&self, e: EntryOrExit, cfgidx: CFGIndex) -> Vec<uint> {
+        self.with_set(e, cfgidx, || Vec::new(), |slice| slice.to_owned())
+    }
+
+    /// Let S be the entry/exit (`e`) set for `cfgidx`.  Sets `bits`
+    /// to `bits o S` where `o` denotes the bitwise operator `oper`.
+    pub fn apply_op<Op:BitwiseOperator>(&self,
+                                        e: EntryOrExit,
+                                        cfgidx: CFGIndex,
+                                        bits: &mut [uint],
+                                        oper: Op) {
+        self.with_set(e, cfgidx, || (), |slice| { bitwise(bits, slice, &oper); })
+    }
 
     pub fn each_bit_on_entry(&self,
                              id: ast::NodeId,
@@ -292,15 +336,28 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {
     pub fn each_bit_for_node(&self,
                              e: EntryOrExit,
                              cfgidx: CFGIndex,
-                             f: |uint| -> bool)
+                             on_one: |uint| -> bool)
                              -> bool {
         //! Iterates through each bit that is set on entry/exit to `cfgidx`.
         //! Only useful after `propagate()` has been called.
 
+        self.with_set(e, cfgidx, || true, |slice| {
+            debug!("{:s} each_bit_for_node({}, cfgidx={}) bits={}",
+                   self.analysis_name, e, cfgidx, bits_to_string(slice));
+            self.each_one_bit(slice, |x|on_one(x))
+        })
+    }
+
+    fn with_set<A>(&self,
+                   e: EntryOrExit,
+                   cfgidx: CFGIndex,
+                   default: || -> A,
+                   f: |&[uint]| -> A) -> A {
+
         if self.bits_per_id == 0 {
-            // Skip the surprisingly common degenerate case.  (Note
+            // degenerate case: use the default.  (Note
             // compute_id_range requires self.words_per_id > 0.)
-            return true;
+            return default();
         }
 
         let (start, end) = self.compute_id_range(cfgidx);
@@ -315,9 +372,8 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {
                 temp_bits.as_slice()
             }
         };
-        debug!("{:s} each_bit_for_node({}, cfgidx={}) bits={}",
-               self.analysis_name, e, cfgidx, bits_to_string(slice));
-        self.each_bit(slice, f)
+
+        f(slice)
     }
 
     pub fn each_gen_bit(&self, id: ast::NodeId, f: |uint| -> bool)
@@ -338,11 +394,11 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {
         let gens = self.gens.slice(start, end);
         debug!("{:s} each_gen_bit(id={:?}, gens={})",
                self.analysis_name, id, bits_to_string(gens));
-        self.each_bit(gens, f)
+        self.each_one_bit(gens, f)
     }
 
-    fn each_bit(&self, words: &[uint], f: |uint| -> bool) -> bool {
-        //! Helper for iterating over the bits in a bit set.
+    fn each_one_bit(&self, words: &[uint], f: |uint| -> bool) -> bool {
+        //! Helper for iterating over the 1 bits in a bit set.
         //! Returns false on the first call to `f` that returns false;
         //! if all calls to `f` return true, then returns true.
 
@@ -575,6 +631,14 @@ fn bitwise<Op:BitwiseOperator>(out_vec: &mut [uint],
     changed
 }
 
+pub fn is_bit_set(words: &[uint], bit: uint) -> bool {
+    let word = bit / uint::BITS;
+    let bit_in_word = bit % uint::BITS;
+    let bit_mask = 1 << bit_in_word;
+    let oldv = words[word];
+    0 != (oldv & bit_mask)
+}
+
 fn set_bit(words: &mut [uint], bit: uint) -> bool {
     debug!("set_bit: words={} bit={}",
            mut_bits_to_string(words), bit_str(bit));
@@ -594,11 +658,18 @@ fn bit_str(bit: uint) -> String {
     format!("[{}:{}-{:02x}]", bit, byte, lobits)
 }
 
-struct Union;
+pub struct Union;
 impl BitwiseOperator for Union {
     fn join(&self, a: uint, b: uint) -> uint { a | b }
 }
-struct Subtract;
+pub struct Subtract;
 impl BitwiseOperator for Subtract {
     fn join(&self, a: uint, b: uint) -> uint { a & !b }
 }
+pub struct Intersect;
+impl BitwiseOperator for Intersect {
+    fn join(&self, a: uint, b: uint) -> uint { a & b }
+}
+pub fn subtract(a: &mut [uint], b: &[uint]) {
+    bitwise(a, b, &Subtract);
+}
diff --git a/src/librustc/middle/def.rs b/src/librustc/middle/def.rs
index 914cf45..ab35f75 100644
--- a/src/librustc/middle/def.rs
+++ b/src/librustc/middle/def.rs
@@ -15,6 +15,11 @@ use syntax::ast_util::local_def;
 use std::gc::Gc;
 
 #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]
+pub enum BindingAliasMode {
+    Aliasing(ast::NodeId),
+    Original,
+}
+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]
 pub enum Def {
     DefFn(ast::DefId, ast::FnStyle),
     DefStaticMethod(/* method */ ast::DefId, MethodProvenance, ast::FnStyle),
@@ -29,7 +34,7 @@ pub enum Def {
     DefTrait(ast::DefId),
     DefPrimTy(ast::PrimTy),
     DefTyParam(ParamSpace, ast::DefId, uint),
-    DefBinding(ast::NodeId, ast::BindingMode),
+    DefBinding(ast::NodeId, ast::BindingMode, BindingAliasMode),
     DefUse(ast::DefId),
     DefUpvar(ast::NodeId,  // id of closed over var
              Gc<Def>,     // closed over def
@@ -70,7 +75,7 @@ impl Def {
             DefLocal(id, _) |
             DefSelfTy(id) |
             DefUpvar(id, _, _, _) |
-            DefBinding(id, _) |
+            DefBinding(id, _, _) |
             DefRegion(id) |
             DefTyParamBinder(id) |
             DefLabel(id) => {
diff --git a/src/librustc/middle/expr_use_visitor.rs b/src/librustc/middle/expr_use_visitor.rs
index 207620b..6d376a7 100644
--- a/src/librustc/middle/expr_use_visitor.rs
+++ b/src/librustc/middle/expr_use_visitor.rs
@@ -42,6 +42,18 @@ pub trait Delegate {
                cmt: mc::cmt,
                mode: ConsumeMode);
 
+    // The value found at `cmt` has been determined to match the
+    // pattern binding `matched_pat`, and its subparts are being
+    // copied or moved depending on `mode`.  Note that `matched_pat`
+    // is called on all variant/structs in the pattern (i.e., the
+    // interior nodes of the pattern's tree structure) while
+    // consume_pat is called on the binding identifiers in the pattern
+    // (i.e., the leaves of the pattern's tree structure)
+    fn matched_pat(&mut self,
+                   matched_pat: &ast::Pat,
+                   cmt: mc::cmt,
+                   mode: MatchMode);
+
     // The value found at `cmt` is either copied or moved via the
     // pattern binding `consume_pat`, depending on mode.
     fn consume_pat(&mut self,
@@ -97,6 +109,80 @@ pub enum MoveReason {
 }
 
 #[deriving(PartialEq,Show)]
+pub enum MatchMode {
+    NonBindingMatch,
+    BorrowingMatch,
+    CopyingMatch,
+    MovingMatch,
+}
+
+#[deriving(PartialEq,Show)]
+enum TrackMatchMode {
+    Unknown, Definite(MatchMode), Conflicting
+}
+
+impl TrackMatchMode {
+    // Builds up the whole match mode for a pattern from its constituent
+    // parts.  The lattice looks like this:
+    //
+    //             Conflicting
+    //              /      \
+    //             /       \
+    //       Borrowing    Moving
+    //            \        /
+    //            \       /
+    //             Copying
+    //                |
+    //            NonBinding
+    //                |
+    //             Unknown
+    //
+    // examples:
+    //
+    // * `(_, some_int)` pattern is Copying, since
+    //   NonBinding + Copying => Copying
+    //
+    // * `(some_int, some_box)` pattern is Moving, since
+    //   Copying + Moving => Moving
+    //
+    // * `(ref x, some_box)` pattern is Conflicting, since
+    //   Borrowing + Moving => Conflicting
+    //
+    // Note that the `Unknown` and `Conflicting` states are
+    // represented separately from the other more interesting
+    // `Definite` states, which simplifies logic here somewhat.
+    fn meet(&mut self, mode: MatchMode) {
+        *self = match (*self, mode) {
+            // Note that clause order below is very significant.
+            (Unknown, new) => Definite(new),
+            (Definite(old), new) if old == new => Definite(old),
+
+            (Definite(old), NonBindingMatch) => Definite(old),
+            (Definite(NonBindingMatch), new) => Definite(new),
+
+            (Definite(old), CopyingMatch) => Definite(old),
+            (Definite(CopyingMatch), new) => Definite(new),
+
+            _ => Conflicting
+        };
+    }
+
+    fn mode(self) -> MatchMode {
+        match self {
+            // if we don't know, then there was no binding.
+            Unknown => NonBindingMatch,
+
+            Definite(mm) => mm,
+
+            // if there were conflicting results, then we will hit a
+            // compiler error later.  But to let rustc make progress
+            // now, claim it was a move (i.e. consumes the input).
+            Conflicting => MovingMatch,
+        }
+    }
+}
+
+#[deriving(PartialEq,Show)]
 pub enum MutateMode {
     Init,
     JustWrite,    // x = y
@@ -242,7 +328,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {
                 ty::ReScope(body.id), // Args live only as long as the fn body.
                 arg_ty);
 
-            self.walk_pat(arg_cmt, arg.pat.clone());
+            self.walk_pat_isolated(arg_cmt, arg.pat.clone());
         }
     }
 
@@ -362,7 +448,9 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {
                 self.walk_expr(&**discr);
                 let discr_cmt = return_if_err!(self.mc.cat_expr(&**discr));
                 for arm in arms.iter() {
-                    self.walk_arm(discr_cmt.clone(), arm);
+                    let mut mode = Unknown;
+                    self.walk_arm_prepass(discr_cmt.clone(), arm, &mut mode);
+                    self.walk_arm(discr_cmt.clone(), arm, &mode);
                 }
             }
 
@@ -419,7 +507,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {
                                                  pat.span,
                                                  ty::ReScope(blk.id),
                                                  pattern_type);
-                self.walk_pat(pat_cmt, pat.clone());
+                self.walk_pat_isolated(pat_cmt, pat.clone());
 
                 self.walk_block(&**blk);
             }
@@ -588,7 +676,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {
                 // `walk_pat`:
                 self.walk_expr(&**expr);
                 let init_cmt = return_if_err!(self.mc.cat_expr(&**expr));
-                self.walk_pat(init_cmt, local.pat);
+                self.walk_pat_isolated(init_cmt, local.pat);
             }
         }
     }
@@ -791,9 +879,15 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {
         return true;
     }
 
-    fn walk_arm(&mut self, discr_cmt: mc::cmt, arm: &ast::Arm) {
+    fn walk_arm_prepass(&mut self, discr_cmt: mc::cmt, arm: &ast::Arm, mode: &mut TrackMatchMode) {
+        for &pat in arm.pats.iter() {
+            self.walk_pat_prepass(discr_cmt.clone(), pat, mode);
+        }
+    }
+
+    fn walk_arm(&mut self, discr_cmt: mc::cmt, arm: &ast::Arm, mode: &TrackMatchMode) {
         for &pat in arm.pats.iter() {
-            self.walk_pat(discr_cmt.clone(), pat);
+            self.walk_pat(discr_cmt.clone(), pat, mode);
         }
 
         for guard in arm.guard.iter() {
@@ -803,38 +897,90 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {
         self.consume_expr(&*arm.body);
     }
 
-    fn walk_pat(&mut self, cmt_discr: mc::cmt, pat: Gc<ast::Pat>) {
-        debug!("walk_pat cmt_discr={} pat={}", cmt_discr.repr(self.tcx()),
+    /// Walks a pat that occurs in isolation (i.e. top-level of a fn
+    /// arg or let binding.  *Not* a match arm or nested pat.)
+    fn walk_pat_isolated(&mut self, cmt_discr: mc::cmt, pat: Gc<ast::Pat>) {
+        let mut mode = Unknown;
+        self.walk_pat_prepass(cmt_discr.clone(), pat, &mut mode);
+        self.walk_pat(cmt_discr, pat, &mode);
+    }
+
+    /// Identifies any bindings within `pat` and accumulates within
+    /// `mode` whether the overall pattern/match structure is a move,
+    /// copy, or borrow.
+    fn walk_pat_prepass(&mut self,
+                        cmt_discr: mc::cmt,
+                        pat: Gc<ast::Pat>,
+                        mode: &mut TrackMatchMode) {
+        debug!("walk_pat_prepass cmt_discr={} pat={}", cmt_discr.repr(self.tcx()),
                pat.repr(self.tcx()));
+
+        return_if_err!(self.mc.cat_pattern(cmt_discr.clone(), &*pat, |_mc, cmt_pat, pat| {
+            let tcx = self.typer.tcx();
+            let def_map = &tcx.def_map;
+            if pat_util::pat_is_binding(def_map, pat) {
+                debug!("prepass binding cmt_pat={} pat={}", cmt_pat.repr(tcx), pat.repr(tcx));
+
+                match pat.node {
+                    ast::PatIdent(ast::BindByRef(_), _, _) =>
+                        mode.meet(BorrowingMatch),
+                    ast::PatIdent(ast::BindByValue(_), _, _) => {
+                        match copy_or_move(tcx, cmt_pat.ty, PatBindingMove) {
+                            Copy => mode.meet(CopyingMatch),
+                            Move(_) => mode.meet(MovingMatch),
+                        }
+                    }
+                    _ => {
+                        // we will report the error here in the actual
+                        // pass, after the prepass is completed.
+                    }
+                }
+            }
+        }));
+    }
+
+    fn walk_pat(&mut self,
+                cmt_discr: mc::cmt,
+                pat: Gc<ast::Pat>,
+                outer_context_mode: &TrackMatchMode) {
+        debug!("walk_pat cmt_discr={} pat={} outer_context_mode={}",
+               cmt_discr.repr(self.tcx()), pat.repr(self.tcx()), outer_context_mode);
+
+        let match_mode = outer_context_mode.mode();
+
         let mc = &self.mc;
         let typer = self.typer;
         let tcx = typer.tcx();
         let def_map = &self.typer.tcx().def_map;
         let delegate = &mut self.delegate;
-        return_if_err!(mc.cat_pattern(cmt_discr, &*pat, |mc, cmt_pat, pat| {
-            if pat_util::pat_is_binding(def_map, pat) {
+
+        return_if_err!(mc.cat_pattern(cmt_discr.clone(), &*pat, |mc, cmt_pat, pat| {
+            if pat_util::pat_is_binding_or_wild(def_map, pat) {
                 let tcx = typer.tcx();
 
-                debug!("binding cmt_pat={} pat={}",
+                debug!("binding cmt_pat={} pat={} match_mode={}",
                        cmt_pat.repr(tcx),
-                       pat.repr(tcx));
+                       pat.repr(tcx),
+                       match_mode);
 
                 // pat_ty: the type of the binding being produced.
                 let pat_ty = return_if_err!(typer.node_ty(pat.id));
 
-                // Each match binding is effectively an assignment to the
-                // binding being produced.
-                let def = def_map.borrow().get_copy(&pat.id);
-                match mc.cat_def(pat.id, pat.span, pat_ty, def) {
-                    Ok(binding_cmt) => {
-                        delegate.mutate(pat.id, pat.span, binding_cmt, Init);
+                if pat_util::pat_is_binding(def_map, pat) {
+                    // Each match binding is effectively an assignment to the
+                    // binding being produced.
+                    let def = def_map.borrow().get_copy(&pat.id);
+                    match mc.cat_def(pat.id, pat.span, pat_ty, def) {
+                        Ok(binding_cmt) => {
+                            delegate.mutate(pat.id, pat.span, binding_cmt, Init);
+                        }
+                        Err(_) => { }
                     }
-                    Err(_) => { }
                 }
 
                 // It is also a borrow or copy/move of the value being matched.
-                match pat.node {
-                    ast::PatIdent(ast::BindByRef(m), _, _) => {
+                match (&pat.node, match_mode) {
+                    (&ast::PatIdent(ast::BindByRef(m), _, _), _) => {
                         let (r, bk) = {
                             (ty::ty_region(tcx, pat.span, pat_ty),
                              ty::BorrowKind::from_mutbl(m))
@@ -842,11 +988,40 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {
                         delegate.borrow(pat.id, pat.span, cmt_pat,
                                              r, bk, RefBinding);
                     }
-                    ast::PatIdent(ast::BindByValue(_), _, _) => {
+
+                    (&ast::PatIdent(ast::BindByValue(_), _, _), _) => {
                         let mode = copy_or_move(typer.tcx(), cmt_pat.ty, PatBindingMove);
                         debug!("walk_pat binding consuming pat");
                         delegate.consume_pat(pat, cmt_pat, mode);
                     }
+
+                    (&ast::PatWild(_), MovingMatch) => {
+
+                        // On `enum E { Variant(Box<T>) }`, both of
+                        // the match arms:
+                        //
+                        //    Variant(a) => ...
+                        //    Variant(_) => ...
+                        //
+                        // are conceptually moving into the `Variant`
+                        // pattern, while the match arm:
+                        //
+                        //    a @ Variant(_) => ...
+                        //
+                        // is *not* moving into the `Variant(_)`.
+                        // Thus check the `pat_already_bound` flag to
+                        // distinguish the latter two cases.
+
+                        if !mc.pat_is_already_bound_by_value {
+                            let mode = copy_or_move(typer.tcx(), cmt_pat.ty, PatBindingMove);
+                            delegate.consume_pat(pat, cmt_pat, mode);
+                        }
+                    }
+
+                    (&ast::PatWild(_), NonBindingMatch) |
+                    (&ast::PatWild(_), BorrowingMatch) |
+                    (&ast::PatWild(_), CopyingMatch)  => {}
+
                     _ => {
                         typer.tcx().sess.span_bug(
                             pat.span,
@@ -900,6 +1075,54 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {
                 }
             }
         }));
+
+        return_if_err!(mc.cat_pattern(cmt_discr, &*pat, |mc, cmt_pat, pat| {
+            let def_map = def_map.borrow();
+            let tcx = typer.tcx();
+            let match_mode = if mc.pat_is_already_bound_by_value {
+                // A pat in the context of `id @ ... pat ...` cannot
+                // be moved into, it can at most copy or borrow.
+                //
+                // Actually, post PR #16053, we cannot do *any*
+                // binding in such a context, but I am writing this
+                // code in anticipation of loosening that rule (FSK).
+                BorrowingMatch
+            } else {
+                match_mode
+            };
+
+            match pat.node {
+                ast::PatEnum(_, _) | ast::PatIdent(_, _, None) | ast::PatStruct(..) => {
+                    match def_map.find(&pat.id) {
+                        Some(&def::DefVariant(enum_did, variant_did, _is_struct)) => {
+                            let downcast_cmt =
+                                if ty::enum_is_univariant(tcx, enum_did) {
+                                    cmt_pat
+                                } else {
+                                    let cmt_pat_ty = cmt_pat.ty;
+                                    mc.cat_downcast(pat, cmt_pat, cmt_pat_ty, variant_did)
+                                };
+
+                            debug!("variant downcast_cmt={} pat={}",
+                                   downcast_cmt.repr(tcx),
+                                   pat.repr(tcx));
+
+                            delegate.matched_pat(pat, downcast_cmt, match_mode);
+                        }
+
+                        Some(&def::DefStruct(..)) => {
+                            debug!("struct cmt_pat={} pat={}",
+                                   cmt_pat.repr(tcx),
+                                   pat.repr(tcx));
+
+                            delegate.matched_pat(pat, cmt_pat, match_mode);
+                        }
+                        _ => {}
+                    }
+                }
+                _ => {}
+            }
+        }));
     }
 
     fn walk_captures(&mut self, closure_expr: &ast::Expr) {
diff --git a/src/librustc/middle/lang_items.rs b/src/librustc/middle/lang_items.rs
index 2602ec4..5d55fc0 100644
--- a/src/librustc/middle/lang_items.rs
+++ b/src/librustc/middle/lang_items.rs
@@ -221,6 +221,7 @@ lets_do_this! {
     SyncTraitLangItem,               "sync",                    sync_trait;
 
     DropTraitLangItem,               "drop",                    drop_trait;
+    QuietEarlyDropTraitLangItem,     "quiet_early_drop",        quiet_early_drop;
 
     AddTraitLangItem,                "add",                     add_trait;
     SubTraitLangItem,                "sub",                     sub_trait;
diff --git a/src/librustc/middle/liveness.rs b/src/librustc/middle/liveness.rs
index 26aa51b..f03f0cb 100644
--- a/src/librustc/middle/liveness.rs
+++ b/src/librustc/middle/liveness.rs
@@ -440,7 +440,7 @@ fn visit_arm(ir: &mut IrMaps, arm: &Arm) {
 
 fn moved_variable_node_id_from_def(def: Def) -> Option<NodeId> {
     match def {
-        DefBinding(nid, _) |
+        DefBinding(nid, _, _) |
         DefArg(nid, _) |
         DefLocal(nid, _) => Some(nid),
 
diff --git a/src/librustc/middle/mem_categorization.rs b/src/librustc/middle/mem_categorization.rs
index abed04c..be9fb9f 100644
--- a/src/librustc/middle/mem_categorization.rs
+++ b/src/librustc/middle/mem_categorization.rs
@@ -88,7 +88,7 @@ pub enum categorization {
     cat_arg(ast::NodeId),              // formal argument
     cat_deref(cmt, uint, PointerKind), // deref of a ptr
     cat_interior(cmt, InteriorKind),   // something interior: field, tuple, etc
-    cat_downcast(cmt),                 // selects a particular enum variant (*1)
+    cat_downcast(cmt, ast::DefId),     // selects a particular enum variant (*1)
     cat_discr(cmt, ast::NodeId),       // match discriminant (see preserve())
 
     // (*1) downcast is only required if the enum has more than one variant
@@ -241,7 +241,11 @@ impl ast_node for ast::Pat {
 }
 
 pub struct MemCategorizationContext<'t,TYPER:'t> {
-    typer: &'t TYPER
+    typer: &'t TYPER,
+
+    // tracks when looking at `pat` in context of `id @ (... pat ...)`
+    // (it affects whether we move into a wildcard or not).
+    pub pat_is_already_bound_by_value: bool,
 }
 
 pub type McResult<T> = Result<T, ()>;
@@ -325,7 +329,7 @@ impl MutabilityCategory {
             def::DefStatic(_, true) => McDeclared,
 
             def::DefArg(_, binding_mode) |
-            def::DefBinding(_, binding_mode) |
+            def::DefBinding(_, binding_mode, _) |
             def::DefLocal(_, binding_mode)  => match binding_mode {
                 ast::BindByValue(ast::MutMutable) => McDeclared,
                 _ => McImmutable
@@ -377,7 +381,20 @@ macro_rules! if_ok(
 
 impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {
     pub fn new(typer: &'t TYPER) -> MemCategorizationContext<'t,TYPER> {
-        MemCategorizationContext { typer: typer }
+        MemCategorizationContext {
+            typer: typer,
+            pat_is_already_bound_by_value: false,
+        }
+    }
+
+    fn already_bound(&self, mode: ast::BindingMode) -> MemCategorizationContext<'t,TYPER> {
+        match mode {
+            ast::BindByRef(_) => *self,
+            ast::BindByValue(_) => MemCategorizationContext {
+                pat_is_already_bound_by_value: true,
+                ..*self
+            }
+        }
     }
 
     fn tcx(&self) -> &'t ty::ctxt<'tcx> {
@@ -627,7 +644,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {
           }
 
           def::DefLocal(vid, _) |
-          def::DefBinding(vid, _) => {
+          def::DefBinding(vid, _, def::Original) |
+          def::DefBinding(_, _, def::Aliasing(vid)) => {
             // by-value/by-ref bindings are local variables
             Ok(Rc::new(cmt_ {
                 id: id,
@@ -973,15 +991,10 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {
     pub fn cat_downcast<N:ast_node>(&self,
                                     node: &N,
                                     base_cmt: cmt,
-                                    downcast_ty: ty::t)
+                                    downcast_ty: ty::t,
+                                    variant_did: ast::DefId)
                                     -> cmt {
-        Rc::new(cmt_ {
-            id: node.id(),
-            span: node.span(),
-            mutbl: base_cmt.mutbl.inherit(),
-            cat: cat_downcast(base_cmt),
-            ty: downcast_ty
-        })
+        mk_cat_downcast(node, base_cmt, downcast_ty, variant_did)
     }
 
     pub fn cat_pattern(&self,
@@ -1052,14 +1065,14 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {
           }
           ast::PatEnum(_, Some(ref subpats)) => {
             match self.tcx().def_map.borrow().find(&pat.id) {
-                Some(&def::DefVariant(enum_did, _, _)) => {
+                Some(&def::DefVariant(enum_did, variant_did, _)) => {
                     // variant(x, y, z)
 
                     let downcast_cmt = {
                         if ty::enum_is_univariant(self.tcx(), enum_did) {
                             cmt // univariant, no downcast needed
                         } else {
-                            self.cat_downcast(pat, cmt.clone(), cmt.ty)
+                            self.cat_downcast(pat, cmt.clone(), cmt.ty, variant_did)
                         }
                     };
 
@@ -1099,8 +1112,9 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {
             }
           }
 
-          ast::PatIdent(_, _, Some(ref subpat)) => {
-              if_ok!(self.cat_pattern(cmt, &**subpat, op));
+          ast::PatIdent(binding_mode, _, Some(ref subpat)) => {
+              if_ok!(self.already_bound(binding_mode).cat_pattern(
+                  cmt, &**subpat, op));
           }
 
           ast::PatIdent(_, _, None) => {
@@ -1109,9 +1123,21 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {
 
           ast::PatStruct(_, ref field_pats, _) => {
             // {f1: p1, ..., fN: pN}
+            let downcast_cmt = match self.tcx().def_map.borrow().find(&pat.id) {
+                Some(&def::DefVariant(enum_did, variant_did, _)) => {
+                    // variant{ a: x, b: y, c: z }
+                    if ty::enum_is_univariant(self.tcx(), enum_did) {
+                        cmt // univariant, no downcast needed
+                    } else {
+                        self.cat_downcast(pat, cmt.clone(), cmt.ty, variant_did)
+                    }
+                }
+                _ => cmt,
+            };
+
             for fp in field_pats.iter() {
                 let field_ty = if_ok!(self.pat_ty(&*fp.pat)); // see (*2)
-                let cmt_field = self.cat_field(pat, cmt.clone(), fp.ident, field_ty);
+                let cmt_field = self.cat_field(pat, downcast_cmt.clone(), fp.ident, field_ty);
                 if_ok!(self.cat_pattern(cmt_field, &*fp.pat, |x,y,z| op(x,y,z)));
             }
           }
@@ -1213,13 +1239,26 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {
           cat_discr(ref cmt, _) => {
             self.cmt_to_string(&**cmt)
           }
-          cat_downcast(ref cmt) => {
+          cat_downcast(ref cmt, _) => {
             self.cmt_to_string(&**cmt)
           }
         }
     }
 }
 
+fn mk_cat_downcast<N:ast_node>(node: &N,
+                               base_cmt: cmt,
+                               downcast_ty: ty::t,
+                               variant_did: ast::DefId) -> cmt {
+    Rc::new(cmt_ {
+        id: node.id(),
+        span: node.span(),
+        mutbl: base_cmt.mutbl.inherit(),
+        cat: cat_downcast(base_cmt, variant_did),
+        ty: downcast_ty
+    })
+}
+
 pub enum InteriorSafety {
     InteriorUnsafe,
     InteriorSafe
@@ -1252,7 +1291,7 @@ impl cmt_ {
             cat_upvar(..) => {
                 Rc::new((*self).clone())
             }
-            cat_downcast(ref b) |
+            cat_downcast(ref b, _) |
             cat_discr(ref b, _) |
             cat_interior(ref b, _) |
             cat_deref(ref b, _, OwnedPtr) => {
@@ -1276,7 +1315,7 @@ impl cmt_ {
             cat_deref(ref b, _, Implicit(ty::MutBorrow, _)) |
             cat_deref(ref b, _, BorrowedPtr(ty::UniqueImmBorrow, _)) |
             cat_deref(ref b, _, Implicit(ty::UniqueImmBorrow, _)) |
-            cat_downcast(ref b) |
+            cat_downcast(ref b, _) |
             cat_deref(ref b, _, OwnedPtr) |
             cat_interior(ref b, _) |
             cat_discr(ref b, _) => {
@@ -1350,8 +1389,8 @@ impl Repr for categorization {
             cat_interior(ref cmt, interior) => {
                 format!("{}.{}", cmt.cat.repr(tcx), interior.repr(tcx))
             }
-            cat_downcast(ref cmt) => {
-                format!("{}->(enum)", cmt.cat.repr(tcx))
+            cat_downcast(ref cmt, ref variant_did) => {
+                format!("({}->{})", cmt.cat.repr(tcx), variant_did.repr(tcx))
             }
             cat_discr(ref cmt, _) => {
                 cmt.cat.repr(tcx)
diff --git a/src/librustc/middle/region.rs b/src/librustc/middle/region.rs
index 21bfcfe..1e13966 100644
--- a/src/librustc/middle/region.rs
+++ b/src/librustc/middle/region.rs
@@ -123,13 +123,13 @@ impl RegionMaps {
     }
 
     pub fn record_var_scope(&self, var: ast::NodeId, lifetime: ast::NodeId) {
-        debug!("record_var_scope(sub={}, sup={})", var, lifetime);
+        debug!("record_var_scope(var={}, lifetime={})", var, lifetime);
         assert!(var != lifetime);
         self.var_map.borrow_mut().insert(var, lifetime);
     }
 
     pub fn record_rvalue_scope(&self, var: ast::NodeId, lifetime: ast::NodeId) {
-        debug!("record_rvalue_scope(sub={}, sup={})", var, lifetime);
+        debug!("record_rvalue_scope(var={}, lifetime={})", var, lifetime);
         assert!(var != lifetime);
         self.rvalue_scopes.borrow_mut().insert(var, lifetime);
     }
diff --git a/src/librustc/middle/resolve.rs b/src/librustc/middle/resolve.rs
index 0c8697d..f04bf2a 100644
--- a/src/librustc/middle/resolve.rs
+++ b/src/librustc/middle/resolve.rs
@@ -126,13 +126,24 @@ impl LastPrivate {
     }
 }
 
-#[deriving(PartialEq)]
-enum PatternBindingMode {
-    RefutableMode,
+enum PatternBindingMode<'a> {
+    /// Payload maps idents to node ID of first occurrence of ident in
+    /// the first pattern in a match disjunction `p_1 | p_2 | ...`
+    RefutableMode(&'a mut HashMap<Name,NodeId>),
     LocalIrrefutableMode,
     ArgumentIrrefutableMode,
 }
 
+impl<'a> PatternBindingMode<'a> {
+    fn is_refutable(&self) -> bool {
+        match *self {
+            RefutableMode(_) => true,
+            LocalIrrefutableMode => false,
+            ArgumentIrrefutableMode => false,
+        }
+    }
+}
+
 #[deriving(PartialEq, Eq, Hash)]
 enum Namespace {
     TypeNS,
@@ -4582,8 +4593,11 @@ impl<'a> Resolver<'a> {
         self.value_ribs.borrow_mut().push(Rib::new(NormalRibKind));
 
         let mut bindings_list = HashMap::new();
+        let mut normalized_list = HashMap::new();
         for pattern in arm.pats.iter() {
-            self.resolve_pattern(&**pattern, RefutableMode, &mut bindings_list);
+            self.resolve_pattern(&**pattern,
+                                 RefutableMode(&mut normalized_list),
+                                 &mut bindings_list);
         }
 
         // This has to happen *after* we determine which
@@ -4723,6 +4737,7 @@ impl<'a> Resolver<'a> {
                        // pattern that binds them
                        bindings_list: &mut HashMap<Name,NodeId>) {
         let pat_id = pattern.id;
+        let mut mode = mode;
         walk_pat(pattern, |pattern| {
             match pattern.node {
                 PatIdent(binding_mode, ref path1, _) => {
@@ -4741,7 +4756,7 @@ impl<'a> Resolver<'a> {
 
                     match self.resolve_bare_identifier_pattern(ident, pattern.span) {
                         FoundStructOrEnumVariant(def, lp)
-                                if mode == RefutableMode => {
+                                if mode.is_refutable() => {
                             debug!("(resolving pattern) resolving `{}` to \
                                     struct or enum variant",
                                    token::get_name(renamed));
@@ -4760,7 +4775,7 @@ impl<'a> Resolver<'a> {
                                          scope",
                                         token::get_name(renamed)).as_slice());
                         }
-                        FoundConst(def, lp) if mode == RefutableMode => {
+                        FoundConst(def, lp) if mode.is_refutable() => {
                             debug!("(resolving pattern) resolving `{}` to \
                                     constant",
                                    token::get_name(renamed));
@@ -4781,11 +4796,20 @@ impl<'a> Resolver<'a> {
                                    token::get_name(renamed));
 
                             let def = match mode {
-                                RefutableMode => {
+                                RefutableMode(ref mut normalization) => {
+                                    let opt_first_id = normalization.find(&renamed).map(|&x|x);
+                                    let aliasing_mode = match opt_first_id {
+                                        Some(first_id) => Aliasing(first_id),
+                                        None => {
+                                            // this is the first id; insert it.
+                                            normalization.insert(renamed, pattern.id);
+                                            Original
+                                        }
+                                    };
+
                                     // For pattern arms, we must use
                                     // `def_binding` definitions.
-
-                                    DefBinding(pattern.id, binding_mode)
+                                    DefBinding(pattern.id, binding_mode, aliasing_mode)
                                 }
                                 LocalIrrefutableMode => {
                                     // But for locals, we use `def_local`.
diff --git a/src/librustc/middle/save/mod.rs b/src/librustc/middle/save/mod.rs
index 7c7960e..82abd2c 100644
--- a/src/librustc/middle/save/mod.rs
+++ b/src/librustc/middle/save/mod.rs
@@ -220,7 +220,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {
             def::DefTy(_) |
             def::DefTrait(_) => Some(recorder::TypeRef),
             def::DefStatic(_, _) |
-            def::DefBinding(_, _) |
+            def::DefBinding(_, _, _) |
             def::DefArg(_, _) |
             def::DefLocal(_, _) |
             def::DefVariant(_, _, _) |
@@ -740,11 +740,11 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {
             def::DefLocal(id, _) |
             def::DefArg(id, _) |
             def::DefUpvar(id, _, _, _) |
-            def::DefBinding(id, _) => self.fmt.ref_str(recorder::VarRef,
-                                                       ex.span,
-                                                       sub_span,
-                                                       ast_util::local_def(id),
-                                                       e.cur_scope),
+            def::DefBinding(id, _, _) => self.fmt.ref_str(recorder::VarRef,
+                                                          ex.span,
+                                                          sub_span,
+                                                          ast_util::local_def(id),
+                                                          e.cur_scope),
             def::DefStatic(def_id,_) |
             def::DefVariant(_, def_id, _) => self.fmt.ref_str(recorder::VarRef,
                                                               ex.span,
@@ -1373,12 +1373,12 @@ impl<'l, 'tcx> Visitor<DxrVisitorEnv> for DxrVisitor<'l, 'tcx> {
             }
             let def = def_map.get(&id);
             match *def {
-                def::DefBinding(id, _)  => self.fmt.variable_str(p.span,
-                                                                 sub_span,
-                                                                 id,
-                                                                 path_to_string(p).as_slice(),
-                                                                 value.as_slice(),
-                                                                 ""),
+                def::DefBinding(id, _, _)  => self.fmt.variable_str(p.span,
+                                                                    sub_span,
+                                                                    id,
+                                                                    path_to_string(p).as_slice(),
+                                                                    value.as_slice(),
+                                                                    ""),
                 def::DefVariant(_,id,_) => self.fmt.ref_str(ref_kind,
                                                             p.span,
                                                             sub_span,
diff --git a/src/librustc/middle/subst.rs b/src/librustc/middle/subst.rs
index c1c23df..5731bce 100644
--- a/src/librustc/middle/subst.rs
+++ b/src/librustc/middle/subst.rs
@@ -18,6 +18,7 @@ use util::ppaux::Repr;
 use std::fmt;
 use std::mem;
 use std::raw;
+use std::result;
 use std::slice::{Items, MutItems};
 use std::vec::Vec;
 use syntax::codemap::{Span, DUMMY_SP};
@@ -467,18 +468,38 @@ impl<T> VecPerParamSpace<T> {
          * can be run to a fixed point
          */
 
-        let mut fns: Vec<U> = self.get_slice(FnSpace).iter().rev().map(|p| pred(p)).collect();
+        let f = |t:&T| -> Result<U,()> { Ok(pred(t)) };
+
+        self.try_map_rev::<U,()>(f).unwrap()
+    }
+
+    pub fn try_map_rev<U,E>(&self, f: |&T| -> Result<U, E>) -> Result<VecPerParamSpace<U>, E> {
+        /*!
+         * If all of the calls to `f` are `Ok`, then behaves like
+         * `map_rev`, (executing the map but in reverse order).
+         * Otherwise, returns the first error encountered during the
+         * map execution.
+         */
+
+        let mut fns: Vec<U> = try!(result::collect(
+            self.get_slice(FnSpace).iter().rev().map(|p| f(p))));
 
         // NB: Calling foo.rev().map().rev() causes the calls to map
         // to occur in the wrong order. This was somewhat surprising
         // to me, though it makes total sense.
         fns.reverse();
 
-        let mut selfs: Vec<U> = self.get_slice(SelfSpace).iter().rev().map(|p| pred(p)).collect();
+        let mut selfs: Vec<U> = try!(result::collect(
+            self.get_slice(SelfSpace).iter().rev().map(|p| f(p))));
+
         selfs.reverse();
-        let mut tys: Vec<U> = self.get_slice(TypeSpace).iter().rev().map(|p| pred(p)).collect();
+
+        let mut tys: Vec<U> = try!(result::collect(
+            self.get_slice(TypeSpace).iter().rev().map(|p| f(p))));
+
         tys.reverse();
-        VecPerParamSpace::new(tys, selfs, fns)
+
+        Ok(VecPerParamSpace::new(tys, selfs, fns))
     }
 
     pub fn split(self) -> (Vec<T>, Vec<T>, Vec<T>) {
diff --git a/src/librustc/middle/trans/_match.rs b/src/librustc/middle/trans/_match.rs
index dd0668b..c3380a8 100644
--- a/src/librustc/middle/trans/_match.rs
+++ b/src/librustc/middle/trans/_match.rs
@@ -1225,7 +1225,7 @@ pub fn trans_match<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,
 fn is_discr_reassigned(bcx: Block, discr: &ast::Expr, body: &ast::Expr) -> bool {
     match discr.node {
         ast::ExprPath(..) => match bcx.def(discr.id) {
-            def::DefArg(vid, _) | def::DefBinding(vid, _) |
+            def::DefArg(vid, _) | def::DefBinding(vid, _, _) |
             def::DefLocal(vid, _) | def::DefUpvar(vid, _, _, _) => {
                 let mut rc = ReassignmentChecker {
                     node: vid,
@@ -1250,6 +1250,7 @@ struct ReassignmentChecker {
 
 impl euv::Delegate for ReassignmentChecker {
     fn consume(&mut self, _: ast::NodeId, _: Span, _: mc::cmt, _: euv::ConsumeMode) {}
+    fn matched_pat(&mut self, _: &ast::Pat, _: mc::cmt, _: euv::MatchMode) {}
     fn consume_pat(&mut self, _: &ast::Pat, _: mc::cmt, _: euv::ConsumeMode) {}
     fn borrow(&mut self, _: ast::NodeId, _: Span, _: mc::cmt, _: ty::Region,
               _: ty::BorrowKind, _: euv::LoanCause) {}
diff --git a/src/librustc/middle/trans/expr.rs b/src/librustc/middle/trans/expr.rs
index 0421aef..4d74ba3 100644
--- a/src/librustc/middle/trans/expr.rs
+++ b/src/librustc/middle/trans/expr.rs
@@ -1193,7 +1193,7 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,
         def::DefArg(nid, _) => {
             take_local(bcx, &*bcx.fcx.llargs.borrow(), nid)
         }
-        def::DefLocal(nid, _) | def::DefBinding(nid, _) => {
+        def::DefLocal(nid, _) | def::DefBinding(nid, _, _) => {
             take_local(bcx, &*bcx.fcx.lllocals.borrow(), nid)
         }
         _ => {
diff --git a/src/librustc/middle/ty.rs b/src/librustc/middle/ty.rs
index feed762..b2a9b32 100644
--- a/src/librustc/middle/ty.rs
+++ b/src/librustc/middle/ty.rs
@@ -491,6 +491,13 @@ pub struct ctxt<'tcx> {
     /// populated during the coherence phase of typechecking.
     pub destructor_for_type: RefCell<DefIdMap<ast::DefId>>,
 
+    /// A mapping from the def ID of an enum or struct type to the def
+    /// ID of its impl of QuietEarlyDrop, if present (flagging any
+    /// associated drop-glue as "pure"/"quiet"). This map is populated
+    /// during the coherence phase of typechecking.
+    pub quiet_dtor_for_type: RefCell<DefIdMap<ast::DefId>>,
+    pub quiet_dtor_for_ty_box: Cell<Option<ast::DefId>>,
+
     /// A method will be in this list if and only if it is a destructor.
     pub destructors: RefCell<DefIdSet>,
 
@@ -1423,6 +1430,8 @@ pub fn mk_ctxt<'tcx>(s: Session,
         superstructs: RefCell::new(DefIdMap::new()),
         struct_fields: RefCell::new(DefIdMap::new()),
         destructor_for_type: RefCell::new(DefIdMap::new()),
+        quiet_dtor_for_type: RefCell::new(DefIdMap::new()),
+        quiet_dtor_for_ty_box: Cell::new(None),
         destructors: RefCell::new(DefIdSet::new()),
         trait_impls: RefCell::new(DefIdMap::new()),
         inherent_impls: RefCell::new(DefIdMap::new()),
@@ -2154,6 +2163,7 @@ def_type_content_sets!(
         OwnsDtor                            = 0b0000_0000__0000_0010__0000,
         OwnsManaged /* see [1] below */     = 0b0000_0000__0000_0100__0000,
         OwnsAffine                          = 0b0000_0000__0000_1000__0000,
+        OwnsLoudDtor                        = 0b0000_0000__0001_0000__0000,
         OwnsAll                             = 0b0000_0000__1111_1111__0000,
 
         // Things that are reachable by the value in any way (fourth nibble):
@@ -2303,6 +2313,23 @@ impl TypeContents {
     pub fn has_dtor(&self) -> bool {
         self.intersects(TC::OwnsDtor)
     }
+
+    // A "loud" destructor is one that has effects that we think the user may care about,
+    // e.g. releasing locks, flushing buffers, etc.
+    // It is the default setting for implementations of Drop.
+    pub fn has_loud_dtor(&self) -> bool {
+        self.intersects(TC::OwnsDtor) &&
+            self.intersects(TC::OwnsLoudDtor)
+    }
+
+    // A "quiet" destructor is one that has no "significant" effects;
+    // e.g. a destructor that just frees memory it owns is considered
+    // quiet.  One opts into this by implementing the QuietEarlyDrop
+    // trait.
+    pub fn has_quiet_dtor(&self) -> bool {
+        self.intersects(TC::OwnsDtor) &&
+            !self.intersects(TC::OwnsLoudDtor)
+    }
 }
 
 impl ops::BitOr<TypeContents,TypeContents> for TypeContents {
@@ -2404,7 +2431,11 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {
             }
 
             ty_box(typ) => {
-                tc_ty(cx, typ, cache).managed_pointer() | TC::ReachesFfiUnsafe
+                let mut ret = tc_ty(cx, typ, cache).managed_pointer() | TC::ReachesFfiUnsafe;
+                if cx.quiet_dtor_for_ty_box.get().is_some() {
+                    ret = ret - TC::OwnsLoudDtor
+                }
+                ret
             }
 
             ty_uniq(typ) => {
@@ -2450,7 +2481,11 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {
                 }
 
                 if ty::has_dtor(cx, did) {
-                    res = res | TC::OwnsDtor;
+                    res = res | TC::OwnsDtor | TC::OwnsLoudDtor;
+                }
+                // Note that a type can impl QuietEarlyDrop even if it does not directly impl Drop
+                if ty::has_quiet_dtor(cx, did) {
+                    res = res - TC::OwnsLoudDtor;
                 }
                 apply_lang_items(cx, did, res)
             }
@@ -2480,7 +2515,11 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {
                     });
 
                 if ty::has_dtor(cx, did) {
-                    res = res | TC::OwnsDtor;
+                    res = res | TC::OwnsDtor | TC::OwnsLoudDtor;
+                }
+                // Note that a type can impl QuietEarlyDrop even if it does not directly impl Drop
+                if ty::has_quiet_dtor(cx, did) {
+                    res = res - TC::OwnsLoudDtor;
                 }
 
                 if variants.len() != 0 {
@@ -3096,6 +3135,62 @@ pub fn array_element_ty(t: t) -> Option<t> {
     }
 }
 
+/// Returns the type of element at index `i` in tuple or tuple-like type.
+/// requires variant_id be Some(_) iff t represents a ty_enum.
+pub fn positional_element_ty(cx: &ctxt, t: t, i: uint, variant_id: Option<ast::DefId>) -> Option<t> {
+
+    // FIXME probably need to pass in substs from the surrounding
+    // context, not the substs from the definition itself.
+
+    match (&get(t).sty, variant_id) {
+        (&ty_tup(ref v), None) => v.as_slice().get(i).map(|&t| t),
+
+
+        (&ty_struct(def_id, ref substs), None) => lookup_struct_fields(cx, def_id)
+            .as_slice().get(i)
+            .map(|&t|lookup_item_type(cx, t.id).ty.subst(cx, substs)),
+
+        (&ty_enum(def_id, ref substs), Some(variant_def_id)) => {
+            let variant_info = enum_variant_with_id(cx, def_id, variant_def_id);
+            variant_info.args.as_slice().get(i).map(|t|t.subst(cx, substs))
+        }
+
+        (&ty_enum(def_id, ref substs), None) => {
+            assert!(enum_is_univariant(cx, def_id));
+            let enum_variants = enum_variants(cx, def_id);
+            let variant_info = enum_variants.get(0);
+            variant_info.args.as_slice().get(i).map(|t|t.subst(cx, substs))
+        }
+
+        _ => None
+    }
+}
+
+/// Returns the type of element at field `n` in struct or struct-like type.
+/// requires variant_id is Some(_) iff t represents a ty_enum.
+pub fn named_element_ty(cx: &ctxt, t: t, n: ast::Name, variant_id: Option<ast::DefId>) -> Option<t> {
+
+    // FIXME probably need to pass in substs from the surrounding
+    // context, not the substs from the definition itself.
+
+    match (&get(t).sty, variant_id) {
+        (&ty_struct(def_id, ref substs), None) => {
+            let r = lookup_struct_fields(cx, def_id);
+            r.iter().find(|f| f.name == n)
+                .map(|&f| lookup_field_type(cx, def_id, f.id, substs))
+        }
+        (&ty_enum(def_id, ref substs), Some(variant_def_id)) => {
+            let variant_info = enum_variant_with_id(cx, def_id, variant_def_id);
+            variant_info.arg_names.as_ref()
+                .expect("must have struct enum variant if accessing a named fields")
+                .iter().zip(variant_info.args.iter())
+                .find(|&(ident, _)| ident.name == n)
+                .map(|(_ident, arg_t)| arg_t.subst(cx, substs))
+        }
+        _ => None
+    }
+}
+
 pub fn node_id_to_trait_ref(cx: &ctxt, id: ast::NodeId) -> Rc<ty::TraitRef> {
     match cx.trait_refs.borrow().find(&id) {
         Some(t) => t.clone(),
@@ -4253,6 +4348,11 @@ pub fn has_dtor(cx: &ctxt, struct_id: DefId) -> bool {
     ty_dtor(cx, struct_id).is_present()
 }
 
+/* Return true iff struct_id names a struct that implements QuietEarlyDrop. */
+fn has_quiet_dtor(cx: &ctxt, struct_id: DefId) -> bool {
+    cx.quiet_dtor_for_type.borrow().find(&struct_id).is_some()
+}
+
 pub fn with_path<T>(cx: &ctxt, id: ast::DefId, f: |ast_map::PathElems| -> T) -> T {
     if id.krate == ast::LOCAL_CRATE {
         cx.map.with_path(id.node, f)
diff --git a/src/librustc/middle/typeck/check/method.rs b/src/librustc/middle/typeck/check/method.rs
index 88d9a58..45be755 100644
--- a/src/librustc/middle/typeck/check/method.rs
+++ b/src/librustc/middle/typeck/check/method.rs
@@ -537,14 +537,14 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {
             return
         }
 
-        let vcx = self.fcx.vtable_context();
+        let infcx = self.fcx.infcx();
 
         // Get the tupled type of the arguments.
         let arguments_type = *closure_function_type.sig.inputs.get(0);
         let return_type = closure_function_type.sig.output;
 
         let closure_region =
-            vcx.infcx.next_region_var(infer::MiscVariable(self.span));
+            infcx.next_region_var(infer::MiscVariable(self.span));
         let unboxed_closure_type = ty::mk_unboxed_closure(self.tcx(),
                                                           closure_did,
                                                           closure_region);
@@ -554,7 +554,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {
             rcvr_substs: subst::Substs::new_trait(
                 vec![arguments_type, return_type],
                 vec![],
-                *vcx.infcx.next_ty_vars(1).get(0)),
+                *infcx.next_ty_vars(1).get(0)),
             method_ty: method,
             origin: MethodStaticUnboxedClosure(closure_did),
         });
@@ -816,11 +816,10 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {
         // determine the `self` of the impl with fresh
         // variables for each parameter:
         let span = self.self_expr.map_or(self.span, |e| e.span);
-        let vcx = self.fcx.vtable_context();
         let TypeAndSubsts {
             substs: impl_substs,
             ty: impl_ty
-        } = impl_self_ty(&vcx, span, impl_did);
+        } = impl_self_ty(self.tcx(), self.infcx(), span, impl_did);
 
         let candidates = if is_extension {
             &mut self.extension_candidates
diff --git a/src/librustc/middle/typeck/check/mod.rs b/src/librustc/middle/typeck/check/mod.rs
index 01b5fd6..599b460 100644
--- a/src/librustc/middle/typeck/check/mod.rs
+++ b/src/librustc/middle/typeck/check/mod.rs
@@ -103,6 +103,7 @@ use middle::typeck::check::method::{DontAutoderefReceiver};
 use middle::typeck::check::method::{IgnoreStaticMethods, ReportStaticMethods};
 use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;
 use middle::typeck::check::vtable::VtableContext;
+use middle::typeck::check;
 use middle::typeck::CrateCtxt;
 use middle::typeck::infer::{resolve_type, force_tvar};
 use middle::typeck::infer;
@@ -1580,13 +1581,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {
         self.ccx.tcx.sess.err_count() - self.err_count_on_creation
     }
 
-    pub fn vtable_context<'a>(&'a self) -> VtableContext<'a, 'tcx> {
+    pub fn vtable_context<'a>(&'a self, is_early: check::vtable::IsEarly) -> VtableContext<'a, 'tcx> {
         VtableContext {
             infcx: self.infcx(),
-            param_env: &self.inh.param_env,
+            param_bounds: &self.inh.param_env.bounds,
             unboxed_closures: &self.inh.unboxed_closures,
+            if_missing_ty_param: check::vtable::IfMissingTyParamSearch,
+            is_early: is_early,
         }
     }
+
+    pub fn vtable_context_is_early<'a>(&'a self, is_early: bool) -> VtableContext<'a, 'tcx> {
+        self.vtable_context(
+            if is_early { check::vtable::IsEarly } else { check::vtable::NotEarly })
+    }
 }
 
 impl<'a, 'tcx> RegionScope for infer::InferCtxt<'a, 'tcx> {
@@ -2571,20 +2579,18 @@ fn check_expr_with_lvalue_pref(fcx: &FnCtxt, expr: &ast::Expr,
 // declared on the impl declaration e.g., `impl<A,B> for ~[(A,B)]`
 // would return ($0, $1) where $0 and $1 are freshly instantiated type
 // variables.
-pub fn impl_self_ty(vcx: &VtableContext,
+pub fn impl_self_ty(tcx: &ty::ctxt,
+                    infcx: &infer::InferCtxt,
                     span: Span, // (potential) receiver for this impl
-                    did: ast::DefId)
-                    -> TypeAndSubsts {
-    let tcx = vcx.tcx();
-
+                    did: ast::DefId) -> TypeAndSubsts {
     let ity = ty::lookup_item_type(tcx, did);
     let (n_tps, rps, raw_ty) =
         (ity.generics.types.len(subst::TypeSpace),
          ity.generics.regions.get_slice(subst::TypeSpace),
          ity.ty);
 
-    let rps = vcx.infcx.region_vars_for_defs(span, rps);
-    let tps = vcx.infcx.next_ty_vars(n_tps);
+    let rps = infcx.region_vars_for_defs(span, rps);
+    let tps = infcx.next_ty_vars(n_tps);
     let substs = subst::Substs::new_type(tps, rps);
     let substd_ty = raw_ty.subst(tcx, &substs);
 
@@ -4715,7 +4721,7 @@ pub fn polytype_for_def(fcx: &FnCtxt,
                         -> Polytype {
     match defn {
       def::DefArg(nid, _) | def::DefLocal(nid, _) |
-      def::DefBinding(nid, _) => {
+      def::DefBinding(nid, _, _) => {
           let typ = fcx.local_ty(sp, nid);
           return no_params(typ);
       }
diff --git a/src/librustc/middle/typeck/check/regionck.rs b/src/librustc/middle/typeck/check/regionck.rs
index eb630d0..ca5f113 100644
--- a/src/librustc/middle/typeck/check/regionck.rs
+++ b/src/librustc/middle/typeck/check/regionck.rs
@@ -234,7 +234,7 @@ fn region_of_def(fcx: &FnCtxt, def: def::Def) -> ty::Region {
     let tcx = fcx.tcx();
     match def {
         DefLocal(node_id, _) | DefArg(node_id, _) |
-        DefBinding(node_id, _) => {
+        DefBinding(node_id, _, _) => {
             tcx.region_maps.var_region(node_id)
         }
         DefUpvar(_, subdef, closure_id, body_id) => {
@@ -1446,7 +1446,7 @@ fn link_region(rcx: &Rcx,
             }
 
             mc::cat_discr(cmt_base, _) |
-            mc::cat_downcast(cmt_base) |
+            mc::cat_downcast(cmt_base, _) |
             mc::cat_deref(cmt_base, _, mc::GcPtr(..)) |
             mc::cat_deref(cmt_base, _, mc::OwnedPtr) |
             mc::cat_interior(cmt_base, _) => {
@@ -1648,7 +1648,7 @@ fn adjust_upvar_borrow_kind_for_mut(rcx: &Rcx,
         match cmt.cat.clone() {
             mc::cat_deref(base, _, mc::OwnedPtr) |
             mc::cat_interior(base, _) |
-            mc::cat_downcast(base) |
+            mc::cat_downcast(base, _) |
             mc::cat_discr(base, _) => {
                 // Interior or owned data is mutable if base is
                 // mutable, so iterate to the base.
@@ -1703,7 +1703,7 @@ fn adjust_upvar_borrow_kind_for_unique(rcx: &Rcx, cmt: mc::cmt) {
         match cmt.cat.clone() {
             mc::cat_deref(base, _, mc::OwnedPtr) |
             mc::cat_interior(base, _) |
-            mc::cat_downcast(base) |
+            mc::cat_downcast(base, _) |
             mc::cat_discr(base, _) => {
                 // Interior or owned data is unique if base is
                 // unique.
diff --git a/src/librustc/middle/typeck/check/vtable.rs b/src/librustc/middle/typeck/check/vtable.rs
index 16136fc..dbaf4ca 100644
--- a/src/librustc/middle/typeck/check/vtable.rs
+++ b/src/librustc/middle/typeck/check/vtable.rs
@@ -70,20 +70,45 @@ use syntax::visit::Visitor;
 /// and a list of unboxed closure types.
 pub struct VtableContext<'a, 'tcx: 'a> {
     pub infcx: &'a infer::InferCtxt<'a, 'tcx>,
-    pub param_env: &'a ty::ParameterEnvironment,
+    pub param_bounds: &'a VecPerParamSpace<ty::ParamBounds>,
     pub unboxed_closures: &'a RefCell<DefIdMap<ty::UnboxedClosure>>,
+    pub is_early: IsEarly,
+    pub if_missing_ty_param: IfMissingTyParam,
+}
+
+#[deriving(PartialEq, Show)]
+pub enum IsEarly {
+    IsEarly,
+    NotEarly,
+}
+
+#[deriving(Show)]
+pub enum IfMissingTyParam {
+    IfMissingTyParamSearch,
+    IfMissingTyParamGiveUp,
 }
 
 impl<'a, 'tcx> VtableContext<'a, 'tcx> {
     pub fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.infcx.tcx }
+
+    pub fn is_early(&self) -> bool { self.is_early == IsEarly }
+
+    fn ok_or_die<A>(&self, r: VtResult<A>) -> A {
+        match r {
+            Ok(r) => r,
+            Err((span, msg)) => self.tcx().sess.span_fatal(span, msg.as_slice()),
+        }
+    }
 }
 
+pub type ErrMsg = (Span, String);
+pub type VtResult<A> = Result<A, ErrMsg>;
+
 fn lookup_vtables(vcx: &VtableContext,
                   span: Span,
                   type_param_defs: &VecPerParamSpace<ty::TypeParameterDef>,
-                  substs: &subst::Substs,
-                  is_early: bool)
-                  -> VecPerParamSpace<vtable_param_res> {
+                  substs: &subst::Substs)
+                  -> VtResult<VecPerParamSpace<vtable_param_res>> {
     debug!("lookup_vtables(\
            type_param_defs={}, \
            substs={}",
@@ -91,40 +116,53 @@ fn lookup_vtables(vcx: &VtableContext,
            substs.repr(vcx.tcx()));
 
     // We do this backwards for reasons discussed above.
-    let result = type_param_defs.map_rev(|def| {
+    let result = type_param_defs.try_map_rev(|def| {
         let ty = *substs.types.get(def.space, def.index);
         lookup_vtables_for_param(vcx, span, Some(substs),
-                                 &def.bounds, ty, is_early)
+                                 &def.bounds, ty)
     });
 
-    debug!("lookup_vtables result(\
-            type_param_defs={}, \
-            substs={}, \
-            result={})",
-           type_param_defs.repr(vcx.tcx()),
-           substs.repr(vcx.tcx()),
-           result.repr(vcx.tcx()));
+    match result {
+        Ok(ref result) => {
+            debug!("lookup_vtables result(\
+                   type_param_defs={}, \
+                   substs={}, \
+                   result={})",
+                   type_param_defs.repr(vcx.tcx()),
+                   substs.repr(vcx.tcx()),
+                   result.repr(vcx.tcx()));
+        }
+        Err(ref payload) => {
+            debug!("lookup_vtables result err(\
+                   type_param_defs={}, \
+                   substs={}, \
+                   result={})",
+                   type_param_defs.repr(vcx.tcx()),
+                   substs.repr(vcx.tcx()),
+                   payload.ref1());
+        }
+    }
 
     result
 }
 
 fn lookup_vtables_for_param(vcx: &VtableContext,
-                            span: Span,
-                            // None for substs means the identity
-                            substs: Option<&subst::Substs>,
-                            type_param_bounds: &ty::ParamBounds,
-                            ty: ty::t,
-                            is_early: bool)
-                            -> vtable_param_res {
+                                span: Span,
+                                // None for substs means the identity
+                                substs: Option<&subst::Substs>,
+                                type_param_bounds: &ty::ParamBounds,
+                                ty: ty::t)
+                                -> VtResult<vtable_param_res> {
     let tcx = vcx.tcx();
 
     debug!("lookup_vtables_for_param(ty={}, type_param_bounds={}, is_early={})",
            ty.repr(vcx.tcx()),
            type_param_bounds.repr(vcx.tcx()),
-           is_early);
+           vcx.is_early());
 
     // ty is the value supplied for the type parameter A...
     let mut param_result = Vec::new();
+    let mut first_error = None;
 
     ty::each_bound_trait_and_supertraits(tcx,
                                          type_param_bounds.trait_bounds
@@ -150,35 +188,47 @@ fn lookup_vtables_for_param(vcx: &VtableContext,
 
         debug!("after subst: {}", trait_ref.repr(tcx));
 
-        match lookup_vtable(vcx, span, ty, trait_ref.clone(), is_early) {
-            Some(vtable) => param_result.push(vtable),
-            None => {
-                vcx.tcx().sess.span_err(span,
+        match lookup_vtable(vcx, span, ty, trait_ref.clone()) {
+            Ok(Some(vtable)) => {
+                param_result.push(vtable);
+            }
+            Ok(None) => {
+                let msg =
                     format!("failed to find an implementation of \
-                          trait {} for {}",
-                         vcx.infcx.trait_ref_to_string(&*trait_ref),
-                         vcx.infcx.ty_to_string(ty)).as_slice());
-                param_result.push(vtable_error)
+                            trait {} for {}",
+                            vcx.infcx.trait_ref_to_string(&*trait_ref),
+                            vcx.infcx.ty_to_string(ty).as_slice());
+                param_result.push(vtable_error);
+                first_error = Some((span, msg));
+            }
+            Err(msg) => {
+                first_error = Some(msg);
             }
         }
-        true
+        first_error.is_none()
     });
 
-    debug!("lookup_vtables_for_param result(\
-            type_param_bounds={}, \
-            ty={}, \
-            result={})",
-           type_param_bounds.repr(vcx.tcx()),
-           ty.repr(vcx.tcx()),
-           param_result.repr(vcx.tcx()));
-
-    param_result
+    match first_error {
+        Some(error_payload) => Err(error_payload),
+        None => {
+            debug!("lookup_vtables_for_param result(\
+                   type_param_bounds={}, \
+                   ty={}, \
+                   result={})",
+                   type_param_bounds.repr(vcx.tcx()),
+                   ty.repr(vcx.tcx()),
+                   param_result.repr(vcx.tcx()));
+            Ok(param_result)
+        }
+    }
 }
 
-fn relate_trait_refs(vcx: &VtableContext,
-                     span: Span,
-                     act_trait_ref: Rc<ty::TraitRef>,
-                     exp_trait_ref: Rc<ty::TraitRef>) {
+// FIXME: this does not belong in this module anymore.
+pub fn relate_trait_refs(tcx: &ty::ctxt,
+                         infcx: &infer::InferCtxt,
+                         span: Span,
+                         act_trait_ref: Rc<ty::TraitRef>,
+                         exp_trait_ref: Rc<ty::TraitRef>) {
     /*!
      *
      * Checks that an implementation of `act_trait_ref` is suitable
@@ -186,7 +236,7 @@ fn relate_trait_refs(vcx: &VtableContext,
      * error otherwise.
      */
 
-    match infer::mk_sub_trait_refs(vcx.infcx,
+    match infer::mk_sub_trait_refs(infcx,
                                    false,
                                    infer::RelateTraitRefs(span),
                                    act_trait_ref.clone(),
@@ -197,15 +247,15 @@ fn relate_trait_refs(vcx: &VtableContext,
             // the message good.
             // Resolve any type vars in the trait refs
             let r_act_trait_ref =
-                vcx.infcx.resolve_type_vars_in_trait_ref_if_possible(&*act_trait_ref);
+                infcx.resolve_type_vars_in_trait_ref_if_possible(&*act_trait_ref);
             let r_exp_trait_ref =
-                vcx.infcx.resolve_type_vars_in_trait_ref_if_possible(&*exp_trait_ref);
+                infcx.resolve_type_vars_in_trait_ref_if_possible(&*exp_trait_ref);
             // Only print the message if there aren't any previous type errors
             // inside the types.
             if !ty::trait_ref_contains_error(&r_act_trait_ref) &&
                 !ty::trait_ref_contains_error(&r_exp_trait_ref)
             {
-                let tcx = vcx.tcx();
+                let tcx = infcx.tcx;
                 span_err!(tcx.sess, span, E0095, "expected {}, found {} ({})",
                           ppaux::trait_ref_to_string(tcx, &r_exp_trait_ref),
                           ppaux::trait_ref_to_string(tcx, &r_act_trait_ref),
@@ -216,79 +266,97 @@ fn relate_trait_refs(vcx: &VtableContext,
 }
 
 // Look up the vtable implementing the trait `trait_ref` at type `t`
-fn lookup_vtable(vcx: &VtableContext,
-                 span: Span,
-                 ty: ty::t,
-                 trait_ref: Rc<ty::TraitRef>,
-                 is_early: bool)
-                 -> Option<vtable_origin>
+pub fn lookup_vtable(vcx: &VtableContext,
+                     span: Span,
+                     ty: ty::t,
+                     trait_ref: Rc<ty::TraitRef>)
+                 -> VtResult<Option<vtable_origin>>
 {
-    debug!("lookup_vtable(ty={}, trait_ref={})",
+    debug!("lookup_vtable(vcx{} param_bounds={} {}, ty={}, trait_ref={})",
+           "{", vcx.param_bounds.repr(vcx.tcx()), "}",
            ty.repr(vcx.tcx()),
            trait_ref.repr(vcx.tcx()));
     let _i = indenter();
 
-    let ty = match fixup_ty(vcx, span, ty, is_early) {
-        Some(ty) => ty,
+    let ty = match fixup_ty(vcx.tcx(), vcx.infcx, span, ty, vcx.is_early()) {
+        Some(ty) => {
+            ty
+        }
         None => {
             // fixup_ty can only fail if this is early resolution
-            assert!(is_early);
+            assert!(vcx.is_early());
             // The type has unconstrained type variables in it, so we can't
             // do early resolution on it. Return some completely bogus vtable
             // information: we aren't storing it anyways.
-            return Some(vtable_error);
+            debug!("lookup_vtable vtable_error");
+            return Ok(Some(vtable_error));
         }
     };
 
     if ty::type_is_error(ty) {
-        return Some(vtable_error);
+        debug!("lookup_vtable type_is_error(ty={})", ty.repr(vcx.tcx()));
+        return Ok(Some(vtable_error));
     }
 
     // If the type is self or a param, we look at the trait/supertrait
     // bounds to see if they include the trait we are looking for.
-    let vtable_opt = match ty::get(ty).sty {
+    match ty::get(ty).sty {
         ty::ty_param(ParamTy {space, idx: n, ..}) => {
-            let env_bounds = &vcx.param_env.bounds;
+            let env_bounds = &vcx.param_bounds;
             let type_param_bounds = &env_bounds.get(space, n).trait_bounds;
-            lookup_vtable_from_bounds(vcx,
-                                      span,
-                                      type_param_bounds.as_slice(),
-                                      param_index {
-                                          space: space,
-                                          index: n,
-                                      },
-                                      trait_ref.clone())
+            let param_index = param_index { space: space, index: n };
+            debug!("lookup_vtable type_param_bounds: {} \
+                    param_index: {:?} trait_ref: {}",
+                   type_param_bounds.repr(vcx.tcx()),
+                   param_index,
+                   trait_ref.repr(vcx.tcx()));
+            let ret = lookup_vtable_from_bounds(vcx.tcx(),
+                                                vcx.infcx,
+                                                span,
+                                                type_param_bounds.as_slice(),
+                                                param_index,
+                                                trait_ref.clone());
+            if ret.is_some() {
+                return Ok(ret);
+            }
+
+            match vcx.if_missing_ty_param {
+                IfMissingTyParamGiveUp => {
+                    let msg = format!("No vtable found for ty param {}", ty.repr(vcx.tcx()));
+                    return Err((span, msg));
+                }
+                IfMissingTyParamSearch => {
+                    // fall through to search below
+                }
+            }
         }
 
         // Default case just falls through
-        _ => None
+        _ => {}
     };
 
-    if vtable_opt.is_some() { return vtable_opt; }
-
     // If we aren't a self type or param, or it was, but we didn't find it,
     // do a search.
-    search_for_vtable(vcx, span, ty, trait_ref, is_early)
+    search_for_vtable(vcx, span, ty, trait_ref)
 }
 
 // Given a list of bounds on a type, search those bounds to see if any
 // of them are the vtable we are looking for.
-fn lookup_vtable_from_bounds(vcx: &VtableContext,
-                             span: Span,
-                             bounds: &[Rc<ty::TraitRef>],
-                             param: param_index,
-                             trait_ref: Rc<ty::TraitRef>)
-                             -> Option<vtable_origin> {
-    let tcx = vcx.tcx();
-
+pub fn lookup_vtable_from_bounds(tcx: &ty::ctxt,
+                                 infcx: &infer::InferCtxt,
+                                 span: Span,
+                                 bounds: &[Rc<ty::TraitRef>],
+                                 param: param_index,
+                                 trait_ref: Rc<ty::TraitRef>)
+                                 -> Option<vtable_origin> {
     let mut n_bound = 0;
     let mut ret = None;
     ty::each_bound_trait_and_supertraits(tcx, bounds, |bound_trait_ref| {
         debug!("checking bounds trait {}",
-               bound_trait_ref.repr(vcx.tcx()));
+               bound_trait_ref.repr(tcx));
 
         if bound_trait_ref.def_id == trait_ref.def_id {
-            relate_trait_refs(vcx, span, bound_trait_ref, trait_ref.clone());
+            relate_trait_refs(tcx, infcx, span, bound_trait_ref, trait_ref.clone());
             let vtable = vtable_param(param, n_bound);
             debug!("found param vtable: {:?}",
                    vtable);
@@ -302,7 +370,7 @@ fn lookup_vtable_from_bounds(vcx: &VtableContext,
     ret
 }
 
-fn search_for_unboxed_closure_vtable(vcx: &VtableContext,
+pub fn search_for_unboxed_closure_vtable(vcx: &VtableContext,
                                      span: Span,
                                      ty: ty::t,
                                      trait_ref: Rc<ty::TraitRef>)
@@ -375,7 +443,7 @@ fn search_for_unboxed_closure_vtable(vcx: &VtableContext,
                 ty)
         });
 
-        relate_trait_refs(vcx, span, corresponding_trait_ref, trait_ref);
+        relate_trait_refs(vcx.tcx(), vcx.infcx, span, corresponding_trait_ref, trait_ref);
         return Some(vtable_unboxed_closure(closure_def_id))
     }
 
@@ -385,9 +453,8 @@ fn search_for_unboxed_closure_vtable(vcx: &VtableContext,
 fn search_for_vtable(vcx: &VtableContext,
                      span: Span,
                      ty: ty::t,
-                     trait_ref: Rc<ty::TraitRef>,
-                     is_early: bool)
-                     -> Option<vtable_origin> {
+                     trait_ref: Rc<ty::TraitRef>)
+                     -> VtResult<Option<vtable_origin>> {
     let tcx = vcx.tcx();
 
     // First, check to see whether this is a call to the `call` method of an
@@ -396,7 +463,7 @@ fn search_for_vtable(vcx: &VtableContext,
                                             span,
                                             ty,
                                             trait_ref.clone()) {
-        Some(vtable_origin) => return Some(vtable_origin),
+        Some(vtable_origin) => return Ok(Some(vtable_origin)),
         None => {}
     }
 
@@ -412,7 +479,7 @@ fn search_for_vtable(vcx: &VtableContext,
     let impls = match tcx.trait_impls.borrow().find_copy(&trait_ref.def_id) {
         Some(impls) => impls,
         None => {
-            return None;
+            return Ok(None);
         }
     };
     // impls is the list of all impls in scope for trait_ref.
@@ -451,7 +518,7 @@ fn search_for_vtable(vcx: &VtableContext,
         let TypeAndSubsts {
             substs: substs,
             ty: for_ty
-        } = impl_self_ty(vcx, span, impl_did);
+        } = impl_self_ty(vcx.tcx(), vcx.infcx, span, impl_did);
         match infer::mk_eqty(vcx.infcx,
                              false,
                              infer::RelateSelfType(span),
@@ -484,7 +551,7 @@ fn search_for_vtable(vcx: &VtableContext,
                vcx.infcx.trait_ref_to_string(&*trait_ref),
                vcx.infcx.trait_ref_to_string(&*of_trait_ref));
 
-        relate_trait_refs(vcx, span, of_trait_ref, trait_ref.clone());
+        relate_trait_refs(vcx.tcx(), vcx.infcx, span, of_trait_ref, trait_ref.clone());
 
 
         // Recall that trait_ref -- the trait type we're casting to --
@@ -499,23 +566,24 @@ fn search_for_vtable(vcx: &VtableContext,
         // later in the kind checking pass.
         let im_generics =
             ty::lookup_item_type(tcx, impl_did).generics;
-        let subres = lookup_vtables(vcx,
-                                    span,
-                                    &im_generics.types,
-                                    &substs,
-                                    is_early);
+        let subres = try!(lookup_vtables(vcx,
+                                         span,
+                                         &im_generics.types,
+                                         &substs));
 
         // substs might contain type variables, so we call
         // fixup_substs to resolve them.
-        let substs_f = match fixup_substs(vcx, span,
+        let substs_f = match fixup_substs(vcx.tcx(),
+                                          vcx.infcx,
+                                          span,
                                           trait_ref.def_id,
                                           substs,
-                                          is_early) {
+                                          vcx.is_early()) {
             Some(ref substs) => (*substs).clone(),
             None => {
-                assert!(is_early);
+                assert!(vcx.is_early());
                 // Bail out with a bogus answer
-                return Some(vtable_error);
+                return Ok(Some(vtable_error));
             }
         };
 
@@ -532,7 +600,7 @@ fn search_for_vtable(vcx: &VtableContext,
         // I am a little confused about this, since it seems to be
         // very similar to the relate_trait_refs we already do,
         // but problems crop up if it is removed, so... -sully
-        connect_trait_tps(vcx, span, &substs_f, trait_ref.clone(), impl_did);
+        connect_trait_tps(vcx.tcx(), vcx.infcx, span, &substs_f, trait_ref.clone(), impl_did);
 
         // Finally, we register that we found a matching impl, and
         // record the def ID of the impl as well as the resolved list
@@ -541,31 +609,31 @@ fn search_for_vtable(vcx: &VtableContext,
     }
 
     match found.len() {
-        0 => { return None }
-        1 => return Some(found.get(0).clone()),
+        0 => { return Ok(None) }
+        1 => return Ok(Some(found.get(0).clone())),
         _ => {
-            if !is_early {
+            if !vcx.is_early() {
                 span_err!(vcx.tcx().sess, span, E0096,
                           "multiple applicable methods in scope");
             }
-            return Some(found.get(0).clone());
+            return Ok(Some(found.get(0).clone()));
         }
     }
 }
 
-
-fn fixup_substs(vcx: &VtableContext,
-                span: Span,
-                id: ast::DefId,
-                substs: subst::Substs,
-                is_early: bool)
-                -> Option<subst::Substs> {
-    let tcx = vcx.tcx();
+// FIXME: may not belong here anymore
+pub fn fixup_substs(tcx: &ty::ctxt,
+                    infcx: &infer::InferCtxt,
+                    span: Span,
+                    id: ast::DefId,
+                    substs: subst::Substs,
+                    is_early: bool)
+                    -> Option<subst::Substs> {
     // use a dummy type just to package up the substs that need fixing up
     let t = ty::mk_trait(tcx,
                          id, substs,
                          ty::region_existential_bound(ty::ReStatic));
-    fixup_ty(vcx, span, t, is_early).map(|t_f| {
+    fixup_ty(tcx, infcx, span, t, is_early).map(|t_f| {
         match ty::get(t_f).sty {
           ty::ty_trait(ref inner) => inner.substs.clone(),
           _ => fail!("t_f should be a trait")
@@ -573,13 +641,13 @@ fn fixup_substs(vcx: &VtableContext,
     })
 }
 
-fn fixup_ty(vcx: &VtableContext,
-            span: Span,
-            ty: ty::t,
-            is_early: bool)
-            -> Option<ty::t> {
-    let tcx = vcx.tcx();
-    match resolve_type(vcx.infcx, Some(span), ty, resolve_and_force_all_but_regions) {
+pub fn fixup_ty(tcx: &ty::ctxt,
+                infcx: &infer::InferCtxt,
+                span: Span,
+                ty: ty::t,
+                is_early: bool)
+                -> Option<ty::t> {
+    match resolve_type(infcx, Some(span), ty, resolve_and_force_all_but_regions) {
         Ok(new_type) => Some(new_type),
         Err(e) if !is_early => {
             tcx.sess.span_err(span,
@@ -594,24 +662,23 @@ fn fixup_ty(vcx: &VtableContext,
     }
 }
 
-fn connect_trait_tps(vcx: &VtableContext,
+pub fn connect_trait_tps(tcx: &ty::ctxt,
+                     infcx: &infer::InferCtxt,
                      span: Span,
                      impl_substs: &subst::Substs,
                      trait_ref: Rc<ty::TraitRef>,
                      impl_did: ast::DefId) {
-    let tcx = vcx.tcx();
-
     let impl_trait_ref = match ty::impl_trait_ref(tcx, impl_did) {
         Some(t) => t,
-        None => vcx.tcx().sess.span_bug(span,
+        None => tcx.sess.span_bug(span,
                                   "connect_trait_tps invoked on a type impl")
     };
 
     let impl_trait_ref = impl_trait_ref.subst(tcx, impl_substs);
-    relate_trait_refs(vcx, span, impl_trait_ref, trait_ref);
+    relate_trait_refs(tcx, infcx, span, impl_trait_ref, trait_ref);
 }
 
-fn insert_vtables(fcx: &FnCtxt, vtable_key: MethodCall, vtables: vtable_res) {
+pub fn insert_vtables(fcx: &FnCtxt, vtable_key: MethodCall, vtables: vtable_res) {
     debug!("insert_vtables(vtable_key={}, vtables={})",
            vtable_key, vtables.repr(fcx.tcx()));
     fcx.inh.vtable_map.borrow_mut().insert(vtable_key, vtables);
@@ -698,7 +765,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {
           ty::ty_trait(box ty::TyTrait {
               def_id: target_def_id, substs: ref target_substs, ..
           }) => {
-              let vcx = fcx.vtable_context();
+              let vcx = fcx.vtable_context_is_early(is_early);
 
               // Take the type parameters from the object
               // type, but set the Self type (which is
@@ -727,12 +794,11 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {
                                              ex.span,
                                              None,
                                              &param_bounds,
-                                             src_ty,
-                                             is_early);
+                                             src_ty);
 
               if !is_early {
-                  let mut r = VecPerParamSpace::empty();
-                  r.push(subst::SelfSpace, vtables);
+                  let mut r : vtable_res = VecPerParamSpace::empty();
+                  r.push(subst::SelfSpace, vtables.unwrap());
                   insert_vtables(fcx, key, r);
               }
           }
@@ -751,11 +817,12 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {
                    fcx.infcx().ty_to_string(item_ty.ty));
             debug!("early_resolve_expr: looking up vtables for type params {}",
                    item_ty.generics.types.repr(fcx.tcx()));
-            let vcx = fcx.vtable_context();
-            let vtbls = lookup_vtables(&vcx, ex.span,
-                                       &item_ty.generics.types,
-                                       &item_substs.substs, is_early);
-            if !is_early {
+            let vcx = fcx.vtable_context_is_early(is_early);
+            let vtbls = vcx.ok_or_die(
+                lookup_vtables(&vcx, ex.span,
+                               &item_ty.generics.types,
+                               &item_substs.substs));
+            if !vcx.is_early() {
                 insert_vtables(fcx, MethodCall::expr(ex.id), vtbls);
             }
         });
@@ -776,11 +843,12 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {
               let type_param_defs =
                   ty::method_call_type_param_defs(fcx, method.origin);
               let substs = fcx.method_ty_substs(ex.id);
-              let vcx = fcx.vtable_context();
-              let vtbls = lookup_vtables(&vcx, ex.span,
-                                         &type_param_defs,
-                                         &substs, is_early);
-              if !is_early {
+              let vcx = fcx.vtable_context_is_early(is_early);
+              let vtbls = vcx.ok_or_die(
+                  lookup_vtables(&vcx, ex.span,
+                                 &type_param_defs,
+                                 &substs));
+              if !vcx.is_early() {
                   insert_vtables(fcx, MethodCall::expr(ex.id), vtbls);
               }
           }
@@ -835,11 +903,12 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {
                                        ex.repr(fcx.tcx()));
                                 let type_param_defs =
                                     ty::method_call_type_param_defs(cx.tcx, method.origin);
-                                let vcx = fcx.vtable_context();
-                                let vtbls = lookup_vtables(&vcx, ex.span,
-                                                           &type_param_defs,
-                                                           &method.substs, is_early);
-                                if !is_early {
+                                let vcx = fcx.vtable_context_is_early(is_early);
+                                let vtbls = vcx.ok_or_die(
+                                    lookup_vtables(&vcx, ex.span,
+                                                   &type_param_defs,
+                                                   &method.substs));
+                                if !vcx.is_early() {
                                     insert_vtables(fcx, method_call, vtbls);
                                 }
                             }
@@ -961,8 +1030,10 @@ pub fn resolve_impl(tcx: &ty::ctxt,
     let unboxed_closures = RefCell::new(DefIdMap::new());
     let vcx = VtableContext {
         infcx: infcx,
-        param_env: &param_env,
+        param_bounds: &param_env.bounds,
         unboxed_closures: &unboxed_closures,
+        if_missing_ty_param: IfMissingTyParamSearch,
+        is_early: NotEarly,
     };
 
     // Resolve the vtables for the trait reference on the impl.  This
@@ -988,11 +1059,11 @@ pub fn resolve_impl(tcx: &ty::ctxt,
     //     fn default_x<T:B, Self:A>(...) { .. .})
 
     let trait_def = ty::lookup_trait_def(tcx, impl_trait_ref.def_id);
-    let vtbls = lookup_vtables(&vcx,
-                                   impl_item.span,
-                                   &trait_def.generics.types,
-                                   &impl_trait_ref.substs,
-                                   false);
+    let vtbls = vcx.ok_or_die(
+        lookup_vtables(&vcx,
+                       impl_item.span,
+                       &trait_def.generics.types,
+                       &impl_trait_ref.substs));
 
     infcx.resolve_regions_and_report_errors();
 
@@ -1012,17 +1083,19 @@ pub fn trans_resolve_method(tcx: &ty::ctxt, id: ast::NodeId,
                             substs: &subst::Substs) -> vtable_res {
     let generics = ty::lookup_item_type(tcx, ast_util::local_def(id)).generics;
     let unboxed_closures = RefCell::new(DefIdMap::new());
+    let param_env = ty::construct_parameter_environment(tcx, &ty::Generics::empty(), id);
     let vcx = VtableContext {
         infcx: &infer::new_infer_ctxt(tcx),
-        param_env: &ty::construct_parameter_environment(tcx, &ty::Generics::empty(), id),
+        param_bounds: &param_env.bounds,
         unboxed_closures: &unboxed_closures,
+        if_missing_ty_param: IfMissingTyParamSearch,
+        is_early: NotEarly,
     };
 
-    lookup_vtables(&vcx,
-                   tcx.map.span(id),
-                   &generics.types,
-                   substs,
-                   false)
+    vcx.ok_or_die(lookup_vtables(&vcx,
+                                 tcx.map.span(id),
+                                 &generics.types,
+                                 substs))
 }
 
 impl<'a, 'b, 'tcx> visit::Visitor<()> for &'a FnCtxt<'b, 'tcx> {
@@ -1053,11 +1126,13 @@ pub fn check_param_bounds(tcx: &ty::ctxt,
     let unboxed_closures = RefCell::new(DefIdMap::new());
     let vcx = VtableContext {
         infcx: &infer::new_infer_ctxt(tcx),
-        param_env: parameter_environment,
+        param_bounds: &parameter_environment.bounds,
         unboxed_closures: &unboxed_closures,
+        is_early: NotEarly,
+        if_missing_ty_param: IfMissingTyParamSearch,
     };
     let vtable_param_results =
-        lookup_vtables(&vcx, span, type_param_defs, substs, false);
+        lookup_vtables(&vcx, span, type_param_defs, substs);
     for (vtable_param_result, type_param_def) in
             vtable_param_results.iter().zip(type_param_defs.iter()) {
         for (vtable_result, trait_ref) in
@@ -1065,7 +1140,7 @@ pub fn check_param_bounds(tcx: &ty::ctxt,
                                    .zip(type_param_def.bounds
                                                       .trait_bounds
                                                       .iter()) {
-            match *vtable_result {
+            match vtable_result.unwrap() {
                 vtable_error => any_missing(&**trait_ref),
                 vtable_static(..) |
                 vtable_param(..) |
diff --git a/src/librustc/middle/typeck/coherence.rs b/src/librustc/middle/typeck/coherence.rs
index 2c6dc94..101c68d 100644
--- a/src/librustc/middle/typeck/coherence.rs
+++ b/src/librustc/middle/typeck/coherence.rs
@@ -690,8 +690,12 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {
     //
     // Destructors
     //
-
     fn populate_destructor_table(&self) {
+        self.populate_destructor_table_for_drop();
+        self.populate_destructor_table_for_quiet_early_drop();
+    }
+
+    fn populate_destructor_table_for_drop(&self) {
         let tcx = self.crate_context.tcx;
         let drop_trait = match tcx.lang_items.drop_trait() {
             Some(id) => id, None => { return }
@@ -746,6 +750,53 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {
             }
         }
     }
+
+    fn populate_destructor_table_for_quiet_early_drop(&self) {
+        let tcx = self.crate_context.tcx;
+        let quiet_early_drop_trait = match tcx.lang_items.quiet_early_drop() {
+            Some(id) => id, None => { return }
+        };
+
+        let trait_impls = match tcx.trait_impls.borrow().find_copy(&quiet_early_drop_trait) {
+            None => return, // No types with (new-style) dtors present.
+            Some(found_impls) => found_impls
+        };
+
+        for &impl_did in trait_impls.borrow().iter() {
+            let self_type = self.get_self_type_for_implementation(impl_did);
+            match ty::get(self_type.ty).sty {
+                ty::ty_enum(type_def_id, _) |
+                ty::ty_struct(type_def_id, _) |
+                ty::ty_unboxed_closure(type_def_id) => {
+                    tcx.quiet_dtor_for_type.borrow_mut().insert(type_def_id, impl_did);
+                }
+                ty::ty_box(..) => {
+                    assert!(tcx.quiet_dtor_for_ty_box.get().is_none());
+                    tcx.quiet_dtor_for_ty_box.set(Some(impl_did));
+                }
+                _ => {
+                    // Destructors only work on nominal types.
+                    if impl_did.krate == ast::LOCAL_CRATE {
+                        {
+                            match tcx.map.find(impl_did.node) {
+                                Some(ast_map::NodeItem(item)) => {
+                                    span_err!(tcx.sess, item.span, E0162,
+                                        "the QuietEarlyDrop trait may only be implemented on structures");
+                                }
+                                _ => {
+                                    tcx.sess.bug("didn't find impl in ast \
+                                                  map");
+                                }
+                            }
+                        }
+                    } else {
+                        tcx.sess.bug("found external impl of QuietEarlyDrop trait on \
+                                      something other than a struct");
+                    }
+                }
+            }
+        }
+    }
 }
 
 pub fn make_substs_for_receiver_types(tcx: &ty::ctxt,
diff --git a/src/librustc/util/ppaux.rs b/src/librustc/util/ppaux.rs
index 11f16f1..638ca5d 100644
--- a/src/librustc/util/ppaux.rs
+++ b/src/librustc/util/ppaux.rs
@@ -107,7 +107,7 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)
           }
           Some(_) | None => {
             // this really should not happen
-            (format!("unknown scope: {}.  Please report a bug.", node_id), None)
+            fail!("unknown scope: {}.  Please report a bug.", node_id)
           }
         }
       }
diff --git a/src/libstd/gc.rs b/src/libstd/gc.rs
index 47b7426..71fa68f 100644
--- a/src/libstd/gc.rs
+++ b/src/libstd/gc.rs
@@ -26,7 +26,7 @@ use fmt;
 use hash;
 use kinds::marker;
 use option::Option;
-use ops::Deref;
+use ops::{Deref, QuietEarlyDrop};
 use raw;
 
 /// Immutable garbage-collected pointer type
@@ -46,6 +46,11 @@ impl<T> Clone for Gc<T> {
     fn clone(&self) -> Gc<T> { *self }
 }
 
+// We do not require QuietEarlyDrop on T in this case, because the
+// assumption is that if you are using Gc<T>, then you are prepared
+// for the Drop to occur at any time.
+impl<T> QuietEarlyDrop for Gc<T> { }
+
 /// An value that represents the task-local managed heap.
 ///
 /// Use this like `let foo = box(GC) Bar::new(...);`
diff --git a/src/libstd/path/posix.rs b/src/libstd/path/posix.rs
index 06eab31..574dabe 100644
--- a/src/libstd/path/posix.rs
+++ b/src/libstd/path/posix.rs
@@ -18,6 +18,7 @@ use from_str::FromStr;
 use hash;
 use io::Writer;
 use iter::{DoubleEndedIterator, AdditiveIterator, Extendable, Iterator, Map};
+use ops::QuietEarlyDrop;
 use option::{Option, None, Some};
 use str::Str;
 use str;
@@ -41,6 +42,8 @@ pub struct Path {
     sepidx: Option<uint> // index of the final separator in repr
 }
 
+impl QuietEarlyDrop for Path {}
+
 /// The standard path separator character
 pub static SEP: char = '/';
 
diff --git a/src/libstd/path/windows.rs b/src/libstd/path/windows.rs
index d9864cf..ac9a676 100644
--- a/src/libstd/path/windows.rs
+++ b/src/libstd/path/windows.rs
@@ -22,6 +22,7 @@ use hash;
 use io::Writer;
 use iter::{AdditiveIterator, DoubleEndedIterator, Extendable, Iterator, Map};
 use mem;
+use ops::QuietEarlyDrop;
 use option::{Option, Some, None};
 use slice::{Slice, ImmutableSlice};
 use str::{CharSplits, Str, StrAllocating, StrVector, StrSlice};
@@ -83,6 +84,8 @@ pub struct Path {
     sepidx: Option<uint> // index of the final separator in the non-prefix portion of repr
 }
 
+impl QuietEarlyDrop for Path {}
+
 impl PartialEq for Path {
     #[inline]
     fn eq(&self, other: &Path) -> bool {
@@ -734,7 +737,7 @@ impl Path {
         };
         (prefix, match val {
             None => s.into_string(),
-            Some(val) => val
+            Some(val) => { mem::drop(s); val }
         })
     }
 
diff --git a/src/libsyntax/ast_map/mod.rs b/src/libsyntax/ast_map/mod.rs
index d1f78c7..4cb865e 100644
--- a/src/libsyntax/ast_map/mod.rs
+++ b/src/libsyntax/ast_map/mod.rs
@@ -164,7 +164,7 @@ impl MapEntry {
             EntryBlock(id, _) => id,
             EntryStructCtor(id, _) => id,
             EntryLifetime(id, _) => id,
-            _ => return None
+            NotPresent | RootCrate | RootInlinedParent(_) => return None,
         })
     }
 
@@ -183,7 +183,7 @@ impl MapEntry {
             EntryBlock(_, p) => NodeBlock(p),
             EntryStructCtor(_, p) => NodeStructCtor(p),
             EntryLifetime(_, p) => NodeLifetime(p),
-            _ => return None
+            NotPresent | RootCrate | RootInlinedParent(_) => return None,
         })
     }
 }
@@ -620,6 +620,7 @@ pub struct Ctx<'a, F> {
 impl<'a, F> Ctx<'a, F> {
     fn insert(&self, id: NodeId, entry: MapEntry) {
         (*self.map.map.borrow_mut()).grow_set(id as uint, &NotPresent, entry);
+        debug!("ast_map::Ctx.insert({}, {:s})", id, node_id_to_string(self.map, id));
     }
 }
 
diff --git a/src/libsyntax/print/pprust.rs b/src/libsyntax/print/pprust.rs
index d5bc1bf..4458958 100644
--- a/src/libsyntax/print/pprust.rs
+++ b/src/libsyntax/print/pprust.rs
@@ -39,6 +39,7 @@ pub enum AnnNode<'a> {
     NodeItem(&'a ast::Item),
     NodeExpr(&'a ast::Expr),
     NodePat(&'a ast::Pat),
+    NodeMethod(&'a ast::Method),
 }
 
 pub trait PpAnn {
@@ -1091,6 +1092,7 @@ impl<'a> State<'a> {
         try!(self.hardbreak_if_not_bol());
         try!(self.maybe_print_comment(meth.span.lo));
         try!(self.print_outer_attributes(meth.attrs.as_slice()));
+        try!(self.ann.pre(self, NodeMethod(meth)));
         match meth.node {
             ast::MethDecl(ident,
                           ref generics,
@@ -1108,7 +1110,7 @@ impl<'a> State<'a> {
                                    Some(explicit_self.node),
                                    vis));
                 try!(word(&mut self.s, " "));
-                self.print_block_with_attrs(&*body, meth.attrs.as_slice())
+                try!(self.print_block_with_attrs(&*body, meth.attrs.as_slice()))
             },
             ast::MethMac(codemap::Spanned { node: ast::MacInvocTT(ref pth, ref tts, _),
                                             ..}) => {
@@ -1119,9 +1121,10 @@ impl<'a> State<'a> {
                 try!(self.popen());
                 try!(self.print_tts(tts.as_slice()));
                 try!(self.pclose());
-                self.end()
+                try!(self.end())
             }
         }
+        self.ann.post(self, NodeMethod(meth))
     }
 
     pub fn print_outer_attributes(&mut self,
diff --git a/str01.rs b/str01.rs
new file mode 100644
index 0000000..9e1410d
--- /dev/null
+++ b/str01.rs
@@ -0,0 +1,55 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub fn drop<T>(_x: T) { }
+
+pub enum Option<T> { None, Some(T), }
+
+impl<T> Option<T> {
+    fn map<A>(self, _f: |T| -> A) -> Option<A> { loop { } }
+}
+
+mod marker {
+    #[lang="contravariant_lifetime"]
+    pub struct ContravariantLifetime<'a>;
+}
+
+pub struct Chars<'a> {
+    marker: marker::ContravariantLifetime<'a>
+}
+
+pub struct Utf16CodeUnits<'a> {
+    chars: Chars<'a>,
+    extra: u16
+}
+
+impl<'a> Chars<'a> {
+    fn next(&mut self) -> Option<char> { loop { } }
+}
+
+trait EncodeUtf16 {
+    fn encode_utf16(&self, _buf: &mut [u16]) -> uint { loop { } }
+}
+
+impl EncodeUtf16 for char { }
+
+impl<'a> Utf16CodeUnits<'a> {
+    pub fn foo(&mut self) -> Option<u16> {
+        if self.extra != 0 {
+            let tmp = self.extra;
+            self.extra = 0;
+            return Some(tmp);
+        }
+
+        let mut buf = [0u16, ..2];
+        self.chars.next().map(|ch| {
+            let n = ch.encode_utf16(buf /* as mut slice! */);
+            if n == 2 { self.extra = buf[1]; }
+            buf[0]
+        })
+    }
+}
diff --git a/str02.rs b/str02.rs
new file mode 100644
index 0000000..96b7634
--- /dev/null
+++ b/str02.rs
@@ -0,0 +1,61 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub fn drop<T>(_x: T) { }
+
+pub enum Option<T> { None, Some(T), }
+
+impl<T> Option<T> {
+    fn map<A>(self, f: |T| -> A) -> Option<A> { loop { } }
+}
+
+mod slice {
+    mod marker {
+        #[lang="contravariant_lifetime"]
+        pub struct ContravariantLifetime<'a>;
+    }
+
+    pub struct Items<'a, T> {
+        ptr: *const T,
+        end: *const T,
+        marker: marker::ContravariantLifetime<'a>
+    }
+}
+
+pub struct Chars<'a> {
+    iter: slice::Items<'a, u8>
+}
+
+pub struct Utf16CodeUnits<'a> {
+    chars: Chars<'a>,
+    extra: u16
+}
+
+impl<'a> Chars<'a> {
+    fn next(&mut self) -> Option<char> { loop { } }
+}
+
+trait EncodeUtf16 {
+    fn encode_utf16(&self, buf: &mut [u16]) -> uint { loop { } }
+}
+
+impl EncodeUtf16 for char { }
+
+fn foo<'a>(c: &mut Utf16CodeUnits<'a>) -> Option<u16> {
+    if c.extra != 0 {
+        let tmp = c.extra;
+        c.extra = 0;
+        return Some(tmp);
+    }
+
+    let mut buf = [0u16, ..2];
+    c.chars.next().map(|ch| {
+        let n = ch.encode_utf16(buf /* as mut slice! */);
+        if n == 2 { c.extra = buf[1]; }
+        buf[0]
+    })
+}
