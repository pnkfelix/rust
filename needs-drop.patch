commit 3fc5a75f89d6522de7b5ee2766ce839e8ce3f986
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Mon Sep 15 12:07:05 2014 +0200

    checkpoint my attempt at a rebase.
---
 src/librustc/driver/driver.rs               | 629 ---------------------------------------------------------------------------------------------------------------
 src/librustc/driver/mod.rs                  |  40 -------
 src/librustc/driver/pretty.rs               |   4 -
 src/librustc/middle/borrowck/check_drops.rs |  35 +++----
 src/librustc/middle/borrowck/check_loans.rs |   4 +-
 src/librustc/middle/borrowck/mod.rs         |   8 +-
 src/librustc/middle/borrowck/move_data.rs   |  14 +--
 src/librustc/middle/check_match.rs          |   3 +-
 src/librustc/middle/check_rvalues.rs        |   5 +
 src/librustc/middle/mem_categorization.rs   |   2 +-
 src/librustc/middle/trans/_match.rs         |   3 +-
 src/librustc/middle/ty.rs                   |   2 +-
 src/librustc/middle/typeck/check/mod.rs     |   2 +-
 src/librustc/middle/typeck/check/vtable.rs  |  35 +++----
 src/librustc/middle/typeck/coherence.rs     |   2 +-
 src/libsyntax/ast_map/mod.rs                |   1 -
 16 files changed, 60 insertions(+), 729 deletions(-)

diff --git a/src/librustc/driver/driver.rs b/src/librustc/driver/driver.rs
index e4b79f1..24c9a7f 100644
--- a/src/librustc/driver/driver.rs
+++ b/src/librustc/driver/driver.rs
@@ -614,635 +614,6 @@ fn write_out_deps(sess: &Session,
     }
 }
 
-<<<<<<< HEAD
-||||||| merged common ancestors
-struct IdentifiedAnnotation;
-
-impl pprust::PpAnn for IdentifiedAnnotation {
-    fn pre(&self,
-           s: &mut pprust::State,
-           node: pprust::AnnNode) -> io::IoResult<()> {
-        match node {
-            pprust::NodeExpr(_) => s.popen(),
-            _ => Ok(())
-        }
-    }
-    fn post(&self,
-            s: &mut pprust::State,
-            node: pprust::AnnNode) -> io::IoResult<()> {
-        match node {
-            pprust::NodeItem(item) => {
-                try!(pp::space(&mut s.s));
-                s.synth_comment(item.id.to_string())
-            }
-            pprust::NodeBlock(blk) => {
-                try!(pp::space(&mut s.s));
-                s.synth_comment(format!("block {}", blk.id))
-            }
-            pprust::NodeExpr(expr) => {
-                try!(pp::space(&mut s.s));
-                try!(s.synth_comment(expr.id.to_string()));
-                s.pclose()
-            }
-            pprust::NodePat(pat) => {
-                try!(pp::space(&mut s.s));
-                s.synth_comment(format!("pat {}", pat.id))
-            }
-        }
-    }
-}
-
-struct TypedAnnotation {
-    analysis: CrateAnalysis,
-}
-
-impl pprust::PpAnn for TypedAnnotation {
-    fn pre(&self,
-           s: &mut pprust::State,
-           node: pprust::AnnNode) -> io::IoResult<()> {
-        match node {
-            pprust::NodeExpr(_) => s.popen(),
-            _ => Ok(())
-        }
-    }
-    fn post(&self,
-            s: &mut pprust::State,
-            node: pprust::AnnNode) -> io::IoResult<()> {
-        let tcx = &self.analysis.ty_cx;
-        match node {
-            pprust::NodeExpr(expr) => {
-                try!(pp::space(&mut s.s));
-                try!(pp::word(&mut s.s, "as"));
-                try!(pp::space(&mut s.s));
-                try!(pp::word(&mut s.s,
-                              ppaux::ty_to_string(
-                                  tcx,
-                                  ty::expr_ty(tcx, expr)).as_slice()));
-                s.pclose()
-            }
-            _ => Ok(())
-        }
-    }
-}
-
-fn gather_flowgraph_variants(sess: &Session) -> Vec<borrowck_dot::Variant> {
-    let print_loans   = config::FLOWGRAPH_PRINT_LOANS;
-    let print_moves   = config::FLOWGRAPH_PRINT_MOVES;
-    let print_assigns = config::FLOWGRAPH_PRINT_ASSIGNS;
-    let print_all     = config::FLOWGRAPH_PRINT_ALL;
-    let opt = |print_which| sess.debugging_opt(print_which);
-    let mut variants = Vec::new();
-    if opt(print_all) || opt(print_loans) {
-        variants.push(borrowck_dot::Loans);
-    }
-    if opt(print_all) || opt(print_moves) {
-        variants.push(borrowck_dot::Moves);
-    }
-    if opt(print_all) || opt(print_assigns) {
-        variants.push(borrowck_dot::Assigns);
-    }
-    variants
-}
-
-pub fn pretty_print_input(sess: Session,
-                          cfg: ast::CrateConfig,
-                          input: &Input,
-                          ppm: PpMode,
-                          ofile: Option<Path>) {
-    let krate = phase_1_parse_input(&sess, cfg, input);
-    let id = link::find_crate_name(Some(&sess), krate.attrs.as_slice(), input);
-
-    let (krate, ast_map, is_expanded) = match ppm {
-        PpmExpanded | PpmExpandedIdentified | PpmTyped | PpmFlowGraph(_) => {
-            let (krate, ast_map)
-                = match phase_2_configure_and_expand(&sess, krate,
-                                                     id.as_slice(), None) {
-                    None => return,
-                    Some(p) => p,
-                };
-            (krate, Some(ast_map), true)
-        }
-        _ => (krate, None, false)
-    };
-
-    let src_name = source_name(input);
-    let src = Vec::from_slice(sess.codemap()
-                                  .get_filemap(src_name.as_slice())
-                                  .src
-                                  .as_bytes());
-    let mut rdr = MemReader::new(src);
-
-    let out = match ofile {
-        None => box io::stdout() as Box<Writer>,
-        Some(ref p) => {
-            let r = io::File::create(p);
-            match r {
-                Ok(w) => box w as Box<Writer>,
-                Err(e) => fail!("print-print failed to open {} due to {}",
-                                p.display(), e),
-            }
-        }
-    };
-
-    let mut file_cleanup = OutputFileCleanup::if_needed(ofile);
-
-    let res = match ppm {
-        PpmIdentified | PpmExpandedIdentified => {
-            pprust::print_crate(sess.codemap(),
-                                sess.diagnostic(),
-                                &krate,
-                                src_name.to_string(),
-                                &mut rdr,
-                                out,
-                                &IdentifiedAnnotation,
-                                is_expanded)
-        }
-        PpmTyped => {
-            let ast_map = ast_map.expect("--pretty=typed missing ast_map");
-            let analysis = phase_3_run_analysis_passes(sess, &krate, ast_map, id);
-            let annotation = TypedAnnotation {
-                analysis: analysis
-            };
-            pprust::print_crate(annotation.analysis.ty_cx.sess.codemap(),
-                                annotation.analysis.ty_cx.sess.diagnostic(),
-                                &krate,
-                                src_name.to_string(),
-                                &mut rdr,
-                                out,
-                                &annotation,
-                                is_expanded)
-        }
-        PpmFlowGraph(nodeid) => {
-            let ast_map = ast_map.expect("--pretty flowgraph missing ast_map");
-            let node = ast_map.find(nodeid).unwrap_or_else(|| {
-                sess.fatal(format!("--pretty flowgraph couldn't find id: {}",
-                                   nodeid).as_slice())
-            });
-            let code = blocks::Code::from_node(node);
-            match code {
-                Some(code) => {
-                    let variants = gather_flowgraph_variants(&sess);
-                    let analysis = phase_3_run_analysis_passes(sess, &krate,
-                                                               ast_map, id);
-                    print_flowgraph(variants, analysis, code, out)
-                }
-                None => {
-                    let message = format!("--pretty=flowgraph needs \
-                                           block, fn, or method; got {:?}",
-                                          node);
-
-                    // point to what was found, if there's an
-                    // accessible span.
-                    match ast_map.opt_span(nodeid) {
-                        Some(sp) => sess.span_fatal(sp, message.as_slice()),
-                        None => sess.fatal(message.as_slice())
-                    }
-                }
-            }
-        }
-        _ => {
-            pprust::print_crate(sess.codemap(),
-                                sess.diagnostic(),
-                                &krate,
-                                src_name.to_string(),
-                                &mut rdr,
-                                out,
-                                &pprust::NoAnn,
-                                is_expanded)
-        }
-    }.unwrap()
-
-}
-
-fn print_flowgraph<W:io::Writer>(variants: Vec<borrowck_dot::Variant>,
-                                 analysis: CrateAnalysis,
-                                 code: blocks::Code,
-                                 mut out: W) -> io::IoResult<()> {
-    let ty_cx = &analysis.ty_cx;
-    let cfg = match code {
-        blocks::BlockCode(block) => cfg::CFG::new(ty_cx, &*block),
-        blocks::FnLikeCode(fn_like) => cfg::CFG::new(ty_cx, &*fn_like.body()),
-    };
-    debug!("cfg: {:?}", cfg);
-
-    match code {
-        _ if variants.len() == 0 => {
-            let lcfg = LabelledCFG {
-                ast_map: &ty_cx.map,
-                cfg: &cfg,
-                name: format!("node_{}", code.id()),
-            };
-            let r = dot::render(&lcfg, &mut out);
-            return expand_err_details(r);
-        }
-        blocks::BlockCode(_) => {
-            ty_cx.sess.err("--pretty flowgraph with -Z flowgraph-print \
-                            annotations requires fn-like node id.");
-            return Ok(())
-        }
-        blocks::FnLikeCode(fn_like) => {
-            let fn_parts = FnPartsWithCFG::from_fn_like(&fn_like, &cfg);
-            let (bccx, analysis_data) =
-                borrowck::build_borrowck_dataflow_data_for_fn(ty_cx, fn_parts);
-
-            let lcfg = LabelledCFG {
-                ast_map: &ty_cx.map,
-                cfg: &cfg,
-                name: format!("node_{}", code.id()),
-            };
-            let lcfg = borrowck_dot::DataflowLabeller {
-                inner: lcfg,
-                variants: variants,
-                borrowck_ctxt: &bccx,
-                analysis_data: &analysis_data,
-            };
-            let r = dot::render(&lcfg, &mut out);
-            return expand_err_details(r);
-        }
-    }
-
-    fn expand_err_details(r: io::IoResult<()>) -> io::IoResult<()> {
-        r.map_err(|ioerr| {
-            let orig_detail = ioerr.detail.clone();
-            let m = "graphviz::render failed";
-            io::IoError {
-                detail: Some(match orig_detail {
-                    None => m.into_string(),
-                    Some(d) => format!("{}: {}", m, d)
-                }),
-                ..ioerr
-            }
-        })
-    }
-}
-
-=======
-struct IdentifiedAnnotation;
-
-impl pprust::PpAnn for IdentifiedAnnotation {
-    fn pre(&self,
-           s: &mut pprust::State,
-           node: pprust::AnnNode) -> io::IoResult<()> {
-        match node {
-            pprust::NodeExpr(_) => s.popen(),
-            _ => Ok(())
-        }
-    }
-    fn post(&self,
-            s: &mut pprust::State,
-            node: pprust::AnnNode) -> io::IoResult<()> {
-        match node {
-            pprust::NodeItem(item) => {
-                try!(pp::space(&mut s.s));
-                s.synth_comment(item.id.to_string())
-            }
-            pprust::NodeBlock(blk) => {
-                try!(pp::space(&mut s.s));
-                s.synth_comment(format!("block {}", blk.id))
-            }
-            pprust::NodeExpr(expr) => {
-                try!(pp::space(&mut s.s));
-                try!(s.synth_comment(expr.id.to_string()));
-                s.pclose()
-            }
-            pprust::NodePat(pat) => {
-                try!(pp::space(&mut s.s));
-                s.synth_comment(format!("pat {}", pat.id))
-            }
-            pprust::NodeMethod(m) => {
-                try!(pp::space(&mut s.s));
-                s.synth_comment(format!("method {}", m.id))
-            }
-        }
-    }
-}
-
-struct TypedAnnotation {
-    analysis: CrateAnalysis,
-}
-
-impl pprust::PpAnn for TypedAnnotation {
-    fn pre(&self,
-           s: &mut pprust::State,
-           node: pprust::AnnNode) -> io::IoResult<()> {
-        match node {
-            pprust::NodeExpr(_) => s.popen(),
-            _ => Ok(())
-        }
-    }
-    fn post(&self,
-            s: &mut pprust::State,
-            node: pprust::AnnNode) -> io::IoResult<()> {
-        let tcx = &self.analysis.ty_cx;
-        match node {
-            pprust::NodeExpr(expr) => {
-                try!(pp::space(&mut s.s));
-                try!(pp::word(&mut s.s, "as"));
-                try!(pp::space(&mut s.s));
-                try!(pp::word(&mut s.s,
-                              ppaux::ty_to_string(
-                                  tcx,
-                                  ty::expr_ty(tcx, expr)).as_slice()));
-                s.pclose()
-            }
-            _ => Ok(())
-        }
-    }
-}
-
-fn gather_flowgraph_variants(sess: &Session) -> Vec<borrowck_dot::Variant> {
-    let print_loans      = config::FLOWGRAPH_PRINT_LOANS;
-    let print_moves      = config::FLOWGRAPH_PRINT_MOVES;
-    let print_assigns    = config::FLOWGRAPH_PRINT_ASSIGNS;
-    let print_needs_drop = config::FLOWGRAPH_PRINT_NEEDS_DROP;
-    let print_all        = config::FLOWGRAPH_PRINT_ALL;
-    let opt = |print_which| sess.debugging_opt(print_which);
-    let mut variants = Vec::new();
-    if opt(print_all) || opt(print_loans) {
-        variants.push(borrowck_dot::Loans);
-    }
-    if opt(print_all) || opt(print_moves) {
-        variants.push(borrowck_dot::Moves);
-    }
-    if opt(print_all) || opt(print_assigns) {
-        variants.push(borrowck_dot::Assigns);
-    }
-    if opt(print_all) || opt(print_needs_drop) {
-        variants.push(borrowck_dot::NeedsDrop);
-        variants.push(borrowck_dot::IgnoreDrop);
-    }
-    variants
-}
-
-pub enum FlowGraphId {
-    FlowGraphViaNode(ast::NodeId),
-    FlowGraphViaPath(String),
-}
-
-impl FromStr for FlowGraphId {
-    fn from_str(s: &str) -> Option<FlowGraphId> {
-        let oi: Option<ast::NodeId> = FromStr::from_str(s);
-        match oi {
-            Some(i) => Some(FlowGraphViaNode(i)),
-            None => Some(FlowGraphViaPath(s.to_string())),
-        }
-    }
-}
-
-impl FlowGraphId {
-    fn to_node_id(self,
-                  tcx: &ty::ctxt) -> ast::NodeId {
-        let sess = &tcx.sess;
-        let string = match self {
-            FlowGraphViaNode(node_id) => return node_id,
-            FlowGraphViaPath(string) => string,
-        };
-
-        let fail_because = |is_wrong_because| -> ast::NodeId {
-            let message =
-                format!("pretty flowgraph= needs NodeId (int) or unique \
-                         path suffix (b::c::d); got {:s}, which {:s}",
-                        string, is_wrong_because);
-            sess.fatal(message.as_slice())
-        };
-
-        let parts : Vec<&str> = string.as_slice().split_str("::").collect();
-        let mut saw_node = ast::DUMMY_NODE_ID;
-        let mut seen = 0u;
-        for node in tcx.map.nodes_matching_suffix(parts.as_slice()) {
-            saw_node = node;
-            seen += 1;
-            if seen > 1 {
-                fail_because("does not resolve uniquely");
-            }
-        }
-        if seen == 0 {
-            fail_because("does not resolve to any item");
-        }
-
-        assert!(seen == 1);
-        return saw_node;
-    }
-}
-
-pub fn pretty_print_input(sess: Session,
-                          cfg: ast::CrateConfig,
-                          input: &Input,
-                          ppm: PpMode,
-                          ofile: Option<Path>) {
-    let krate = phase_1_parse_input(&sess, cfg, input);
-    let id = link::find_crate_name(Some(&sess), krate.attrs.as_slice(), input);
-
-    let (krate, ast_map, is_expanded) = match ppm {
-        PpmExpanded | PpmExpandedIdentified | PpmTyped | PpmFlowGraph(_) => {
-            let (krate, ast_map)
-                = match phase_2_configure_and_expand(&sess, krate,
-                                                     id.as_slice(), None) {
-                    None => return,
-                    Some(p) => p,
-                };
-            (krate, Some(ast_map), true)
-        }
-        _ => (krate, None, false)
-    };
-
-    let src_name = source_name(input);
-    let src = Vec::from_slice(sess.codemap()
-                                  .get_filemap(src_name.as_slice())
-                                  .src
-                                  .as_bytes());
-    let mut rdr = MemReader::new(src);
-
-    let out = match ofile {
-        None => box io::stdout() as Box<Writer>,
-        Some(p) => {
-            let r = io::File::create(&p);
-            match r {
-                Ok(w) => box w as Box<Writer>,
-                Err(e) => fail!("print-print failed to open {} due to {}",
-                                p.display(), e),
-            }
-        }
-    };
-    match ppm {
-        PpmIdentified | PpmExpandedIdentified => {
-            pprust::print_crate(sess.codemap(),
-                                sess.diagnostic(),
-                                &krate,
-                                src_name.to_string(),
-                                &mut rdr,
-                                out,
-                                &IdentifiedAnnotation,
-                                is_expanded)
-        }
-        PpmTyped => {
-            let ast_map = ast_map.expect("--pretty=typed missing ast_map");
-            let analysis = phase_3_run_analysis_passes(sess, &krate, ast_map, id);
-            let annotation = TypedAnnotation {
-                analysis: analysis
-            };
-            pprust::print_crate(annotation.analysis.ty_cx.sess.codemap(),
-                                annotation.analysis.ty_cx.sess.diagnostic(),
-                                &krate,
-                                src_name.to_string(),
-                                &mut rdr,
-                                out,
-                                &annotation,
-                                is_expanded)
-        }
-        PpmFlowGraph(flow_graph_id) => {
-            let variants = gather_flowgraph_variants(&sess);
-            let ast_map = ast_map.expect("--pretty flowgraph missing ast_map");
-            let analysis = phase_3_run_analysis_passes(sess, &krate, ast_map, id);
-            print_flowgraph(variants, analysis, flow_graph_id, out)
-        }
-        _ => {
-            pprust::print_crate(sess.codemap(),
-                                sess.diagnostic(),
-                                &krate,
-                                src_name.to_string(),
-                                &mut rdr,
-                                out,
-                                &pprust::NoAnn,
-                                is_expanded)
-        }
-    };
-
-    if res.is_ok() {
-        file_cleanup.unneeded();
-    }
-
-    res.unwrap()
-}
-
-struct OutputFileCleanup {
-    path: Option<Path>,
-}
-
-impl OutputFileCleanup {
-    fn unneeded(&mut self) { self.path = None; }
-    fn if_needed(opt_path: Option<Path>) -> OutputFileCleanup {
-        OutputFileCleanup { path: opt_path }
-    }
-}
-
-impl Drop for OutputFileCleanup {
-    fn drop(&mut self) {
-        match self.path {
-            None => {}
-            Some(ref path) => {
-                // clean-up is only best-effort (and only if no output
-                // was produced); so drop result.
-                drop(io::fs::stat(path).
-                     and_then(|file_stat| {
-                         if file_stat.size == 0 {
-                             io::fs::unlink(path)
-                         } else {
-                             Ok(())
-                         }
-                     }));
-            }
-        }
-    }
-}
-
-
-
-
-fn flow_graph_id_to_code(flow_graph_id: FlowGraphId,
-                         analysis: &CrateAnalysis) -> blocks::Code {
-    let ty_cx = &analysis.ty_cx;
-    let ast_map = &ty_cx.map;
-    let sess = &ty_cx.sess;
-
-    let nodeid = flow_graph_id.to_node_id(ty_cx);
-    let node = ast_map.find(nodeid).unwrap_or_else(|| {
-        sess.fatal(format!("--pretty flowgraph couldn't find id: {}",
-                           nodeid).as_slice())
-    });
-    let code = blocks::Code::from_node(node);
-    match code {
-        Some(code) => code,
-        None => {
-            let message = format!("--pretty=flowgraph needs \
-                                   block, fn, or method; got {:?}",
-                                  node);
-
-            // point to what was found, if there's an
-            // accessible span.
-            match ast_map.opt_span(nodeid) {
-                Some(sp) => sess.span_fatal(sp, message.as_slice()),
-                None => sess.fatal(message.as_slice())
-            }
-        }
-    }
-}
-
-fn print_flowgraph<W:io::Writer>(variants: Vec<borrowck_dot::Variant>,
-                                 analysis: CrateAnalysis,
-                                 flow_graph_id: FlowGraphId,
-                                 mut out: W) -> io::IoResult<()> {
-    let ty_cx = &analysis.ty_cx;
-
-    let code = flow_graph_id_to_code(flow_graph_id, &analysis);
-    let cfg = match code {
-        blocks::BlockCode(block) => cfg::CFG::new(ty_cx, &*block),
-        blocks::FnLikeCode(fn_like) => cfg::CFG::new(ty_cx, &*fn_like.body()),
-    };
-    debug!("cfg: {:?}", cfg);
-
-    match code {
-        _ if variants.len() == 0 => {
-            let lcfg = LabelledCFG {
-                ast_map: &ty_cx.map,
-                cfg: &cfg,
-                name: format!("node_{}", code.id()),
-            };
-            let r = dot::render(&lcfg, &mut out);
-            return expand_err_details(r);
-        }
-        blocks::BlockCode(_) => {
-            ty_cx.sess.err("--pretty flowgraph with -Z flowgraph-print \
-                            annotations requires fn-like node id.");
-            return Ok(())
-        }
-        blocks::FnLikeCode(fn_like) => {
-            let fn_parts = FnPartsWithCFG::from_fn_like(&fn_like, &cfg);
-            let (bccx, analysis_data) =
-                borrowck::build_borrowck_dataflow_data_for_fn(ty_cx, fn_parts);
-
-            let lcfg = LabelledCFG {
-                ast_map: &ty_cx.map,
-                cfg: &cfg,
-                name: format!("node_{}", code.id()),
-            };
-            let lcfg = borrowck_dot::DataflowLabeller {
-                inner: lcfg,
-                variants: variants,
-                borrowck_ctxt: &bccx,
-                analysis_data: &analysis_data,
-            };
-            let r = dot::render(&lcfg, &mut out);
-            return expand_err_details(r);
-        }
-    }
-
-    fn expand_err_details(r: io::IoResult<()>) -> io::IoResult<()> {
-        r.map_err(|ioerr| {
-            let orig_detail = ioerr.detail.clone();
-            let m = "graphviz::render failed";
-            io::IoError {
-                detail: Some(match orig_detail {
-                    None => m.into_string(),
-                    Some(d) => format!("{}: {}", m, d)
-                }),
-                ..ioerr
-            }
-        })
-    }
-}
-
->>>>>>> checkpoint prelim needs drop analysis.
 pub fn collect_crate_types(session: &Session,
                            attrs: &[ast::Attribute]) -> Vec<config::CrateType> {
     // Unconditionally collect crate types from attributes to make them used
diff --git a/src/librustc/driver/mod.rs b/src/librustc/driver/mod.rs
index cb385da..5e00b9e 100644
--- a/src/librustc/driver/mod.rs
+++ b/src/librustc/driver/mod.rs
@@ -385,46 +385,6 @@ fn print_crate_info(sess: &Session,
     }
 }
 
-<<<<<<< HEAD
-||||||| merged common ancestors
-pub enum PpMode {
-    PpmNormal,
-    PpmExpanded,
-    PpmTyped,
-    PpmIdentified,
-    PpmExpandedIdentified,
-    PpmFlowGraph(ast::NodeId),
-}
-
-pub fn parse_pretty(sess: &Session, name: &str) -> PpMode {
-    let mut split = name.splitn('=', 1);
-    let first = split.next().unwrap();
-    let opt_second = split.next();
-    match (opt_second, first) {
-        (None, "normal")       => PpmNormal,
-        (None, "expanded")     => PpmExpanded,
-        (None, "typed")        => PpmTyped,
-        (None, "expanded,identified") => PpmExpandedIdentified,
-        (None, "identified")   => PpmIdentified,
-        (arg, "flowgraph") => {
-             match arg.and_then(from_str) {
-                 Some(id) => PpmFlowGraph(id),
-                 None => {
-                     sess.fatal(format!("`pretty flowgraph=<nodeid>` needs \
-                                         an integer <nodeid>; got {}",
-                                        arg.unwrap_or("nothing")).as_slice())
-                 }
-             }
-        }
-        _ => {
-            sess.fatal(format!(
-                "argument to `pretty` must be one of `normal`, \
-                 `expanded`, `flowgraph=<nodeid>`, `typed`, `identified`, \
-                 or `expanded,identified`; got {}", name).as_slice());
-        }
-    }
-}
-
 fn parse_crate_attrs(sess: &Session, input: &Input) ->
                      Vec<ast::Attribute> {
     let result = match *input {
diff --git a/src/librustc/driver/pretty.rs b/src/librustc/driver/pretty.rs
index f346925..8400650 100644
--- a/src/librustc/driver/pretty.rs
+++ b/src/librustc/driver/pretty.rs
@@ -218,10 +218,6 @@ impl pprust::PpAnn for IdentifiedAnnotation {
                 try!(pp::space(&mut s.s));
                 s.synth_comment(format!("pat {}", pat.id))
             }
-            pprust::Nodearm(arm) => {
-                try!(pp::space(&mut s.s));
-                s.synth_comment(format!("arm {}", arm.id))
-            }
         }
     }
 }
diff --git a/src/librustc/middle/borrowck/check_drops.rs b/src/librustc/middle/borrowck/check_drops.rs
index fe3e774..b3d5527 100644
--- a/src/librustc/middle/borrowck/check_drops.rs
+++ b/src/librustc/middle/borrowck/check_drops.rs
@@ -14,9 +14,9 @@
 use metadata::csearch;
 use middle::borrowck::*;
 use middle::borrowck::move_data::{Assignment, Move};
-use euv = middle::expr_use_visitor;
+use middle::expr_use_visitor as euv;
 use lint;
-use mc = middle::mem_categorization;
+use middle::mem_categorization as mc;
 use middle::dataflow;
 use middle::graph;
 use middle::lang_items::QuietEarlyDropTraitLangItem;
@@ -67,13 +67,13 @@ pub fn check_drops(bccx: &BorrowckCtxt,
                 param_env = ty::construct_parameter_environment(bccx.tcx, generics, body.id);
                 break;
             }
-            Some(ast_map::NodeMethod(..))      |
-            Some(ast_map::NodeTraitMethod(..)) => {
-                let method = ty::method(bccx.tcx, ast_util::local_def(cursor_id));
-                let generics = &method.generics;
-                param_env = ty::construct_parameter_environment(bccx.tcx, generics, body.id);
-                break;
-            }
+
+            // FIXME (pnkfelix): There used to be cut-and-pasted code
+            // here that did the same thing as NodeItem case above,
+            // but for NodeMethod and NodeTraitMethod. Those variants
+            // do not exist anymore, but presumably they are still
+            // separate cases under a different name.
+
             Some(_) => {
                 cursor_id = bccx.tcx.map.get_parent(cursor_id);
                 continue;
@@ -241,7 +241,7 @@ pub fn check_drops(bccx: &BorrowckCtxt,
                     let loan_path_str = bccx.loan_path_to_string(lp.deref());
 
                     let cfgidx_and_id = format!(" (cfgidx={}, id={})", source, source_id);
-                    let where = if bccx.tcx.sess.verbose() {
+                    let where_ = if bccx.tcx.sess.verbose() {
                         cfgidx_and_id.as_slice()
                     } else {
                         ""
@@ -251,7 +251,7 @@ pub fn check_drops(bccx: &BorrowckCtxt,
                                        exiting here{:s}, but uninitialized on others. \
                                        (Consider either using Option, or calling `drop()` \
                                        on it or reinitializing it as necessary); count: {}",
-                                      loan_path_str, where, count);
+                                      loan_path_str, where_, count);
 
                     // Check if type of `lp` has #[quiet_early_drop]
                     // attribute or implements `QuietEarlyDrop`;
@@ -280,14 +280,14 @@ pub fn check_drops(bccx: &BorrowckCtxt,
                             let opt_source2_span = bccx.tcx.map.opt_span(source2_id);
                             let cfgidx_and_id = format!(" (cfgidx={}, id={})",
                                                         source2, source2_id);
-                            let where = if bccx.tcx.sess.verbose() {
+                            let where_ = if bccx.tcx.sess.verbose() {
                                 cfgidx_and_id.as_slice()
                             } else {
                                 ""
                             };
                             let msg = format!("Path {:u} here{:s} leaves `{:s}` \
                                                uninitialized.",
-                                              count, where, loan_path_str);
+                                              count, where_, loan_path_str);
                             match opt_source2_span {
                                 Some(span) => bccx.tcx.sess.span_note(span, msg.as_slice()),
                                 None => bccx.tcx.sess.note(msg.as_slice()),
@@ -454,7 +454,6 @@ fn scan_forward_for_kill_id(bccx: &BorrowckCtxt,
             }
 
             ast_map::NodeItem(_)        | ast_map::NodeForeignItem(_) |
-            ast_map::NodeTraitMethod(_) | ast_map::NodeMethod(_)      |
             ast_map::NodeVariant(_)     | ast_map::NodeLifetime(_) => {
                 bccx.tcx.sess.bug("unexpected node")
             }
@@ -566,7 +565,7 @@ fn is_quiet_early_drop_ty_recur(tcx: &ty::ctxt,
         ty::ty_uniq(_) |
         ty::ty_ptr(_) |
         ty::ty_infer(_) |
-        ty::ty_unboxed_closure(_) => drops_loud(),
+        ty::ty_unboxed_closure(..) => drops_loud(),
 
         ty::ty_param(_) => drops_loud(),
 
@@ -583,7 +582,7 @@ fn is_quiet_early_drop_ty_recur(tcx: &ty::ctxt,
         // (Below are all the potentially recursive cases)
 
         ty::ty_tup(ref tys) => drops_recur(|| tys.iter().all(|&ty| recur(ty))),
-        ty::ty_vec(mt, opt_len) => drops_recur(|| recur(mt.ty)),
+        ty::ty_vec(ty, opt_len) => drops_recur(|| recur(ty)),
 
         ty::ty_enum(def_id, ref substs) => {
             // if this type *itself* has a dtor, but does not
@@ -660,12 +659,12 @@ fn type_implements_trait(tcx: &ty::ctxt,
 
     debug!("after subst: {}", trait_ref.repr(tcx));
 
-    let unboxed_closure_types = RefCell::new(DefIdMap::new());
+    let unboxed_closures = RefCell::new(DefIdMap::new());
 
     let vcx = check::vtable::VtableContext {
         infcx: &infcx,
         param_bounds: &param_env.bounds,
-        unboxed_closure_types: &unboxed_closure_types,
+        unboxed_closures: &unboxed_closures,
         is_early: check::vtable::NotEarly,
         if_missing_ty_param: check::vtable::IfMissingTyParamGiveUp,
     };
diff --git a/src/librustc/middle/borrowck/check_loans.rs b/src/librustc/middle/borrowck/check_loans.rs
index c68d661..2e3357d 100644
--- a/src/librustc/middle/borrowck/check_loans.rs
+++ b/src/librustc/middle/borrowck/check_loans.rs
@@ -44,7 +44,7 @@ fn owned_ptr_base_path<'a>(loan_path: &'a LoanPath) -> &'a LoanPath {
 
     fn owned_ptr_base_path_helper<'a>(loan_path: &'a LoanPath) -> Option<&'a LoanPath> {
         match *loan_path {
-            LpVar(_) | LpUpvar(_) => None,
+            LpVar(_) | LpUpvar(..) => None,
             LpExtend(ref lp_base, _, LpDeref(mc::OwnedPtr)) => {
                 match owned_ptr_base_path_helper(&**lp_base) {
                     v @ Some(_) => v,
@@ -67,7 +67,7 @@ fn owned_ptr_base_path_rc(loan_path: &Rc<LoanPath>) -> Rc<LoanPath> {
 
     fn owned_ptr_base_path_helper(loan_path: &Rc<LoanPath>) -> Option<Rc<LoanPath>> {
         match **loan_path {
-            LpVar(_) | LpUpvar(_) => None,
+            LpVar(_) | LpUpvar(..) => None,
             LpExtend(ref lp_base, _, LpDeref(mc::OwnedPtr)) => {
                 match owned_ptr_base_path_helper(lp_base) {
                     v @ Some(_) => v,
diff --git a/src/librustc/middle/borrowck/mod.rs b/src/librustc/middle/borrowck/mod.rs
index fa495c1..64c1aad 100644
--- a/src/librustc/middle/borrowck/mod.rs
+++ b/src/librustc/middle/borrowck/mod.rs
@@ -303,8 +303,8 @@ impl LoanPath {
     }
 
     fn to_type(&self, tcx: &ty::ctxt) -> ty::t {
-        use Element = middle::mem_categorization::InteriorElement;
-        use Field = middle::mem_categorization::InteriorField;
+        use middle::mem_categorization::InteriorElement as Element;
+        use middle::mem_categorization::InteriorField as Field;
 
         debug!("lp.to_type() for lp={:s}", self.repr(tcx));
         let ty = match *self {
@@ -392,7 +392,7 @@ impl LoanPath {
                     // revising array_element_ty to also map input
                     // `[T]` to `Some(T)` rather than `None` (FSK).
                     (&LpInterior(Element(_)), _) if base_elem_t.is_some() =>
-                        base_elem_t.unwrap().ty,
+                        base_elem_t.unwrap(),
 
                     // FIXME: At one point I was deliberately
                     // eschewing ty::array_element_ty because I
@@ -418,7 +418,7 @@ impl LoanPath {
                                               self.repr(tcx), t.repr(tcx));
                             let opt_span = tcx.map.opt_span(id);
                             tcx.sess.opt_span_bug(opt_span, msg.as_slice());
-                        }).ty,
+                        }),
 
                     (lp_elem, _) => {
                         let id = self.kill_scope(tcx);
diff --git a/src/librustc/middle/borrowck/move_data.rs b/src/librustc/middle/borrowck/move_data.rs
index a2ef1b1..fd25c71 100644
--- a/src/librustc/middle/borrowck/move_data.rs
+++ b/src/librustc/middle/borrowck/move_data.rs
@@ -79,7 +79,7 @@ pub struct FlowedMoveData<'a, 'tcx: 'a> {
     // We could (and maybe should, for efficiency) combine both move
     // and assign data flow into one, but this way it's easier to
     // distinguish the bits that correspond to moves and assignments.
-    pub dfcx_assign: AssignDataFlow<'a, 'tcx>
+    pub dfcx_assign: AssignDataFlow<'a, 'tcx>,
 
     pub dfcx_needs_drop: NeedsDropDataFlow<'a, 'tcx>,
 
@@ -200,11 +200,11 @@ pub type AssignDataFlow<'a, 'tcx> = DataFlowContext<'a, 'tcx, AssignDataFlowOper
 
 #[deriving(Clone)]
 pub struct NeedsDropDataFlowOperator;
-pub type NeedsDropDataFlow<'a> = DataFlowContext<'a, NeedsDropDataFlowOperator>;
+pub type NeedsDropDataFlow<'a, 'tcx> = DataFlowContext<'a, 'tcx, NeedsDropDataFlowOperator>;
 
 #[deriving(Clone)]
 pub struct IgnoreDropDataFlowOperator;
-pub type IgnoreDropDataFlow<'a> = DataFlowContext<'a, IgnoreDropDataFlowOperator>;
+pub type IgnoreDropDataFlow<'a, 'tcx> = DataFlowContext<'a, 'tcx, IgnoreDropDataFlowOperator>;
 
 fn loan_path_is_precise(loan_path: &LoanPath) -> bool {
     match *loan_path {
@@ -872,7 +872,7 @@ impl MoveData {
                     self.kill_moves(move_path_index, kill_id, dfcx_moves);
                     debug!("remove_drop_obligations scope {} {}",
                            kill_id, path.loan_path.repr(tcx));
-                    let rm = Removed { where: kill_id, what_path: move_path_index };
+                    let rm = Removed { where_: kill_id, what_path: move_path_index };
                     self.remove_drop_obligations(tcx, &rm, dfcx_needs_drop);
                     // FIXME: do I need to also remove_ignored_drops here? (FSK)
                 }
@@ -882,7 +882,7 @@ impl MoveData {
                     self.kill_moves(move_path_index, kill_id, dfcx_moves);
                     debug!("remove_drop_obligations scope {} {}",
                            kill_id, path.loan_path.repr(tcx));
-                    let rm = Removed { where: kill_id, what_path: move_path_index };
+                    let rm = Removed { where_: kill_id, what_path: move_path_index };
                     self.remove_drop_obligations(tcx, &rm, dfcx_needs_drop);
                     // FIXME: do I need to also remove_ignored_drops here? (FSK)
                 }
@@ -1203,9 +1203,9 @@ trait RemoveNeedsDropArg {
     fn node_id_removing_obligation(&self) -> ast::NodeId;
     fn path_being_moved(&self) -> MovePathIndex;
 }
-struct Removed { where: ast::NodeId, what_path: MovePathIndex }
+struct Removed { where_: ast::NodeId, what_path: MovePathIndex }
 impl RemoveNeedsDropArg for Removed {
-    fn node_id_removing_obligation(&self) -> ast::NodeId { self.where }
+    fn node_id_removing_obligation(&self) -> ast::NodeId { self.where_ }
     fn path_being_moved(&self) -> MovePathIndex { self.what_path }
 }
 impl<'a> RemoveNeedsDropArg for Move {
diff --git a/src/librustc/middle/check_match.rs b/src/librustc/middle/check_match.rs
index 6676ea9..f8770b5 100644
--- a/src/librustc/middle/check_match.rs
+++ b/src/librustc/middle/check_match.rs
@@ -12,7 +12,7 @@ use middle::const_eval::{compare_const_vals, const_bool, const_float, const_nil,
 use middle::const_eval::{const_expr_to_pat, eval_const_expr, lookup_const_by_id};
 use middle::def::*;
 use middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, Init};
-use middle::expr_use_visitor::{JustWrite, LoanCause, MutateMode};
+use middle::expr_use_visitor::{JustWrite, LoanCause, MatchMode, MutateMode};
 use middle::expr_use_visitor::{WriteAndRead};
 use middle::mem_categorization::cmt;
 use middle::pat_util::*;
@@ -977,6 +977,7 @@ struct MutationChecker<'a, 'tcx: 'a> {
 
 impl<'a, 'tcx> Delegate for MutationChecker<'a, 'tcx> {
     fn consume(&mut self, _: NodeId, _: Span, _: cmt, _: ConsumeMode) {}
+    fn matched_pat(&mut self, _: &Pat, _: cmt, _: MatchMode) {}
     fn consume_pat(&mut self, _: &Pat, _: cmt, _: ConsumeMode) {}
     fn borrow(&mut self,
               _: NodeId,
diff --git a/src/librustc/middle/check_rvalues.rs b/src/librustc/middle/check_rvalues.rs
index f851ddb..9851f0c 100644
--- a/src/librustc/middle/check_rvalues.rs
+++ b/src/librustc/middle/check_rvalues.rs
@@ -57,6 +57,11 @@ impl<'a, 'tcx> euv::Delegate for RvalueContext<'a, 'tcx> {
         }
     }
 
+    fn matched_pat(&mut self,
+                   matched_pat: &ast::Pat,
+                   cmt: mc::cmt,
+                   mode: euv::MatchMode) {}
+
     fn consume_pat(&mut self,
                    _consume_pat: &ast::Pat,
                    _cmt: mc::cmt,
diff --git a/src/librustc/middle/mem_categorization.rs b/src/librustc/middle/mem_categorization.rs
index a392e81..be9fb9f 100644
--- a/src/librustc/middle/mem_categorization.rs
+++ b/src/librustc/middle/mem_categorization.rs
@@ -329,7 +329,7 @@ impl MutabilityCategory {
             def::DefStatic(_, true) => McDeclared,
 
             def::DefArg(_, binding_mode) |
-            def::DefBinding(_, binding_mode) |
+            def::DefBinding(_, binding_mode, _) |
             def::DefLocal(_, binding_mode)  => match binding_mode {
                 ast::BindByValue(ast::MutMutable) => McDeclared,
                 _ => McImmutable
diff --git a/src/librustc/middle/trans/_match.rs b/src/librustc/middle/trans/_match.rs
index dd0668b..c3380a8 100644
--- a/src/librustc/middle/trans/_match.rs
+++ b/src/librustc/middle/trans/_match.rs
@@ -1225,7 +1225,7 @@ pub fn trans_match<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,
 fn is_discr_reassigned(bcx: Block, discr: &ast::Expr, body: &ast::Expr) -> bool {
     match discr.node {
         ast::ExprPath(..) => match bcx.def(discr.id) {
-            def::DefArg(vid, _) | def::DefBinding(vid, _) |
+            def::DefArg(vid, _) | def::DefBinding(vid, _, _) |
             def::DefLocal(vid, _) | def::DefUpvar(vid, _, _, _) => {
                 let mut rc = ReassignmentChecker {
                     node: vid,
@@ -1250,6 +1250,7 @@ struct ReassignmentChecker {
 
 impl euv::Delegate for ReassignmentChecker {
     fn consume(&mut self, _: ast::NodeId, _: Span, _: mc::cmt, _: euv::ConsumeMode) {}
+    fn matched_pat(&mut self, _: &ast::Pat, _: mc::cmt, _: euv::MatchMode) {}
     fn consume_pat(&mut self, _: &ast::Pat, _: mc::cmt, _: euv::ConsumeMode) {}
     fn borrow(&mut self, _: ast::NodeId, _: Span, _: mc::cmt, _: ty::Region,
               _: ty::BorrowKind, _: euv::LoanCause) {}
diff --git a/src/librustc/middle/ty.rs b/src/librustc/middle/ty.rs
index 3173a87..b2a9b32 100644
--- a/src/librustc/middle/ty.rs
+++ b/src/librustc/middle/ty.rs
@@ -2431,7 +2431,7 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {
             }
 
             ty_box(typ) => {
-                let mut ret = tc_ty(cx, typ, cache).managed_pointer() | TC::ReachesFfiUnsafe
+                let mut ret = tc_ty(cx, typ, cache).managed_pointer() | TC::ReachesFfiUnsafe;
                 if cx.quiet_dtor_for_ty_box.get().is_some() {
                     ret = ret - TC::OwnsLoudDtor
                 }
diff --git a/src/librustc/middle/typeck/check/mod.rs b/src/librustc/middle/typeck/check/mod.rs
index 713506f..599b460 100644
--- a/src/librustc/middle/typeck/check/mod.rs
+++ b/src/librustc/middle/typeck/check/mod.rs
@@ -1591,7 +1591,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {
         }
     }
 
-    pub fn vtable_context_is_early<'a>(&'a self, is_early: bool) -> VtableContext<'a> {
+    pub fn vtable_context_is_early<'a>(&'a self, is_early: bool) -> VtableContext<'a, 'tcx> {
         self.vtable_context(
             if is_early { check::vtable::IsEarly } else { check::vtable::NotEarly })
     }
diff --git a/src/librustc/middle/typeck/check/vtable.rs b/src/librustc/middle/typeck/check/vtable.rs
index 2912b18..dbaf4ca 100644
--- a/src/librustc/middle/typeck/check/vtable.rs
+++ b/src/librustc/middle/typeck/check/vtable.rs
@@ -104,11 +104,10 @@ impl<'a, 'tcx> VtableContext<'a, 'tcx> {
 pub type ErrMsg = (Span, String);
 pub type VtResult<A> = Result<A, ErrMsg>;
 
-pub fn lookup_vtables(vcx: &VtableContext,
+fn lookup_vtables(vcx: &VtableContext,
                   span: Span,
                   type_param_defs: &VecPerParamSpace<ty::TypeParameterDef>,
-                  substs: &subst::Substs,
-                  is_early: bool)
+                  substs: &subst::Substs)
                   -> VtResult<VecPerParamSpace<vtable_param_res>> {
     debug!("lookup_vtables(\
            type_param_defs={}, \
@@ -120,7 +119,7 @@ pub fn lookup_vtables(vcx: &VtableContext,
     let result = type_param_defs.try_map_rev(|def| {
         let ty = *substs.types.get(def.space, def.index);
         lookup_vtables_for_param(vcx, span, Some(substs),
-                                 &def.bounds, ty, is_early)
+                                 &def.bounds, ty)
     });
 
     match result {
@@ -147,7 +146,7 @@ pub fn lookup_vtables(vcx: &VtableContext,
     result
 }
 
-pub fn lookup_vtables_for_param(vcx: &VtableContext,
+fn lookup_vtables_for_param(vcx: &VtableContext,
                                 span: Span,
                                 // None for substs means the identity
                                 substs: Option<&subst::Substs>,
@@ -199,7 +198,7 @@ pub fn lookup_vtables_for_param(vcx: &VtableContext,
                             trait {} for {}",
                             vcx.infcx.trait_ref_to_string(&*trait_ref),
                             vcx.infcx.ty_to_string(ty).as_slice());
-                param_result.push(vtable_error)
+                param_result.push(vtable_error);
                 first_error = Some((span, msg));
             }
             Err(msg) => {
@@ -256,7 +255,7 @@ pub fn relate_trait_refs(tcx: &ty::ctxt,
             if !ty::trait_ref_contains_error(&r_act_trait_ref) &&
                 !ty::trait_ref_contains_error(&r_exp_trait_ref)
             {
-                let tcx = vcx.tcx();
+                let tcx = infcx.tcx;
                 span_err!(tcx.sess, span, E0095, "expected {}, found {} ({})",
                           ppaux::trait_ref_to_string(tcx, &r_exp_trait_ref),
                           ppaux::trait_ref_to_string(tcx, &r_act_trait_ref),
@@ -454,8 +453,7 @@ pub fn search_for_unboxed_closure_vtable(vcx: &VtableContext,
 fn search_for_vtable(vcx: &VtableContext,
                      span: Span,
                      ty: ty::t,
-                     trait_ref: Rc<ty::TraitRef>,
-                     is_early: bool)
+                     trait_ref: Rc<ty::TraitRef>)
                      -> VtResult<Option<vtable_origin>> {
     let tcx = vcx.tcx();
 
@@ -635,7 +633,7 @@ pub fn fixup_substs(tcx: &ty::ctxt,
     let t = ty::mk_trait(tcx,
                          id, substs,
                          ty::region_existential_bound(ty::ReStatic));
-    fixup_ty(vcx, infcx, span, t, is_early).map(|t_f| {
+    fixup_ty(tcx, infcx, span, t, is_early).map(|t_f| {
         match ty::get(t_f).sty {
           ty::ty_trait(ref inner) => inner.substs.clone(),
           _ => fail!("t_f should be a trait")
@@ -767,7 +765,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {
           ty::ty_trait(box ty::TyTrait {
               def_id: target_def_id, substs: ref target_substs, ..
           }) => {
-              let vcx = fcx.vtable_context();
+              let vcx = fcx.vtable_context_is_early(is_early);
 
               // Take the type parameters from the object
               // type, but set the Self type (which is
@@ -796,12 +794,11 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {
                                              ex.span,
                                              None,
                                              &param_bounds,
-                                             src_ty,
-                                             is_early);
+                                             src_ty);
 
               if !is_early {
-                  let mut r = VecPerParamSpace::empty();
-                  r.push(subst::SelfSpace, vtables);
+                  let mut r : vtable_res = VecPerParamSpace::empty();
+                  r.push(subst::SelfSpace, vtables.unwrap());
                   insert_vtables(fcx, key, r);
               }
           }
@@ -1129,11 +1126,13 @@ pub fn check_param_bounds(tcx: &ty::ctxt,
     let unboxed_closures = RefCell::new(DefIdMap::new());
     let vcx = VtableContext {
         infcx: &infer::new_infer_ctxt(tcx),
-        param_env: parameter_environment,
+        param_bounds: &parameter_environment.bounds,
         unboxed_closures: &unboxed_closures,
+        is_early: NotEarly,
+        if_missing_ty_param: IfMissingTyParamSearch,
     };
     let vtable_param_results =
-        lookup_vtables(&vcx, span, type_param_defs, substs, false);
+        lookup_vtables(&vcx, span, type_param_defs, substs);
     for (vtable_param_result, type_param_def) in
             vtable_param_results.iter().zip(type_param_defs.iter()) {
         for (vtable_result, trait_ref) in
@@ -1141,7 +1140,7 @@ pub fn check_param_bounds(tcx: &ty::ctxt,
                                    .zip(type_param_def.bounds
                                                       .trait_bounds
                                                       .iter()) {
-            match *vtable_result {
+            match vtable_result.unwrap() {
                 vtable_error => any_missing(&**trait_ref),
                 vtable_static(..) |
                 vtable_param(..) |
diff --git a/src/librustc/middle/typeck/coherence.rs b/src/librustc/middle/typeck/coherence.rs
index ce607db..101c68d 100644
--- a/src/librustc/middle/typeck/coherence.rs
+++ b/src/librustc/middle/typeck/coherence.rs
@@ -780,7 +780,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {
                         {
                             match tcx.map.find(impl_did.node) {
                                 Some(ast_map::NodeItem(item)) => {
-                                    span_err!(tcx.sess, item.span, E0158,
+                                    span_err!(tcx.sess, item.span, E0162,
                                         "the QuietEarlyDrop trait may only be implemented on structures");
                                 }
                                 _ => {
diff --git a/src/libsyntax/ast_map/mod.rs b/src/libsyntax/ast_map/mod.rs
index 06b7583..4cb865e 100644
--- a/src/libsyntax/ast_map/mod.rs
+++ b/src/libsyntax/ast_map/mod.rs
@@ -745,7 +745,6 @@ impl<'a, F: FoldOps> Folder for Ctx<'a, F> {
             "noop_fold_method must produce exactly one method");
         assert_eq!(self.parent, m.id);
         self.parent = parent;
-        self.insert(m.id, EntryMethod(self.parent, m));
         SmallVector::one(m)
     }
 

commit 7829f2b9f5b72f52eb41e6976f946370b3b5ef37
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Tue Sep 9 20:47:43 2014 +0200

    Added various examples that I made during development of the RFC itself.
---
 Makefile      |  14 +++++++++++---
 rfc01_fine.rs |  76 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 rfc02_warn.rs |  96 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 rfc03_fine.rs | 106 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 rfc03_warn.rs | 106 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 rfc04_fine.rs | 106 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 rfc04_warn.rs |  70 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 rfc05_deny.rs |  30 ++++++++++++++++++++++++++++++
 rfc06_fine.rs |  31 +++++++++++++++++++++++++++++++
 rfc07_fine.rs |  48 ++++++++++++++++++++++++++++++++++++++++++++++++
 10 files changed, 680 insertions(+), 3 deletions(-)

diff --git a/Makefile b/Makefile
index c763391..cde2a66 100644
--- a/Makefile
+++ b/Makefile
@@ -6,7 +6,10 @@ FILES_WARN=foo01_warn.rs               foo03_warn.rs foo04_warn.rs foo05_warn.rs
            foo31_warn.rs                                                         \
                                        foo43_warn.rs                             \
                                        foo48_warn.rs               foo50_warn.rs \
-                         foo52_warn.rs
+                         foo52_warn.rs                                           \
+                                                                                 \
+                         rfc02_warn.rs               rfc04_warn.rs
+
 
 FILES_FINE=              foo02_fine.rs                                           \
            foo11_fine.rs foo12_fine.rs foo13_fine.rs foo14_fine.rs foo15_fine.rs \
@@ -15,7 +18,12 @@ FILES_FINE=              foo02_fine.rs
                          foo32_fine.rs foo33_fine.rs foo34_fine.rs               \
                          foo42_fine.rs               foo44_fine.rs               \
                          foo47_fine.rs               foo49_fine.rs               \
-                                       foo53_fine.rs foo54_fine.rs foo55_fine.rs
+                                       foo53_fine.rs foo54_fine.rs foo55_fine.rs \
+                                                                                 \
+           rfc01_fine.rs               rfc03_fine.rs                             \
+           rfc06_fine.rs
+
+FILES_DENY=rfc05_deny.rs
 
 FILES_UNCATEGORIZED=                                                             \
            foo16.rs                                  foo19.rs      foo20.rs      \
@@ -27,7 +35,7 @@ FILES_UNCATEGORIZED=
            result01.rs result02.rs result03.rs \
            str01.rs
 
-FILES=$(FILES_WARN) $(FILES_FINE) $(FILES_UNCATEGORIZED)
+FILES=$(FILES_WARN) $(FILES_FINE) $(FILES_DENY) $(FILES_UNCATEGORIZED)
 
 all: $(patsubst %.rs,%.dot,$(FILES))
 .PHONY: touch_fine
diff --git a/rfc01_fine.rs b/rfc01_fine.rs
new file mode 100644
index 0000000..43cd257
--- /dev/null
+++ b/rfc01_fine.rs
@@ -0,0 +1,76 @@
+#![feature(lang_items)]
+#![no_std]
+#![allow(dead_code)]
+#![allow(unused_variable)]
+#![allow(dead_assignment)]
+
+#![crate_type="lib"]
+
+#[lang="sized"] pub trait Sized { }
+#[lang="drop"] pub trait Drop { fn drop(&mut self); }
+pub enum Option<T> { None, Some(T), }
+
+// (PRELUDE ENDS ABOVE)
+
+struct Pair<X,Y>{ x:X, y:Y }
+
+struct D; struct S;
+
+impl Drop for D { fn drop(&mut self) { loop { } } }
+
+fn test() -> bool { loop { } }
+
+fn xform(d:D) -> D { loop { } }
+
+fn foo(mk_dd: || -> Pair<D,D>, mk_ds: || -> Pair<D,S>, mk_opt_d: || -> Option<D>) {
+    // At the outset, the set of drop obligations is
+    // just the set of moved input parameters (empty
+    // in this case).
+
+    //                                      DROP OBLIGATIONS
+    //                                  ------------------------
+    //                                  {  }
+    let mut pDD : Pair<D,D> = mk_dd();
+    //                                  { pDD.x, pDD.y }
+    let pDS : Pair<D,S> = mk_ds();
+    //                                  { pDD.x, pDD.y, pDS.x }
+    let mut some_d : Option<D> = mk_opt_d();
+    //                                  { pDD.x, pDD.y, pDS.x }
+    if test() {
+        //                                 { pDD.x, pDD.y, pDS.x }
+        {
+            let temp = xform(pDD.x);
+            //                             {        pDD.y, pDS.x, temp }
+            some_d = Some(temp);
+            //                             {        pDD.y, pDS.x, temp, some_d }
+        } // END OF SCOPE for `temp`
+        //                                 {        pDD.y, pDS.x, some_d }
+    } else {
+        {
+            //                             { pDD.x, pDD.y, pDS.x }
+            let z = D;
+            //                             { pDD.x, pDD.y, pDS.x, z }
+
+            // This drops `pDD.y` before
+            // moving `pDD.x` there.
+            pDD.y = pDD.x;
+
+            //                             {        pDD.y, pDS.x, z }
+            some_d = None;
+            //                             {        pDD.y, pDS.x, z, some_d }
+        } // END OF SCOPE for `z`
+        //                                 {        pDD.y, pDS.x, some_d }
+    }
+
+    // MERGE POINT: set of drop obligations must
+    // match on all incoming control-flow paths...
+    //
+    // ... which they do in this case.
+
+    //                                  {       pDD.y, pDS.x, some_d }
+
+    // (... some code that does not change drop obligations ...)
+    mk_dd();
+
+    //                                  {       pDD.y, pDS.x, some_d }
+}
diff --git a/rfc02_warn.rs b/rfc02_warn.rs
new file mode 100644
index 0000000..43f53d2
--- /dev/null
+++ b/rfc02_warn.rs
@@ -0,0 +1,96 @@
+#![feature(lang_items)]
+#![no_std]
+#![allow(dead_code)]
+#![allow(unused_variable)]
+#![allow(dead_assignment)]
+
+#![crate_type="lib"]
+
+#[lang="sized"] pub trait Sized { }
+#[lang="drop"] pub trait Drop { fn drop(&mut self); }
+pub enum Option<T> { None, Some(T), }
+
+// (PRELUDE ENDS ABOVE)
+
+struct Pair<X,Y>{ x:X, y:Y }
+
+struct D; struct S;
+
+impl Drop for D { fn drop(&mut self) { loop { } } }
+
+fn test() -> bool { loop { } }
+
+fn xform(d:D) -> D { loop { } }
+
+// `f2` is similar to `f1`, except that it will have differing set
+// of drop obligations at the merge point, necessitating a hidden
+// drop call.
+fn foo(mk_dd: || -> Pair<D,D>, mk_ds: || -> Pair<D,S>, mk_opt_d: || -> Option<D>) {
+    // At the outset, the set of drop obligations is
+    // just the set of moved input parameters (empty
+    // in this case).
+
+    //                                      DROP OBLIGATIONS
+    //                                  ------------------------
+    //                                  {  }
+    let mut pDD : Pair<D,D> = mk_dd();
+    //                                  {pDD.x, pDD.y}
+    let pDS : Pair<D,S> = mk_ds();
+    //                                  {pDD.x, pDD.y, pDS.x}
+    let mut some_d : Option<D> = mk_opt_d();
+    //                                  {pDD.x, pDD.y, pDS.x}
+    if test() {
+        //                                  {pDD.x, pDD.y, pDS.x}
+        {
+            let temp = xform(pDD.y);
+            //                              {pDD.x,        pDS.x, temp}
+            some_d = Some(temp);
+            //                              {pDD.x,        pDS.x, temp, some_d}
+        } // END OF SCOPE for `temp`
+        //                                  {pDD.x,        pDS.x, some_d}
+
+        // MERGE POINT PREDECESSOR 1
+
+        // implicit drops injected: drop(pDD.y)
+    } else {
+        {
+            //                              {pDD.x, pDD.y, pDS.x}
+            let z = D;
+            //                              {pDD.x, pDD.y, pDS.x, z}
+
+            // This drops `pDD.y` before
+            // moving `pDD.x` there.
+            pDD.y = pDD.x;
+
+            //                              {       pDD.y, pDS.x, z}
+            some_d = None;
+            //                              {       pDD.y, pDS.x, z, some_d}
+        } // END OF SCOPE for `z`
+        //                                  {       pDD.y, pDS.x, some_d}
+
+        // MERGE POINT PREDECESSOR 2
+
+        // implicit drops injected: drop(pDD.y)
+    }
+
+    // MERGE POINT: set of drop obligations must
+    // match on all incoming control-flow paths.
+    //
+    // For the original user code, they did not
+    // in this case.
+    //
+    // Therefore, implicit drops are injected up
+    // above, to ensure that the set of drop
+    // obligations match.
+
+    // After the implicit drops, the resulting
+    // remaining drop obligations are the
+    // following:
+
+    //                                  {              pDS.x, some_d}
+
+    // (... some code that does not change drop obligations ...)
+    mk_dd();
+
+    //                                  {              pDS.x, some_d}
+}
diff --git a/rfc03_fine.rs b/rfc03_fine.rs
new file mode 100644
index 0000000..c424d76
--- /dev/null
+++ b/rfc03_fine.rs
@@ -0,0 +1,106 @@
+#![feature(lang_items)]
+#![no_std]
+#![allow(dead_code)]
+#![allow(unused_variable)]
+#![allow(dead_assignment)]
+
+#![crate_type="lib"]
+
+#[lang="sized"] pub trait Sized { }
+#[lang="drop"] pub trait Drop { fn drop(&mut self); }
+pub enum Option<T> { None, Some(T), }
+
+// (PRELUDE ENDS ABOVE)
+
+struct Pair<X,Y>{ x:X, y:Y }
+
+struct D; struct S;
+
+impl Drop for D { fn drop(&mut self) { loop { } } }
+
+fn test() -> bool { loop { } }
+
+fn xform(d:D) -> D { loop { } }
+
+fn foo(mk_dd: || -> Pair<D,D>, mk_d: || -> D, consume: |D|) {
+    // At the outset, the set of drop obligations is
+    // just the set of moved input parameters (empty
+    // in this case).
+
+    //                                      DROP OBLIGATIONS
+    //                                  ------------------------
+    //                                  {  }
+    let mut pDD : Pair<D,D> = mk_dd();
+    //                                  {         pDD.x, pDD.y }
+    'a: loop {
+        // MERGE POINT: set of drop obligations must
+        // match on all incoming control-flow paths.
+
+        //                                  {     pDD.x, pDD.y }
+        if test() {
+            //                                  { pDD.x, pDD.y }
+            consume(pDD.x);
+            //                                  {        pDD.y }
+            break 'a;
+        }
+
+        //                                  {     pDD.x, pDD.y }
+
+        // *not* merge point (only one path flows here)
+
+        // never falls through; must merge with 'a loop.
+    }
+
+    // RESUME POINT: break 'a above flows here
+
+    //                                  {                pDD.y }
+
+    'b: loop {
+        // MERGE POINT: set of drop obligations must match on all
+        // incoming control-flow paths.
+        //
+        // There are *three* such incoming paths: (1.) the statement
+        // preceding `'b: loop`, (2.) the `continue 'b;` below, and
+        // (3.) the loop end below.
+
+        //                                  {            pDD.y }
+
+        consume(pDD.y);
+
+        //                                  {                  }
+
+        if test() {
+            //                                  {              }
+            pDD.x = mk_d();
+            //                                  {  pDD.x       }
+            break 'b;
+        }
+
+        // *not* merge point (only one path flows here)
+
+        //                                  {                  }
+
+        if test() {
+            //                                  {              }
+            pDD.y = mk_d();
+            //                                  {        pDD.y }
+            continue 'b;
+        }
+        // *not* merge point (only one path flows here)
+
+        //                                  {                  }
+
+        pDD.y = mk_d();
+
+        //                                  {            pDD.y }
+    }
+
+    // RESUME POINT: break 'b above flows here
+
+    //                                  {         pDD.x        }
+
+    // (... some code that does not change drop obligations ...)
+    mk_dd();
+
+    //                                  {               pDD.y }
+}
diff --git a/rfc03_warn.rs b/rfc03_warn.rs
new file mode 100644
index 0000000..71467d0
--- /dev/null
+++ b/rfc03_warn.rs
@@ -0,0 +1,106 @@
+#![feature(lang_items)]
+#![no_std]
+#![allow(dead_code)]
+#![allow(unused_variable)]
+#![allow(dead_assignment)]
+
+#![crate_type="lib"]
+
+#[lang="sized"] pub trait Sized { }
+#[lang="drop"] pub trait Drop { fn drop(&mut self); }
+pub enum Option<T> { None, Some(T), }
+
+// (PRELUDE ENDS ABOVE)
+
+struct Pair<X,Y>{ x:X, y:Y }
+
+struct D; struct S;
+
+impl Drop for D { fn drop(&mut self) { loop { } } }
+
+fn test() -> bool { loop { } }
+
+fn xform(d:D) -> D { loop { } }
+
+fn foo(mk_dd: || -> Pair<D,D>, mk_d: || -> D, consume: |D|) {
+    // At the outset, the set of drop obligations is
+    // just the set of moved input parameters (empty
+    // in this case).
+
+    //                                      DROP OBLIGATIONS
+    //                                  ------------------------
+    //                                  {  }
+    let mut pDD : Pair<D,D> = mk_dd();
+    //                                  {         pDD.x, pDD.y }
+    'a: loop {
+        // MERGE POINT: set of drop obligations must
+        // match on all incoming control-flow paths.
+
+        //                                  {     pDD.x, pDD.y }
+        if test() {
+            //                                  { pDD.x, pDD.y }
+            consume(pDD.x);
+            //                                  {        pDD.y }
+            break 'a;
+        }
+
+        //                                  {     pDD.x, pDD.y }
+
+        // *not* merge point (only one path flows here)
+
+        // never falls through; must merge with 'a loop.
+    }
+
+    // RESUME POINT: break 'a above flows here
+
+    //                                  {                pDD.y }
+
+    'b: loop {
+        // MERGE POINT: set of drop obligations must match on all
+        // incoming control-flow paths.
+        //
+        // There are *three* such incoming paths: (1.) the statement
+        // preceding `'b: loop`, (2.) the `continue 'b;` below, and
+        // (3.) the loop end below.
+
+        //                                  {            pDD.y }
+
+        consume(pDD.y);
+
+        //                                  {                  }
+
+        if test() {
+            //                                  {              }
+            pDD.y = mk_d();
+            //                                  {        pDD.y }
+            break 'b;
+        }
+
+        // *not* merge point (only one path flows here)
+
+        //                                  {                  }
+
+        if test() {
+            //                                  {              }
+            pDD.y = mk_d();
+            //                                  {        pDD.y }
+            continue 'b;
+        }
+        // *not* merge point (only one path flows here)
+
+        //                                  {                  }
+
+        pDD.y = mk_d();
+
+        //                                  {            pDD.y }
+    }
+
+    // RESUME POINT: break 'b above flows here
+
+    //                                  {               pDD.y }
+
+    // (... some code that does not change drop obligations ...)
+    mk_dd();
+
+    //                                  {               pDD.y }
+}
diff --git a/rfc04_fine.rs b/rfc04_fine.rs
new file mode 100644
index 0000000..71467d0
--- /dev/null
+++ b/rfc04_fine.rs
@@ -0,0 +1,106 @@
+#![feature(lang_items)]
+#![no_std]
+#![allow(dead_code)]
+#![allow(unused_variable)]
+#![allow(dead_assignment)]
+
+#![crate_type="lib"]
+
+#[lang="sized"] pub trait Sized { }
+#[lang="drop"] pub trait Drop { fn drop(&mut self); }
+pub enum Option<T> { None, Some(T), }
+
+// (PRELUDE ENDS ABOVE)
+
+struct Pair<X,Y>{ x:X, y:Y }
+
+struct D; struct S;
+
+impl Drop for D { fn drop(&mut self) { loop { } } }
+
+fn test() -> bool { loop { } }
+
+fn xform(d:D) -> D { loop { } }
+
+fn foo(mk_dd: || -> Pair<D,D>, mk_d: || -> D, consume: |D|) {
+    // At the outset, the set of drop obligations is
+    // just the set of moved input parameters (empty
+    // in this case).
+
+    //                                      DROP OBLIGATIONS
+    //                                  ------------------------
+    //                                  {  }
+    let mut pDD : Pair<D,D> = mk_dd();
+    //                                  {         pDD.x, pDD.y }
+    'a: loop {
+        // MERGE POINT: set of drop obligations must
+        // match on all incoming control-flow paths.
+
+        //                                  {     pDD.x, pDD.y }
+        if test() {
+            //                                  { pDD.x, pDD.y }
+            consume(pDD.x);
+            //                                  {        pDD.y }
+            break 'a;
+        }
+
+        //                                  {     pDD.x, pDD.y }
+
+        // *not* merge point (only one path flows here)
+
+        // never falls through; must merge with 'a loop.
+    }
+
+    // RESUME POINT: break 'a above flows here
+
+    //                                  {                pDD.y }
+
+    'b: loop {
+        // MERGE POINT: set of drop obligations must match on all
+        // incoming control-flow paths.
+        //
+        // There are *three* such incoming paths: (1.) the statement
+        // preceding `'b: loop`, (2.) the `continue 'b;` below, and
+        // (3.) the loop end below.
+
+        //                                  {            pDD.y }
+
+        consume(pDD.y);
+
+        //                                  {                  }
+
+        if test() {
+            //                                  {              }
+            pDD.y = mk_d();
+            //                                  {        pDD.y }
+            break 'b;
+        }
+
+        // *not* merge point (only one path flows here)
+
+        //                                  {                  }
+
+        if test() {
+            //                                  {              }
+            pDD.y = mk_d();
+            //                                  {        pDD.y }
+            continue 'b;
+        }
+        // *not* merge point (only one path flows here)
+
+        //                                  {                  }
+
+        pDD.y = mk_d();
+
+        //                                  {            pDD.y }
+    }
+
+    // RESUME POINT: break 'b above flows here
+
+    //                                  {               pDD.y }
+
+    // (... some code that does not change drop obligations ...)
+    mk_dd();
+
+    //                                  {               pDD.y }
+}
diff --git a/rfc04_warn.rs b/rfc04_warn.rs
new file mode 100644
index 0000000..7c3040a
--- /dev/null
+++ b/rfc04_warn.rs
@@ -0,0 +1,70 @@
+#![feature(lang_items)]
+#![no_std]
+#![allow(dead_code)]
+#![allow(unused_variable)]
+#![allow(dead_assignment)]
+
+#![crate_type="lib"]
+
+#[lang="sized"] pub trait Sized { }
+#[lang="drop"] pub trait Drop { fn drop(&mut self); }
+pub enum Option<T> { None, Some(T), }
+
+// (PRELUDE ENDS ABOVE)
+
+struct Pair<X,Y>{ x:X, y:Y }
+
+struct D; struct S;
+
+impl Drop for D { fn drop(&mut self) { loop { } } }
+
+fn test() -> bool { loop { } }
+
+fn xform(d:D) -> D { loop { } }
+
+fn foo(mk_dd: || -> Pair<D,D>, mk_d: || -> D, consume: |D|) {
+    // At the outset, the set of drop obligations is
+    // just the set of moved input parameters (empty
+    // in this case).
+
+    //                                      DROP OBLIGATIONS
+    //                                  ------------------------
+    //                                  {  }
+    let mut pDD : Pair<D,D> = mk_dd();
+    //                                  {         pDD.x, pDD.y }
+    'a: loop {
+        // MERGE POINT: set of drop obligations must
+        // match on all incoming control-flow paths.
+
+        //                                  {     pDD.x, pDD.y }
+        if test() {
+            //                                  { pDD.x, pDD.y }
+            consume(pDD.x);
+            //                                  {        pDD.y }
+            break 'a;
+        }
+
+        //                                  {     pDD.x, pDD.y }
+
+        // *not* merge point (only one path flows here)
+
+        if test() {
+            //                                  { pDD.x, pDD.y }
+            break 'a;
+        }
+
+        // never falls through; must merge with 'a loop.
+    }
+
+    // MERGE POINT: both `break 'a;` statements above flow here ...
+    //
+    // ... and their drop obligations do not match, so we get a
+    // warning here.
+
+    //                                  {                pDD.y }
+
+    // (... some code that does not change drop obligations ...)
+    mk_dd();
+
+    //                                  {               pDD.y }
+}
diff --git a/rfc05_deny.rs b/rfc05_deny.rs
new file mode 100644
index 0000000..a1a79615
--- /dev/null
+++ b/rfc05_deny.rs
@@ -0,0 +1,30 @@
+#![feature(lang_items)]
+#![no_std]
+#![allow(dead_code)]
+#![allow(unused_variable)]
+#![allow(dead_assignment)]
+
+#![crate_type="lib"]
+
+#[lang="sized"] pub trait Sized { }
+#[lang="drop"] pub trait Drop { fn drop(&mut self); }
+pub enum Option<T> { None, Some(T), }
+
+// (PRELUDE ENDS ABOVE)
+
+pub enum Pairy<X> { Two(X,X), One(X,X) }
+pub fn foo<A>(c: || -> Pairy<A>,
+              dA: |A| -> i8,
+              dR: |&A| -> i8) -> i8 {
+    let s = c();
+    let ret = match s {
+        Two(ref r1, ref r2) => {
+            dR(r1) + dR(r2)
+        }
+        One(a1, a2) => {
+            dA(a1) + dA(a2)
+        }
+    };
+    c();
+    ret
+}
diff --git a/rfc06_fine.rs b/rfc06_fine.rs
new file mode 100644
index 0000000..6158786
--- /dev/null
+++ b/rfc06_fine.rs
@@ -0,0 +1,31 @@
+#![feature(lang_items)]
+#![no_std]
+#![allow(dead_code)]
+#![allow(unused_variable)]
+#![allow(dead_assignment)]
+
+#![crate_type="lib"]
+
+#[lang="sized"] pub trait Sized { }
+#[lang="drop"] pub trait Drop { fn drop(&mut self); }
+pub enum Option<T> { None, Some(T), }
+
+// (PRELUDE ENDS ABOVE)
+
+pub enum Pairy<X> { Two(X,X), One(X,X) }
+pub fn foo<A>(c: || -> Pairy<A>,
+              dA: |A| -> i8,
+              dR: |&A| -> i8,
+              dS: |Pairy<A>| -> i8) -> i8 {
+    let s = c();
+    let ret = match s {
+        One(a1, a2) => {
+            dA(a1) + dA(a2)
+        }
+        Two(_, _) => {
+            dS(s)
+        }
+    };
+    c();
+    ret
+}
diff --git a/rfc07_fine.rs b/rfc07_fine.rs
new file mode 100644
index 0000000..61d160f
--- /dev/null
+++ b/rfc07_fine.rs
@@ -0,0 +1,48 @@
+#![feature(lang_items)]
+#![no_std]
+#![allow(dead_code)]
+#![allow(unused_variable)]
+#![allow(dead_assignment)]
+
+#![crate_type="lib"]
+
+#[lang="sized"] pub trait Sized { }
+#[lang="drop"] pub trait Drop { fn drop(&mut self); }
+pub enum Option<T> { None, Some(T), }
+
+// (PRELUDE ENDS ABOVE)
+
+pub struct D;
+impl Drop for D { fn drop(&mut self) { } }
+
+pub fn foo(b: || -> bool, c: || -> D, f: |D| -> i8) -> i8 {
+
+    //                                      DROP OBLIGATIONS
+    //                                  ------------------------
+    //                                  {       }
+
+    let x = c();
+    //                                  {     x }
+    let y = c();
+    //                                  {     x, y }
+
+    if b() {
+        //                                  { x, y }
+        let ret = f(x);
+        //                                  {    y }
+        return ret; // emits code to drop `y`
+    }
+    // *not* merge point (only one path, the else branch, flows here)
+
+    //                                  {     x, y }
+    if b() {
+        //                                  { x, y }
+        let ret = f(y);
+        //                                  { x    }
+        return ret; // emits code to drop `x`
+    }
+
+    //                                  {     x, y }
+
+    return 0; // emits code to drop `x` and `y`
+}

commit 040f4fd0ec5e21faec63ec910756a9472b7692dd
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Tue Sep 9 20:46:22 2014 +0200

    checkpoint compiler changes for check_drops.
    
    I no longer remember which of these changes were necessary in the end;
    its possible all of them were, though I strongly suspect that the
    `ty.rs` changes are totally irrelevant.
---
 src/librustc/middle/borrowck/check_drops.rs | 139 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++----------------
 src/librustc/middle/ty.rs                   |  50 +++++++++++++++++++++++++++++++++++++---
 src/librustc/middle/typeck/coherence.rs     |  53 +++++++++++++++++++++++++++++++++++++++++-
 3 files changed, 218 insertions(+), 24 deletions(-)

diff --git a/src/librustc/middle/borrowck/check_drops.rs b/src/librustc/middle/borrowck/check_drops.rs
index 3f207e4..fe3e774 100644
--- a/src/librustc/middle/borrowck/check_drops.rs
+++ b/src/librustc/middle/borrowck/check_drops.rs
@@ -256,7 +256,7 @@ pub fn check_drops(bccx: &BorrowckCtxt,
                     // Check if type of `lp` has #[quiet_early_drop]
                     // attribute or implements `QuietEarlyDrop`;
                     // select the appropriate lint to signal.
-                    let lint_category = if is_quiet_early_drop(bccx.tcx, &param_env, &**lp) {
+                    let lint_category = if is_quiet_early_drop_lp(bccx.tcx, &param_env, &**lp) {
                         lint::builtin::QUIET_EARLY_DROP
                     } else {
                         lint::builtin::UNMARKED_EARLY_DROP
@@ -462,10 +462,19 @@ fn scan_forward_for_kill_id(bccx: &BorrowckCtxt,
     }
 }
 
-fn is_quiet_early_drop(tcx: &ty::ctxt,
-                       param_env: &ty::ParameterEnvironment,
-                       lp: &LoanPath) -> bool {
+fn is_quiet_early_drop_lp(tcx: &ty::ctxt,
+                          param_env: &ty::ParameterEnvironment,
+                          lp: &LoanPath) -> bool {
     let t = lp.to_type(tcx);
+    let ret = is_quiet_early_drop_ty(tcx, param_env, t);
+    debug!("is_quiet_early_drop_lp: {} is {}", lp.repr(tcx), ret);
+    ret
+}
+
+
+fn is_quiet_early_drop_ty(tcx: &ty::ctxt,
+                          param_env: &ty::ParameterEnvironment,
+                          t: ty::t) -> bool {
     match ty::get(t).sty {
         ty::ty_struct(did, _) |
         ty::ty_enum(did, _) => {
@@ -481,23 +490,11 @@ fn is_quiet_early_drop(tcx: &ty::ctxt,
                 return true;
             }
         }
-        ty::ty_closure(ref f) => {
-            match f.store {
-                // by-ref closure
-                ty::RegionTraitStore(..) => return true,
-                ty::UniqTraitStore => {}
-            }
-        }
-        ty::ty_unboxed_closure(_) => {}
         _ => {}
     }
 
     // Okay, so far we know that the type does not have the
-    // `quiet_early_drop` attribute marker, nor is it a by-ref
-    // closure.
-    //
-    // But still, it could implement the `QuietEarlyDrop` trait.
-    // Let's find out.
+    // `quiet_early_drop` attribute marker.
 
     let opt_trait_did = tcx.lang_items.require(QuietEarlyDropTraitLangItem);
     let trait_did = match opt_trait_did {
@@ -508,10 +505,112 @@ fn is_quiet_early_drop(tcx: &ty::ctxt,
             return false;
         }
     };
+    is_quiet_early_drop_ty_recur(tcx, param_env, trait_did, t)
+}
 
-    let ret = type_implements_trait(tcx, param_env, t, trait_did);
-    debug!("is_quiet_early_drop: type_implements_trait is {}", ret);
-    ret
+fn is_quiet_early_drop_ty_recur(tcx: &ty::ctxt,
+                                param_env: &ty::ParameterEnvironment,
+                                trait_did: ast::DefId,
+                                t: ty::t) -> bool {
+
+    // The main base case: if the type implements `QuietEarlyDrop`,
+    // then we stop looking.
+    let implements = type_implements_trait(tcx, param_env, t, trait_did);
+    debug!("is_quiet_early_drop_ty_recur: type_implements_trait({}) is {}",
+           t.repr(tcx), implements);
+    if implements {
+        return true;
+    }
+
+    // If it does not implement the QuietEarlyDrop trait, then we need
+    // to emulate the traversal done by `type_contents`, looking at
+    // the substructure of the type to see if the type (or any part of
+    // it) "drops loudly", i.e., implements Drop but does not
+    // implement QuietEarlyDrop.
+
+    let drops_quiet = || {
+        let ret = true;
+        debug!("is_quiet_early_drop_ty_recur: {} fallthru base case: {}", t.repr(tcx), ret);
+        ret
+    };
+
+    let drops_loud = || {
+        let ret = false;
+        debug!("is_quiet_early_drop_ty_recur: {} fallthru base case: {}", t.repr(tcx), ret);
+        ret
+    };
+
+    let drops_recur = |f:|| -> bool| {
+        debug!("is_quiet_early_drop_ty_recur: {} fallthru recur entry", t.repr(tcx));
+        let ret = f();
+        debug!("is_quiet_early_drop_ty_recur: {} fallthru recur ret: {}", t.repr(tcx), ret);
+        ret
+    };
+
+    let recur = |ty| is_quiet_early_drop_ty_recur(tcx, param_env, trait_did, ty);
+
+    match ty::get(t).sty {
+        ty::ty_nil |
+        ty::ty_bot |
+        ty::ty_bool |
+        ty::ty_char |
+        ty::ty_int(_) |
+        ty::ty_uint(_) |
+        ty::ty_float(_) |
+        ty::ty_str |
+        ty::ty_bare_fn(_) |
+        ty::ty_rptr(_, _) |
+        ty::ty_err => drops_quiet(),
+
+        ty::ty_box(_) |
+        ty::ty_uniq(_) |
+        ty::ty_ptr(_) |
+        ty::ty_infer(_) |
+        ty::ty_unboxed_closure(_) => drops_loud(),
+
+        ty::ty_param(_) => drops_loud(),
+
+        ty::ty_trait(_) => drops_loud(),
+
+        ty::ty_closure(ref f) => {
+            match f.store {
+                // by-ref closure
+                ty::RegionTraitStore(..) => drops_quiet(),
+                ty::UniqTraitStore => drops_loud(),
+            }
+        }
+
+        // (Below are all the potentially recursive cases)
+
+        ty::ty_tup(ref tys) => drops_recur(|| tys.iter().all(|&ty| recur(ty))),
+        ty::ty_vec(mt, opt_len) => drops_recur(|| recur(mt.ty)),
+
+        ty::ty_enum(def_id, ref substs) => {
+            // if this type *itself* has a dtor, but does not
+            // implment `QuietEarlyDrop`, then it must drop loudly.
+            if ty::has_dtor(tcx, def_id) {
+                drops_loud()
+            } else {
+                let variants = ty::substd_enum_variants(tcx, def_id, substs);
+                drops_recur(|| variants.iter()
+                            .flat_map(|v| v.args.iter())
+                            .all(|&ty| recur(ty)))
+            }
+        }
+
+        ty::ty_struct(def_id, ref substs) => {
+            // if this type *itself* has a dtor, but does not
+            // implment `QuietEarlyDrop`, then it must drop loudly.
+            if ty::has_dtor(tcx, def_id) {
+                drops_loud()
+            } else {
+                drops_recur(|| ty::struct_fields(tcx, def_id, substs).iter()
+                            .map(|field| field.mt.ty)
+                            .all(|ty| recur(ty)))
+            }
+        }
+
+    }
 }
 
 fn with_attrs_for_did<A>(tcx: &ty::ctxt,
diff --git a/src/librustc/middle/ty.rs b/src/librustc/middle/ty.rs
index e79fec9..3173a87 100644
--- a/src/librustc/middle/ty.rs
+++ b/src/librustc/middle/ty.rs
@@ -491,6 +491,13 @@ pub struct ctxt<'tcx> {
     /// populated during the coherence phase of typechecking.
     pub destructor_for_type: RefCell<DefIdMap<ast::DefId>>,
 
+    /// A mapping from the def ID of an enum or struct type to the def
+    /// ID of its impl of QuietEarlyDrop, if present (flagging any
+    /// associated drop-glue as "pure"/"quiet"). This map is populated
+    /// during the coherence phase of typechecking.
+    pub quiet_dtor_for_type: RefCell<DefIdMap<ast::DefId>>,
+    pub quiet_dtor_for_ty_box: Cell<Option<ast::DefId>>,
+
     /// A method will be in this list if and only if it is a destructor.
     pub destructors: RefCell<DefIdSet>,
 
@@ -1423,6 +1430,8 @@ pub fn mk_ctxt<'tcx>(s: Session,
         superstructs: RefCell::new(DefIdMap::new()),
         struct_fields: RefCell::new(DefIdMap::new()),
         destructor_for_type: RefCell::new(DefIdMap::new()),
+        quiet_dtor_for_type: RefCell::new(DefIdMap::new()),
+        quiet_dtor_for_ty_box: Cell::new(None),
         destructors: RefCell::new(DefIdSet::new()),
         trait_impls: RefCell::new(DefIdMap::new()),
         inherent_impls: RefCell::new(DefIdMap::new()),
@@ -2154,6 +2163,7 @@ def_type_content_sets!(
         OwnsDtor                            = 0b0000_0000__0000_0010__0000,
         OwnsManaged /* see [1] below */     = 0b0000_0000__0000_0100__0000,
         OwnsAffine                          = 0b0000_0000__0000_1000__0000,
+        OwnsLoudDtor                        = 0b0000_0000__0001_0000__0000,
         OwnsAll                             = 0b0000_0000__1111_1111__0000,
 
         // Things that are reachable by the value in any way (fourth nibble):
@@ -2303,6 +2313,23 @@ impl TypeContents {
     pub fn has_dtor(&self) -> bool {
         self.intersects(TC::OwnsDtor)
     }
+
+    // A "loud" destructor is one that has effects that we think the user may care about,
+    // e.g. releasing locks, flushing buffers, etc.
+    // It is the default setting for implementations of Drop.
+    pub fn has_loud_dtor(&self) -> bool {
+        self.intersects(TC::OwnsDtor) &&
+            self.intersects(TC::OwnsLoudDtor)
+    }
+
+    // A "quiet" destructor is one that has no "significant" effects;
+    // e.g. a destructor that just frees memory it owns is considered
+    // quiet.  One opts into this by implementing the QuietEarlyDrop
+    // trait.
+    pub fn has_quiet_dtor(&self) -> bool {
+        self.intersects(TC::OwnsDtor) &&
+            !self.intersects(TC::OwnsLoudDtor)
+    }
 }
 
 impl ops::BitOr<TypeContents,TypeContents> for TypeContents {
@@ -2404,7 +2431,11 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {
             }
 
             ty_box(typ) => {
-                tc_ty(cx, typ, cache).managed_pointer() | TC::ReachesFfiUnsafe
+                let mut ret = tc_ty(cx, typ, cache).managed_pointer() | TC::ReachesFfiUnsafe
+                if cx.quiet_dtor_for_ty_box.get().is_some() {
+                    ret = ret - TC::OwnsLoudDtor
+                }
+                ret
             }
 
             ty_uniq(typ) => {
@@ -2450,7 +2481,11 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {
                 }
 
                 if ty::has_dtor(cx, did) {
-                    res = res | TC::OwnsDtor;
+                    res = res | TC::OwnsDtor | TC::OwnsLoudDtor;
+                }
+                // Note that a type can impl QuietEarlyDrop even if it does not directly impl Drop
+                if ty::has_quiet_dtor(cx, did) {
+                    res = res - TC::OwnsLoudDtor;
                 }
                 apply_lang_items(cx, did, res)
             }
@@ -2480,7 +2515,11 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {
                     });
 
                 if ty::has_dtor(cx, did) {
-                    res = res | TC::OwnsDtor;
+                    res = res | TC::OwnsDtor | TC::OwnsLoudDtor;
+                }
+                // Note that a type can impl QuietEarlyDrop even if it does not directly impl Drop
+                if ty::has_quiet_dtor(cx, did) {
+                    res = res - TC::OwnsLoudDtor;
                 }
 
                 if variants.len() != 0 {
@@ -4309,6 +4348,11 @@ pub fn has_dtor(cx: &ctxt, struct_id: DefId) -> bool {
     ty_dtor(cx, struct_id).is_present()
 }
 
+/* Return true iff struct_id names a struct that implements QuietEarlyDrop. */
+fn has_quiet_dtor(cx: &ctxt, struct_id: DefId) -> bool {
+    cx.quiet_dtor_for_type.borrow().find(&struct_id).is_some()
+}
+
 pub fn with_path<T>(cx: &ctxt, id: ast::DefId, f: |ast_map::PathElems| -> T) -> T {
     if id.krate == ast::LOCAL_CRATE {
         cx.map.with_path(id.node, f)
diff --git a/src/librustc/middle/typeck/coherence.rs b/src/librustc/middle/typeck/coherence.rs
index 2c6dc94..ce607db 100644
--- a/src/librustc/middle/typeck/coherence.rs
+++ b/src/librustc/middle/typeck/coherence.rs
@@ -690,8 +690,12 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {
     //
     // Destructors
     //
-
     fn populate_destructor_table(&self) {
+        self.populate_destructor_table_for_drop();
+        self.populate_destructor_table_for_quiet_early_drop();
+    }
+
+    fn populate_destructor_table_for_drop(&self) {
         let tcx = self.crate_context.tcx;
         let drop_trait = match tcx.lang_items.drop_trait() {
             Some(id) => id, None => { return }
@@ -746,6 +750,53 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {
             }
         }
     }
+
+    fn populate_destructor_table_for_quiet_early_drop(&self) {
+        let tcx = self.crate_context.tcx;
+        let quiet_early_drop_trait = match tcx.lang_items.quiet_early_drop() {
+            Some(id) => id, None => { return }
+        };
+
+        let trait_impls = match tcx.trait_impls.borrow().find_copy(&quiet_early_drop_trait) {
+            None => return, // No types with (new-style) dtors present.
+            Some(found_impls) => found_impls
+        };
+
+        for &impl_did in trait_impls.borrow().iter() {
+            let self_type = self.get_self_type_for_implementation(impl_did);
+            match ty::get(self_type.ty).sty {
+                ty::ty_enum(type_def_id, _) |
+                ty::ty_struct(type_def_id, _) |
+                ty::ty_unboxed_closure(type_def_id) => {
+                    tcx.quiet_dtor_for_type.borrow_mut().insert(type_def_id, impl_did);
+                }
+                ty::ty_box(..) => {
+                    assert!(tcx.quiet_dtor_for_ty_box.get().is_none());
+                    tcx.quiet_dtor_for_ty_box.set(Some(impl_did));
+                }
+                _ => {
+                    // Destructors only work on nominal types.
+                    if impl_did.krate == ast::LOCAL_CRATE {
+                        {
+                            match tcx.map.find(impl_did.node) {
+                                Some(ast_map::NodeItem(item)) => {
+                                    span_err!(tcx.sess, item.span, E0158,
+                                        "the QuietEarlyDrop trait may only be implemented on structures");
+                                }
+                                _ => {
+                                    tcx.sess.bug("didn't find impl in ast \
+                                                  map");
+                                }
+                            }
+                        }
+                    } else {
+                        tcx.sess.bug("found external impl of QuietEarlyDrop trait on \
+                                      something other than a struct");
+                    }
+                }
+            }
+        }
+    }
 }
 
 pub fn make_substs_for_receiver_types(tcx: &ty::ctxt,

commit 4b2bb1f0b1e17d546aebb0188c8f8ffac9cb7c85
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Tue Sep 9 19:50:20 2014 +0200

    Add and remove various QuietEarlyDrop traits in the libs.
---
 src/libcollections/string.rs | 3 ---
 src/libcore/cell.rs          | 6 +++++-
 src/libcore/num/mod.rs       | 2 --
 src/librustc/diagnostics.rs  | 3 ++-
 src/libstd/gc.rs             | 5 ++++-
 src/libsyntax/parse/token.rs | 1 -
 6 files changed, 11 insertions(+), 9 deletions(-)

diff --git a/src/libcollections/string.rs b/src/libcollections/string.rs
index a93fa41..05d91a7 100644
--- a/src/libcollections/string.rs
+++ b/src/libcollections/string.rs
@@ -17,7 +17,6 @@ use core::prelude::*;
 use core::default::Default;
 use core::fmt;
 use core::mem;
-use core::ops::QuietEarlyDrop;
 use core::ptr;
 // FIXME: ICE's abound if you import the `Slice` type while importing `Slice` trait
 use core::raw::Slice as RawSlice;
@@ -35,8 +34,6 @@ pub struct String {
     vec: Vec<u8>,
 }
 
-impl QuietEarlyDrop for String {}
-
 impl String {
     /// Creates a new string buffer initialized with the empty string.
     ///
diff --git a/src/libcore/cell.rs b/src/libcore/cell.rs
index 1cad9a3..35fbe0c 100644
--- a/src/libcore/cell.rs
+++ b/src/libcore/cell.rs
@@ -158,7 +158,7 @@
 use clone::Clone;
 use cmp::PartialEq;
 use kinds::{marker, Copy};
-use ops::{Deref, DerefMut, Drop};
+use ops::{Deref, DerefMut, Drop, QuietEarlyDrop};
 use option::{None, Option, Some};
 
 /// A mutable memory location that admits only `Copy` data.
@@ -216,6 +216,8 @@ pub struct RefCell<T> {
     noshare: marker::NoSync,
 }
 
+impl<T:QuietEarlyDrop> QuietEarlyDrop for RefCell<T> { }
+
 // Values [1, MAX-1] represent the number of `Ref` active
 // (will not outgrow its range since `uint` is the size of the address space)
 type BorrowFlag = uint;
@@ -340,6 +342,8 @@ impl<'b, T> Drop for Ref<'b, T> {
     }
 }
 
+impl<'b,T:QuietEarlyDrop> QuietEarlyDrop for Ref<'b,T> { }
+
 #[unstable = "waiting for `Deref` to become stable"]
 impl<'b, T> Deref<T> for Ref<'b, T> {
     #[inline]
diff --git a/src/libcore/num/mod.rs b/src/libcore/num/mod.rs
index e73c857..f6c5ffd 100644
--- a/src/libcore/num/mod.rs
+++ b/src/libcore/num/mod.rs
@@ -24,7 +24,6 @@ use kinds::Copy;
 use mem::size_of;
 use ops::{Add, Sub, Mul, Div, Rem, Neg};
 use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr};
-use ops::QuietEarlyDrop;
 use option::{Option, Some, None};
 
 /// The base trait for numeric types
@@ -43,7 +42,6 @@ macro_rules! trait_impl(
 )
 
 trait_impl!(Num for uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)
-trait_impl!(QuietEarlyDrop for uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)
 
 /// Simultaneous division and remainder
 #[inline]
diff --git a/src/librustc/diagnostics.rs b/src/librustc/diagnostics.rs
index 079e01c..4167320 100644
--- a/src/librustc/diagnostics.rs
+++ b/src/librustc/diagnostics.rs
@@ -170,5 +170,6 @@ register_diagnostics!(
     E0158,
     E0159,
     E0160,
-    E0161
+    E0161,
+    E0162  // QuietEarlyDrop is only for struct/enum/unboxed-closures
 )
diff --git a/src/libstd/gc.rs b/src/libstd/gc.rs
index 3990aa4..71fa68f 100644
--- a/src/libstd/gc.rs
+++ b/src/libstd/gc.rs
@@ -46,7 +46,10 @@ impl<T> Clone for Gc<T> {
     fn clone(&self) -> Gc<T> { *self }
 }
 
-impl<T:QuietEarlyDrop> QuietEarlyDrop for Gc<T> { }
+// We do not require QuietEarlyDrop on T in this case, because the
+// assumption is that if you are using Gc<T>, then you are prepared
+// for the Drop to occur at any time.
+impl<T> QuietEarlyDrop for Gc<T> { }
 
 /// An value that represents the task-local managed heap.
 ///
diff --git a/src/libsyntax/parse/token.rs b/src/libsyntax/parse/token.rs
index e3c889e..cce14be 100644
--- a/src/libsyntax/parse/token.rs
+++ b/src/libsyntax/parse/token.rs
@@ -572,7 +572,6 @@ pub fn get_ident_interner() -> Rc<IdentInterner> {
 /// be fixed in the future by just leaking all strings until task death
 /// somehow.
 #[deriving(Clone, PartialEq, Hash, PartialOrd, Eq, Ord)]
-#[quiet_early_drop]
 pub struct InternedString {
     string: RcStr,
 }

commit 2cc30e30435db499a28633611a23b4315226cb97
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Mon Aug 18 20:40:33 2014 +0200

    root testsuite: test QED pass through on u8 through Vec to String.
---
 Makefile      |  2 +-
 foo51.rs      |  2 +-
 foo55_fine.rs | 33 +++++++++++++++++++++++++++++++++
 3 files changed, 35 insertions(+), 2 deletions(-)

diff --git a/Makefile b/Makefile
index 5a9fa69..c763391 100644
--- a/Makefile
+++ b/Makefile
@@ -15,7 +15,7 @@ FILES_FINE=              foo02_fine.rs
                          foo32_fine.rs foo33_fine.rs foo34_fine.rs               \
                          foo42_fine.rs               foo44_fine.rs               \
                          foo47_fine.rs               foo49_fine.rs               \
-                                       foo53_fine.rs foo54_fine.rs
+                                       foo53_fine.rs foo54_fine.rs foo55_fine.rs
 
 FILES_UNCATEGORIZED=                                                             \
            foo16.rs                                  foo19.rs      foo20.rs      \
diff --git a/foo51.rs b/foo51.rs
index 58dafb0..3a97597 100644
--- a/foo51.rs
+++ b/foo51.rs
@@ -15,7 +15,7 @@ use core::ptr;
 use core::result::{Result,Ok,Err};
 use collections::string::String;
 
-pub fn check_for_errors_in<T>(f: || -> T) -> Result<T, String> {
+pub fn foo<T>(f: || -> T) -> Result<T, String> {
     use rustrt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};
     static mut lock: StaticNativeMutex = NATIVE_MUTEX_INIT;
     unsafe {
diff --git a/foo55_fine.rs b/foo55_fine.rs
new file mode 100644
index 0000000..bf762d0
--- /dev/null
+++ b/foo55_fine.rs
@@ -0,0 +1,33 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+// reduced version of foo51.rs
+#[lang="sized"] pub trait Sized { }
+
+#[lang="quiet_early_drop"]
+pub trait QuietEarlyDrop { }
+
+
+pub struct Vec<T> {
+    _len: uint,
+    _cap: uint,
+    _ptr: *mut T
+}
+
+impl<T:QuietEarlyDrop> QuietEarlyDrop for Vec<T> {}
+
+pub struct String {
+    _vec: Vec<u8>,
+}
+
+pub fn foo<T>(b: || -> bool, f: || -> String, g: || -> T) -> T {
+    let ret = if b() {
+        let _s = f();
+        g()
+    } else {
+        g()
+    };
+    f();
+    ret
+}

commit 4c3517ce2dde6737eb9ad45ad12c28f18e454389
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Thu Aug 14 15:09:15 2014 +0200

    root testsuite: fix test to not emit warning when it compiles successfully.
---
 foo54_fine.rs | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/foo54_fine.rs b/foo54_fine.rs
index 7bf3bc2..7da7a37 100644
--- a/foo54_fine.rs
+++ b/foo54_fine.rs
@@ -18,6 +18,6 @@ impl Float for f32 {
     fn neg_infinity() -> f32 { NEG_INFINITY }
 }
 
-fn foo(s: f32) -> bool {
+pub fn foo(s: f32) -> bool {
     s == Float::infinity() || s == Float::neg_infinity()
 }

commit c8da0b226454e161a62f201268008dabbd6df388
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Thu Aug 14 15:08:11 2014 +0200

    rust-needsdrop: bug fix: ty only impls trait if lookup was non-err and actually carries a vtable.
---
 src/librustc/middle/borrowck/check_drops.rs | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/src/librustc/middle/borrowck/check_drops.rs b/src/librustc/middle/borrowck/check_drops.rs
index 78d7801..3f207e4 100644
--- a/src/librustc/middle/borrowck/check_drops.rs
+++ b/src/librustc/middle/borrowck/check_drops.rs
@@ -571,5 +571,8 @@ fn type_implements_trait(tcx: &ty::ctxt,
         if_missing_ty_param: check::vtable::IfMissingTyParamGiveUp,
     };
 
-    return lookup_vtable(&vcx, span, ty, trait_ref).is_ok();
+    match lookup_vtable(&vcx, span, ty, trait_ref) {
+        Ok(Some(_)) => true,
+        Ok(None) | Err(_) => false,
+    }
 }

commit 8031be4604e6ddc4ae2ef45c91d5dc952de8abb6
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Tue Aug 12 13:16:10 2014 +0200

    lib-needsdrop: make Result propagate QuietEarlyDrop.
---
 src/libcore/result.rs | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/libcore/result.rs b/src/libcore/result.rs
index bf351ec..c672564 100644
--- a/src/libcore/result.rs
+++ b/src/libcore/result.rs
@@ -282,6 +282,7 @@ use std::fmt::Show;
 use slice;
 use slice::Slice;
 use iter::{Iterator, DoubleEndedIterator, FromIterator, ExactSize};
+use ops::QuietEarlyDrop;
 use option::{None, Option, Some};
 
 /// `Result` is a type that represents either success (`Ok`) or failure (`Err`).
@@ -298,6 +299,8 @@ pub enum Result<T, E> {
     Err(E)
 }
 
+impl<T:QuietEarlyDrop,E:QuietEarlyDrop> QuietEarlyDrop for Result<T,E> { }
+
 /////////////////////////////////////////////////////////////////////////////
 // Type implementation
 /////////////////////////////////////////////////////////////////////////////

commit e363435ac4815a05cc09db2ce41349992277b1b8
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Tue Aug 12 13:12:51 2014 +0200

    lib-needsdrop: Add Gc<T> and Rc<T> to set of things that propogate QuietEarlyDrop.
---
 src/liballoc/rc.rs | 4 +++-
 src/libstd/gc.rs   | 4 +++-
 2 files changed, 6 insertions(+), 2 deletions(-)

diff --git a/src/liballoc/rc.rs b/src/liballoc/rc.rs
index ec19844..f524834 100644
--- a/src/liballoc/rc.rs
+++ b/src/liballoc/rc.rs
@@ -154,7 +154,7 @@ use core::default::Default;
 use core::fmt;
 use core::kinds::marker;
 use core::mem::{transmute, min_align_of, size_of, forget};
-use core::ops::{Deref, Drop};
+use core::ops::{Deref, Drop, QuietEarlyDrop};
 use core::option::{Option, Some, None};
 use core::ptr;
 use core::ptr::RawPtr;
@@ -179,6 +179,8 @@ pub struct Rc<T> {
     _noshare: marker::NoSync
 }
 
+impl<T:QuietEarlyDrop> QuietEarlyDrop for Rc<T> { }
+
 #[stable]
 impl<T> Rc<T> {
     /// Constructs a new reference-counted pointer.
diff --git a/src/libstd/gc.rs b/src/libstd/gc.rs
index 47b7426..3990aa4 100644
--- a/src/libstd/gc.rs
+++ b/src/libstd/gc.rs
@@ -26,7 +26,7 @@ use fmt;
 use hash;
 use kinds::marker;
 use option::Option;
-use ops::Deref;
+use ops::{Deref, QuietEarlyDrop};
 use raw;
 
 /// Immutable garbage-collected pointer type
@@ -46,6 +46,8 @@ impl<T> Clone for Gc<T> {
     fn clone(&self) -> Gc<T> { *self }
 }
 
+impl<T:QuietEarlyDrop> QuietEarlyDrop for Gc<T> { }
+
 /// An value that represents the task-local managed heap.
 ///
 /// Use this like `let foo = box(GC) Bar::new(...);`

commit eb63e8e71a6a7ecd1c2ac8ce6379ffc555cbb95b
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Mon Aug 11 23:26:39 2014 +0200

    lib-needsdrop: QuietEarlyDrop clent hackery.
---
 src/libcollections/string.rs | 3 +++
 src/libcollections/vec.rs    | 3 +++
 src/libcore/num/mod.rs       | 2 ++
 src/libcore/option.rs        | 3 +++
 src/libstd/path/posix.rs     | 3 +++
 src/libstd/path/windows.rs   | 5 ++++-
 src/libsyntax/parse/token.rs | 1 +
 7 files changed, 19 insertions(+), 1 deletion(-)

diff --git a/src/libcollections/string.rs b/src/libcollections/string.rs
index 05d91a7..a93fa41 100644
--- a/src/libcollections/string.rs
+++ b/src/libcollections/string.rs
@@ -17,6 +17,7 @@ use core::prelude::*;
 use core::default::Default;
 use core::fmt;
 use core::mem;
+use core::ops::QuietEarlyDrop;
 use core::ptr;
 // FIXME: ICE's abound if you import the `Slice` type while importing `Slice` trait
 use core::raw::Slice as RawSlice;
@@ -34,6 +35,8 @@ pub struct String {
     vec: Vec<u8>,
 }
 
+impl QuietEarlyDrop for String {}
+
 impl String {
     /// Creates a new string buffer initialized with the empty string.
     ///
diff --git a/src/libcollections/vec.rs b/src/libcollections/vec.rs
index a7005cf..363b031 100644
--- a/src/libcollections/vec.rs
+++ b/src/libcollections/vec.rs
@@ -18,6 +18,7 @@ use core::default::Default;
 use core::fmt;
 use core::mem;
 use core::num;
+use core::ops::QuietEarlyDrop;
 use core::ptr;
 use core::raw::Slice as RawSlice;
 use core::uint;
@@ -1529,6 +1530,8 @@ impl<T: Clone, V: Slice<T>> Add<V, Vec<T>> for Vec<T> {
     }
 }
 
+impl<T:QuietEarlyDrop> QuietEarlyDrop for Vec<T> {}
+
 #[unsafe_destructor]
 impl<T> Drop for Vec<T> {
     fn drop(&mut self) {
diff --git a/src/libcore/num/mod.rs b/src/libcore/num/mod.rs
index f6c5ffd..e73c857 100644
--- a/src/libcore/num/mod.rs
+++ b/src/libcore/num/mod.rs
@@ -24,6 +24,7 @@ use kinds::Copy;
 use mem::size_of;
 use ops::{Add, Sub, Mul, Div, Rem, Neg};
 use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr};
+use ops::QuietEarlyDrop;
 use option::{Option, Some, None};
 
 /// The base trait for numeric types
@@ -42,6 +43,7 @@ macro_rules! trait_impl(
 )
 
 trait_impl!(Num for uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)
+trait_impl!(QuietEarlyDrop for uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)
 
 /// Simultaneous division and remainder
 #[inline]
diff --git a/src/libcore/option.rs b/src/libcore/option.rs
index 537d78a..b1e353c 100644
--- a/src/libcore/option.rs
+++ b/src/libcore/option.rs
@@ -148,6 +148,7 @@ use default::Default;
 use slice::Slice;
 use iter::{Iterator, DoubleEndedIterator, FromIterator, ExactSize};
 use mem;
+use ops::QuietEarlyDrop;
 use slice;
 
 // Note that this is not a lang item per se, but it has a hidden dependency on
@@ -165,6 +166,8 @@ pub enum Option<T> {
     Some(T)
 }
 
+impl<T:QuietEarlyDrop> QuietEarlyDrop for Option<T> {}
+
 /////////////////////////////////////////////////////////////////////////////
 // Type implementation
 /////////////////////////////////////////////////////////////////////////////
diff --git a/src/libstd/path/posix.rs b/src/libstd/path/posix.rs
index 06eab31..574dabe 100644
--- a/src/libstd/path/posix.rs
+++ b/src/libstd/path/posix.rs
@@ -18,6 +18,7 @@ use from_str::FromStr;
 use hash;
 use io::Writer;
 use iter::{DoubleEndedIterator, AdditiveIterator, Extendable, Iterator, Map};
+use ops::QuietEarlyDrop;
 use option::{Option, None, Some};
 use str::Str;
 use str;
@@ -41,6 +42,8 @@ pub struct Path {
     sepidx: Option<uint> // index of the final separator in repr
 }
 
+impl QuietEarlyDrop for Path {}
+
 /// The standard path separator character
 pub static SEP: char = '/';
 
diff --git a/src/libstd/path/windows.rs b/src/libstd/path/windows.rs
index d9864cf..ac9a676 100644
--- a/src/libstd/path/windows.rs
+++ b/src/libstd/path/windows.rs
@@ -22,6 +22,7 @@ use hash;
 use io::Writer;
 use iter::{AdditiveIterator, DoubleEndedIterator, Extendable, Iterator, Map};
 use mem;
+use ops::QuietEarlyDrop;
 use option::{Option, Some, None};
 use slice::{Slice, ImmutableSlice};
 use str::{CharSplits, Str, StrAllocating, StrVector, StrSlice};
@@ -83,6 +84,8 @@ pub struct Path {
     sepidx: Option<uint> // index of the final separator in the non-prefix portion of repr
 }
 
+impl QuietEarlyDrop for Path {}
+
 impl PartialEq for Path {
     #[inline]
     fn eq(&self, other: &Path) -> bool {
@@ -734,7 +737,7 @@ impl Path {
         };
         (prefix, match val {
             None => s.into_string(),
-            Some(val) => val
+            Some(val) => { mem::drop(s); val }
         })
     }
 
diff --git a/src/libsyntax/parse/token.rs b/src/libsyntax/parse/token.rs
index cce14be..e3c889e 100644
--- a/src/libsyntax/parse/token.rs
+++ b/src/libsyntax/parse/token.rs
@@ -572,6 +572,7 @@ pub fn get_ident_interner() -> Rc<IdentInterner> {
 /// be fixed in the future by just leaking all strings until task death
 /// somehow.
 #[deriving(Clone, PartialEq, Hash, PartialOrd, Eq, Ord)]
+#[quiet_early_drop]
 pub struct InternedString {
     string: RcStr,
 }

commit 928e988b249034a94a847ed7503d925c494d36b4
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Tue Aug 12 11:29:48 2014 +0200

    rust-needsdrop: more refactoring to vtable API.
---
 src/librustc/middle/typeck/check/method.rs |  9 ++++-----
 src/librustc/middle/typeck/check/mod.rs    |  9 +++++++--
 src/librustc/middle/typeck/check/vtable.rs | 10 +++-------
 3 files changed, 14 insertions(+), 14 deletions(-)

diff --git a/src/librustc/middle/typeck/check/method.rs b/src/librustc/middle/typeck/check/method.rs
index 827eed9..45be755 100644
--- a/src/librustc/middle/typeck/check/method.rs
+++ b/src/librustc/middle/typeck/check/method.rs
@@ -537,14 +537,14 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {
             return
         }
 
-        let vcx = self.fcx.vtable_context();
+        let infcx = self.fcx.infcx();
 
         // Get the tupled type of the arguments.
         let arguments_type = *closure_function_type.sig.inputs.get(0);
         let return_type = closure_function_type.sig.output;
 
         let closure_region =
-            vcx.infcx.next_region_var(infer::MiscVariable(self.span));
+            infcx.next_region_var(infer::MiscVariable(self.span));
         let unboxed_closure_type = ty::mk_unboxed_closure(self.tcx(),
                                                           closure_did,
                                                           closure_region);
@@ -554,7 +554,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {
             rcvr_substs: subst::Substs::new_trait(
                 vec![arguments_type, return_type],
                 vec![],
-                *vcx.infcx.next_ty_vars(1).get(0)),
+                *infcx.next_ty_vars(1).get(0)),
             method_ty: method,
             origin: MethodStaticUnboxedClosure(closure_did),
         });
@@ -816,11 +816,10 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {
         // determine the `self` of the impl with fresh
         // variables for each parameter:
         let span = self.self_expr.map_or(self.span, |e| e.span);
-        let vcx = self.fcx.vtable_context();
         let TypeAndSubsts {
             substs: impl_substs,
             ty: impl_ty
-        } = impl_self_ty(vcx.tcx(), vcx.infcx, span, impl_did);
+        } = impl_self_ty(self.tcx(), self.infcx(), span, impl_did);
 
         let candidates = if is_extension {
             &mut self.extension_candidates
diff --git a/src/librustc/middle/typeck/check/mod.rs b/src/librustc/middle/typeck/check/mod.rs
index 3f1fcbf..713506f 100644
--- a/src/librustc/middle/typeck/check/mod.rs
+++ b/src/librustc/middle/typeck/check/mod.rs
@@ -1581,15 +1581,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {
         self.ccx.tcx.sess.err_count() - self.err_count_on_creation
     }
 
-    pub fn vtable_context<'a>(&'a self) -> VtableContext<'a, 'tcx> {
+    pub fn vtable_context<'a>(&'a self, is_early: check::vtable::IsEarly) -> VtableContext<'a, 'tcx> {
         VtableContext {
             infcx: self.infcx(),
             param_bounds: &self.inh.param_env.bounds,
             unboxed_closures: &self.inh.unboxed_closures,
             if_missing_ty_param: check::vtable::IfMissingTyParamSearch,
-            is_early: check::vtable::NotEarly,
+            is_early: is_early,
         }
     }
+
+    pub fn vtable_context_is_early<'a>(&'a self, is_early: bool) -> VtableContext<'a> {
+        self.vtable_context(
+            if is_early { check::vtable::IsEarly } else { check::vtable::NotEarly })
+    }
 }
 
 impl<'a, 'tcx> RegionScope for infer::InferCtxt<'a, 'tcx> {
diff --git a/src/librustc/middle/typeck/check/vtable.rs b/src/librustc/middle/typeck/check/vtable.rs
index 92191af..2912b18 100644
--- a/src/librustc/middle/typeck/check/vtable.rs
+++ b/src/librustc/middle/typeck/check/vtable.rs
@@ -99,10 +99,6 @@ impl<'a, 'tcx> VtableContext<'a, 'tcx> {
             Err((span, msg)) => self.tcx().sess.span_fatal(span, msg.as_slice()),
         }
     }
-
-    pub fn make_early_vcx(&self, is_early: bool) -> VtableContext<'a> {
-        VtableContext { is_early: if is_early { IsEarly } else { NotEarly }, ..*self }
-    }
 }
 
 pub type ErrMsg = (Span, String);
@@ -824,7 +820,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {
                    fcx.infcx().ty_to_string(item_ty.ty));
             debug!("early_resolve_expr: looking up vtables for type params {}",
                    item_ty.generics.types.repr(fcx.tcx()));
-            let vcx = fcx.vtable_context().make_early_vcx(is_early);
+            let vcx = fcx.vtable_context_is_early(is_early);
             let vtbls = vcx.ok_or_die(
                 lookup_vtables(&vcx, ex.span,
                                &item_ty.generics.types,
@@ -850,7 +846,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {
               let type_param_defs =
                   ty::method_call_type_param_defs(fcx, method.origin);
               let substs = fcx.method_ty_substs(ex.id);
-              let vcx = fcx.vtable_context().make_early_vcx(is_early);
+              let vcx = fcx.vtable_context_is_early(is_early);
               let vtbls = vcx.ok_or_die(
                   lookup_vtables(&vcx, ex.span,
                                  &type_param_defs,
@@ -910,7 +906,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {
                                        ex.repr(fcx.tcx()));
                                 let type_param_defs =
                                     ty::method_call_type_param_defs(cx.tcx, method.origin);
-                                let vcx = fcx.vtable_context().make_early_vcx(is_early);
+                                let vcx = fcx.vtable_context_is_early(is_early);
                                 let vtbls = vcx.ok_or_die(
                                     lookup_vtables(&vcx, ex.span,
                                                    &type_param_defs,

commit 536394453e8f0d8ef12fcd3c68bfc48dd5f3757c
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Tue Aug 12 11:27:27 2014 +0200

    root testsuite: fixed foo54_fine.rs to conform with rules of these tests.
---
 foo54_fine.rs | 18 +++++++++---------
 1 file changed, 9 insertions(+), 9 deletions(-)

diff --git a/foo54_fine.rs b/foo54_fine.rs
index a90e44f..7bf3bc2 100644
--- a/foo54_fine.rs
+++ b/foo54_fine.rs
@@ -5,19 +5,19 @@
 #[lang="copy"]  pub trait Copy { }
 #[lang="sized"] pub trait Sized { }
 
-pub fn drop<T>(_x: T) { }
-
 pub trait Float {
     fn infinity() -> Self;
     fn neg_infinity() -> Self;
-    fn foo(self) -> bool;
 }
 
+pub static INFINITY: f32 = 1.0_f32/0.0_f32;
+pub static NEG_INFINITY: f32 = -1.0_f32/0.0_f32;
+
 impl Float for f32 {
-    #[inline]
-    fn foo(self) -> bool {
-        self == Float::infinity() || self == Float::neg_infinity()
-    }
-    fn infinity() -> f32 { loop { } }
-    fn neg_infinity() -> f32 { loop { } }
+    fn infinity() -> f32 { INFINITY }
+    fn neg_infinity() -> f32 { NEG_INFINITY }
+}
+
+fn foo(s: f32) -> bool {
+    s == Float::infinity() || s == Float::neg_infinity()
 }

commit 27e60799bc9570945d95a31d76913f3ccca153f2
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Tue Aug 12 10:17:32 2014 +0200

    root testsuite: Regression test for problem exposed during most recent bootstrap.
---
 Makefile      |  2 +-
 foo54_fine.rs | 23 +++++++++++++++++++++++
 2 files changed, 24 insertions(+), 1 deletion(-)

diff --git a/Makefile b/Makefile
index 5c3b362..5a9fa69 100644
--- a/Makefile
+++ b/Makefile
@@ -15,7 +15,7 @@ FILES_FINE=              foo02_fine.rs
                          foo32_fine.rs foo33_fine.rs foo34_fine.rs               \
                          foo42_fine.rs               foo44_fine.rs               \
                          foo47_fine.rs               foo49_fine.rs               \
-                                       foo53_fine.rs
+                                       foo53_fine.rs foo54_fine.rs
 
 FILES_UNCATEGORIZED=                                                             \
            foo16.rs                                  foo19.rs      foo20.rs      \
diff --git a/foo54_fine.rs b/foo54_fine.rs
new file mode 100644
index 0000000..a90e44f
--- /dev/null
+++ b/foo54_fine.rs
@@ -0,0 +1,23 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub fn drop<T>(_x: T) { }
+
+pub trait Float {
+    fn infinity() -> Self;
+    fn neg_infinity() -> Self;
+    fn foo(self) -> bool;
+}
+
+impl Float for f32 {
+    #[inline]
+    fn foo(self) -> bool {
+        self == Float::infinity() || self == Float::neg_infinity()
+    }
+    fn infinity() -> f32 { loop { } }
+    fn neg_infinity() -> f32 { loop { } }
+}

commit 579bc70913886239bf805b55ef38157b8defcac8
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Tue Aug 12 10:06:32 2014 +0200

    rust-needsdrop: Generalized param_env construction to handle Method and TraitMethod.
---
 src/librustc/middle/borrowck/check_drops.rs | 13 ++++++++++---
 1 file changed, 10 insertions(+), 3 deletions(-)

diff --git a/src/librustc/middle/borrowck/check_drops.rs b/src/librustc/middle/borrowck/check_drops.rs
index 2ead5b5..78d7801 100644
--- a/src/librustc/middle/borrowck/check_drops.rs
+++ b/src/librustc/middle/borrowck/check_drops.rs
@@ -57,14 +57,21 @@ pub fn check_drops(bccx: &BorrowckCtxt,
     debug!("check_drops(body id={:?})", body.id);
 
     let param_env;
+
     let mut cursor_id = id;
     loop {
         match bccx.tcx.map.find(cursor_id) {
             Some(ast_map::NodeItem(..)) => {
                 let fn_pty = ty::lookup_item_type(bccx.tcx, ast_util::local_def(cursor_id));
-                param_env = ty::construct_parameter_environment(bccx.tcx,
-                                                                &fn_pty.generics,
-                                                                body.id);
+                let generics = &fn_pty.generics;
+                param_env = ty::construct_parameter_environment(bccx.tcx, generics, body.id);
+                break;
+            }
+            Some(ast_map::NodeMethod(..))      |
+            Some(ast_map::NodeTraitMethod(..)) => {
+                let method = ty::method(bccx.tcx, ast_util::local_def(cursor_id));
+                let generics = &method.generics;
+                param_env = ty::construct_parameter_environment(bccx.tcx, generics, body.id);
                 break;
             }
             Some(_) => {

commit 7364e699781743653c085525605c7152c2974812
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Tue Aug 12 09:24:35 2014 +0200

    rustc UX: Have `--pretty -o <file>` cleanup 0 byte file on `fail!`.
---
 src/librustc/driver/driver.rs | 50 ++++++++++++++++++++++++++++++++++++++++++++++----
 1 file changed, 46 insertions(+), 4 deletions(-)

diff --git a/src/librustc/driver/driver.rs b/src/librustc/driver/driver.rs
index 1eee45b..e4b79f1 100644
--- a/src/librustc/driver/driver.rs
+++ b/src/librustc/driver/driver.rs
@@ -734,8 +734,8 @@ pub fn pretty_print_input(sess: Session,
 
     let out = match ofile {
         None => box io::stdout() as Box<Writer>,
-        Some(p) => {
-            let r = io::File::create(&p);
+        Some(ref p) => {
+            let r = io::File::create(p);
             match r {
                 Ok(w) => box w as Box<Writer>,
                 Err(e) => fail!("print-print failed to open {} due to {}",
@@ -743,7 +743,10 @@ pub fn pretty_print_input(sess: Session,
             }
         }
     };
-    match ppm {
+
+    let mut file_cleanup = OutputFileCleanup::if_needed(ofile);
+
+    let res = match ppm {
         PpmIdentified | PpmExpandedIdentified => {
             pprust::print_crate(sess.codemap(),
                                 sess.diagnostic(),
@@ -1103,10 +1106,49 @@ pub fn pretty_print_input(sess: Session,
                                 &pprust::NoAnn,
                                 is_expanded)
         }
-    }.unwrap()
+    };
+
+    if res.is_ok() {
+        file_cleanup.unneeded();
+    }
 
+    res.unwrap()
 }
 
+struct OutputFileCleanup {
+    path: Option<Path>,
+}
+
+impl OutputFileCleanup {
+    fn unneeded(&mut self) { self.path = None; }
+    fn if_needed(opt_path: Option<Path>) -> OutputFileCleanup {
+        OutputFileCleanup { path: opt_path }
+    }
+}
+
+impl Drop for OutputFileCleanup {
+    fn drop(&mut self) {
+        match self.path {
+            None => {}
+            Some(ref path) => {
+                // clean-up is only best-effort (and only if no output
+                // was produced); so drop result.
+                drop(io::fs::stat(path).
+                     and_then(|file_stat| {
+                         if file_stat.size == 0 {
+                             io::fs::unlink(path)
+                         } else {
+                             Ok(())
+                         }
+                     }));
+            }
+        }
+    }
+}
+
+
+
+
 fn flow_graph_id_to_code(flow_graph_id: FlowGraphId,
                          analysis: &CrateAnalysis) -> blocks::Code {
     let ty_cx = &analysis.ty_cx;

commit 36dcae4869bf2a7bf28a9268d2e84729630f8c7c
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Tue Aug 12 08:36:32 2014 +0200

    root testsuite: add specific regression test for method handling.
    
    (which is still broken as of the time of this commit, but hopefully i
    will fix soon.)
---
 Makefile      |  3 ++-
 foo53_fine.rs | 23 +++++++++++++++++++++++
 2 files changed, 25 insertions(+), 1 deletion(-)

diff --git a/Makefile b/Makefile
index c6d4aca..5c3b362 100644
--- a/Makefile
+++ b/Makefile
@@ -14,7 +14,8 @@ FILES_FINE=              foo02_fine.rs
                                                      foo29_fine.rs foo30_fine.rs \
                          foo32_fine.rs foo33_fine.rs foo34_fine.rs               \
                          foo42_fine.rs               foo44_fine.rs               \
-                         foo47_fine.rs               foo49_fine.rs
+                         foo47_fine.rs               foo49_fine.rs               \
+                                       foo53_fine.rs
 
 FILES_UNCATEGORIZED=                                                             \
            foo16.rs                                  foo19.rs      foo20.rs      \
diff --git a/foo53_fine.rs b/foo53_fine.rs
new file mode 100644
index 0000000..82d30c4
--- /dev/null
+++ b/foo53_fine.rs
@@ -0,0 +1,23 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub fn drop<T>(_x: T) { }
+
+pub enum Ordering { Less = -1i, Equal = 0i, Greater = 1i, }
+
+pub trait Ord {
+    fn cmp(&self, _other: &Self) -> bool { loop { } }
+}
+impl Ord for int { }
+
+pub fn foo(x: &int) -> int {
+    match *x {
+        n if n.cmp(&0) => 1,  // int is copy ...
+        0              => 0,  // ... and that is all ...
+        _              => -1, // ... we are looking at.
+    } // So should be fine at this join point.
+}

commit 8eccb909ca3678eb6c0d3fcd9cb4dfb51ee7f87d
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Mon Aug 11 23:24:41 2014 +0200

    rust-needsdrop: checkpoint.  Gets through all existing warn/fine; but ICE's on num01.rs.
---
 src/librustc/middle/borrowck/check_drops.rs |  43 +++++++++++++----
 src/librustc/middle/borrowck/mod.rs         |   2 +-
 src/librustc/middle/typeck/check/mod.rs     |   3 ++
 src/librustc/middle/typeck/check/vtable.rs  | 286 +++++++++++++++++++++++++++++++++++++--------------------------------------------------------------------------
 4 files changed, 133 insertions(+), 201 deletions(-)

diff --git a/src/librustc/middle/borrowck/check_drops.rs b/src/librustc/middle/borrowck/check_drops.rs
index 92ba8bf..2ead5b5 100644
--- a/src/librustc/middle/borrowck/check_drops.rs
+++ b/src/librustc/middle/borrowck/check_drops.rs
@@ -34,7 +34,8 @@ use middle::typeck::check::vtable::fixup_substs; // FIXME
 use middle::typeck::check::vtable::fixup_ty; // FIXME
 use middle::typeck::check::vtable::lookup_vtable_from_bounds; // FIXME
 use middle::typeck::check::vtable::lookup_vtable; // FIXME
-use middle::typeck::check::vtable; // FIXME
+// use middle::typeck::check::vtable; // FIXME for some reason this is failing.  :(
+use middle::typeck::check;
 use util::ppaux::Repr;
 use util::nodemap::DefIdMap;
 
@@ -49,11 +50,33 @@ static mut warning_count: atomics::AtomicUint = atomics::INIT_ATOMIC_UINT;
 
 pub fn check_drops(bccx: &BorrowckCtxt,
                    flowed_move_data: &move_data::FlowedMoveData,
+                   id: ast::NodeId,
                    cfg: &cfg::CFG,
                    decl: &ast::FnDecl,
                    body: &ast::Block) {
     debug!("check_drops(body id={:?})", body.id);
 
+    let param_env;
+    let mut cursor_id = id;
+    loop {
+        match bccx.tcx.map.find(cursor_id) {
+            Some(ast_map::NodeItem(..)) => {
+                let fn_pty = ty::lookup_item_type(bccx.tcx, ast_util::local_def(cursor_id));
+                param_env = ty::construct_parameter_environment(bccx.tcx,
+                                                                &fn_pty.generics,
+                                                                body.id);
+                break;
+            }
+            Some(_) => {
+                cursor_id = bccx.tcx.map.get_parent(cursor_id);
+                continue;
+            }
+            None => {
+                fail!("could not find param_env for node {}", id);
+            }
+        }
+    };
+
     cfg.graph.each_node(|node_index, node| {
         // Special case: do not flag violations for control flow from
         // return expressions.  Each return can be prefixed with
@@ -226,7 +249,7 @@ pub fn check_drops(bccx: &BorrowckCtxt,
                     // Check if type of `lp` has #[quiet_early_drop]
                     // attribute or implements `QuietEarlyDrop`;
                     // select the appropriate lint to signal.
-                    let lint_category = if is_quiet_early_drop(bccx.tcx, &**lp) {
+                    let lint_category = if is_quiet_early_drop(bccx.tcx, &param_env, &**lp) {
                         lint::builtin::QUIET_EARLY_DROP
                     } else {
                         lint::builtin::UNMARKED_EARLY_DROP
@@ -432,7 +455,9 @@ fn scan_forward_for_kill_id(bccx: &BorrowckCtxt,
     }
 }
 
-fn is_quiet_early_drop(tcx: &ty::ctxt, lp: &LoanPath) -> bool {
+fn is_quiet_early_drop(tcx: &ty::ctxt,
+                       param_env: &ty::ParameterEnvironment,
+                       lp: &LoanPath) -> bool {
     let t = lp.to_type(tcx);
     match ty::get(t).sty {
         ty::ty_struct(did, _) |
@@ -477,7 +502,7 @@ fn is_quiet_early_drop(tcx: &ty::ctxt, lp: &LoanPath) -> bool {
         }
     };
 
-    let ret = type_implements_trait(tcx, t, trait_did);
+    let ret = type_implements_trait(tcx, param_env, t, trait_did);
     debug!("is_quiet_early_drop: type_implements_trait is {}", ret);
     ret
 }
@@ -502,6 +527,7 @@ fn with_attrs_for_did<A>(tcx: &ty::ctxt,
 }
 
 fn type_implements_trait(tcx: &ty::ctxt,
+                         param_env: &ty::ParameterEnvironment,
                          ty: ty::t,
                          trait_did: ast::DefId) -> bool {
     // largely modelled after lookup_vtable
@@ -528,14 +554,15 @@ fn type_implements_trait(tcx: &ty::ctxt,
 
     debug!("after subst: {}", trait_ref.repr(tcx));
 
-    let param_bounds = subst::VecPerParamSpace::empty();
     let unboxed_closure_types = RefCell::new(DefIdMap::new());
 
-    let vcx = vtable::VtableContext {
+    let vcx = check::vtable::VtableContext {
         infcx: &infcx,
-        param_bounds: &param_bounds,
+        param_bounds: &param_env.bounds,
         unboxed_closure_types: &unboxed_closure_types,
+        is_early: check::vtable::NotEarly,
+        if_missing_ty_param: check::vtable::IfMissingTyParamGiveUp,
     };
 
-    return lookup_vtable(&vcx, span, ty, trait_ref, false).is_ok();
+    return lookup_vtable(&vcx, span, ty, trait_ref).is_ok();
 }
diff --git a/src/librustc/middle/borrowck/mod.rs b/src/librustc/middle/borrowck/mod.rs
index 2efe810..fa495c1 100644
--- a/src/librustc/middle/borrowck/mod.rs
+++ b/src/librustc/middle/borrowck/mod.rs
@@ -142,7 +142,7 @@ fn borrowck_fn(this: &mut BorrowckCtxt,
                        move_data:flowed_moves } =
         build_borrowck_dataflow_data(this, fk, decl, &cfg, body, sp, id);
 
-    check_drops::check_drops(this, &flowed_moves, &cfg, decl, body);
+    check_drops::check_drops(this, &flowed_moves, id, &cfg, decl, body);
 
     check_loans::check_loans(this, &loan_dfcx, flowed_moves,
                              all_loans.as_slice(), decl, body);
diff --git a/src/librustc/middle/typeck/check/mod.rs b/src/librustc/middle/typeck/check/mod.rs
index 5c3dc4e..3f1fcbf 100644
--- a/src/librustc/middle/typeck/check/mod.rs
+++ b/src/librustc/middle/typeck/check/mod.rs
@@ -103,6 +103,7 @@ use middle::typeck::check::method::{DontAutoderefReceiver};
 use middle::typeck::check::method::{IgnoreStaticMethods, ReportStaticMethods};
 use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;
 use middle::typeck::check::vtable::VtableContext;
+use middle::typeck::check;
 use middle::typeck::CrateCtxt;
 use middle::typeck::infer::{resolve_type, force_tvar};
 use middle::typeck::infer;
@@ -1585,6 +1586,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {
             infcx: self.infcx(),
             param_bounds: &self.inh.param_env.bounds,
             unboxed_closures: &self.inh.unboxed_closures,
+            if_missing_ty_param: check::vtable::IfMissingTyParamSearch,
+            is_early: check::vtable::NotEarly,
         }
     }
 }
diff --git a/src/librustc/middle/typeck/check/vtable.rs b/src/librustc/middle/typeck/check/vtable.rs
index a222025..92191af 100644
--- a/src/librustc/middle/typeck/check/vtable.rs
+++ b/src/librustc/middle/typeck/check/vtable.rs
@@ -72,17 +72,37 @@ pub struct VtableContext<'a, 'tcx: 'a> {
     pub infcx: &'a infer::InferCtxt<'a, 'tcx>,
     pub param_bounds: &'a VecPerParamSpace<ty::ParamBounds>,
     pub unboxed_closures: &'a RefCell<DefIdMap<ty::UnboxedClosure>>,
+    pub is_early: IsEarly,
+    pub if_missing_ty_param: IfMissingTyParam,
+}
+
+#[deriving(PartialEq, Show)]
+pub enum IsEarly {
+    IsEarly,
+    NotEarly,
+}
+
+#[deriving(Show)]
+pub enum IfMissingTyParam {
+    IfMissingTyParamSearch,
+    IfMissingTyParamGiveUp,
 }
 
 impl<'a, 'tcx> VtableContext<'a, 'tcx> {
     pub fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.infcx.tcx }
 
+    pub fn is_early(&self) -> bool { self.is_early == IsEarly }
+
     fn ok_or_die<A>(&self, r: VtResult<A>) -> A {
         match r {
             Ok(r) => r,
             Err((span, msg)) => self.tcx().sess.span_fatal(span, msg.as_slice()),
         }
     }
+
+    pub fn make_early_vcx(&self, is_early: bool) -> VtableContext<'a> {
+        VtableContext { is_early: if is_early { IsEarly } else { NotEarly }, ..*self }
+    }
 }
 
 pub type ErrMsg = (Span, String);
@@ -132,19 +152,18 @@ pub fn lookup_vtables(vcx: &VtableContext,
 }
 
 pub fn lookup_vtables_for_param(vcx: &VtableContext,
-                            span: Span,
-                            // None for substs means the identity
-                            substs: Option<&subst::Substs>,
-                            type_param_bounds: &ty::ParamBounds,
-                            ty: ty::t,
-                            is_early: bool)
-                            -> VtResult<vtable_param_res> {
+                                span: Span,
+                                // None for substs means the identity
+                                substs: Option<&subst::Substs>,
+                                type_param_bounds: &ty::ParamBounds,
+                                ty: ty::t)
+                                -> VtResult<vtable_param_res> {
     let tcx = vcx.tcx();
 
     debug!("lookup_vtables_for_param(ty={}, type_param_bounds={}, is_early={})",
            ty.repr(vcx.tcx()),
            type_param_bounds.repr(vcx.tcx()),
-           is_early);
+           vcx.is_early());
 
     // ty is the value supplied for the type parameter A...
     let mut param_result = Vec::new();
@@ -174,7 +193,7 @@ pub fn lookup_vtables_for_param(vcx: &VtableContext,
 
         debug!("after subst: {}", trait_ref.repr(tcx));
 
-        match lookup_vtable(vcx, span, ty, trait_ref.clone(), is_early) {
+        match lookup_vtable(vcx, span, ty, trait_ref.clone()) {
             Ok(Some(vtable)) => {
                 param_result.push(vtable);
             }
@@ -253,59 +272,77 @@ pub fn relate_trait_refs(tcx: &ty::ctxt,
 
 // Look up the vtable implementing the trait `trait_ref` at type `t`
 pub fn lookup_vtable(vcx: &VtableContext,
-                 span: Span,
-                 ty: ty::t,
-                 trait_ref: Rc<ty::TraitRef>,
-                 is_early: bool)
+                     span: Span,
+                     ty: ty::t,
+                     trait_ref: Rc<ty::TraitRef>)
                  -> VtResult<Option<vtable_origin>>
 {
-    debug!("lookup_vtable(ty={}, trait_ref={})",
+    debug!("lookup_vtable(vcx{} param_bounds={} {}, ty={}, trait_ref={})",
+           "{", vcx.param_bounds.repr(vcx.tcx()), "}",
            ty.repr(vcx.tcx()),
            trait_ref.repr(vcx.tcx()));
     let _i = indenter();
 
-    let ty = match fixup_ty(vcx.tcx(), vcx.infcx, span, ty, is_early) {
-        Some(ty) => ty,
+    let ty = match fixup_ty(vcx.tcx(), vcx.infcx, span, ty, vcx.is_early()) {
+        Some(ty) => {
+            ty
+        }
         None => {
             // fixup_ty can only fail if this is early resolution
-            assert!(is_early);
+            assert!(vcx.is_early());
             // The type has unconstrained type variables in it, so we can't
             // do early resolution on it. Return some completely bogus vtable
             // information: we aren't storing it anyways.
+            debug!("lookup_vtable vtable_error");
             return Ok(Some(vtable_error));
         }
     };
 
     if ty::type_is_error(ty) {
+        debug!("lookup_vtable type_is_error(ty={})", ty.repr(vcx.tcx()));
         return Ok(Some(vtable_error));
     }
 
     // If the type is self or a param, we look at the trait/supertrait
     // bounds to see if they include the trait we are looking for.
-    let vtable_opt = match ty::get(ty).sty {
+    match ty::get(ty).sty {
         ty::ty_param(ParamTy {space, idx: n, ..}) => {
             let env_bounds = &vcx.param_bounds;
             let type_param_bounds = &env_bounds.get(space, n).trait_bounds;
-            lookup_vtable_from_bounds(vcx.tcx(),
-                                      vcx.infcx,
-                                      span,
-                                      type_param_bounds.as_slice(),
-                                      param_index {
-                                          space: space,
-                                          index: n,
-                                      },
-                                      trait_ref.clone())
+            let param_index = param_index { space: space, index: n };
+            debug!("lookup_vtable type_param_bounds: {} \
+                    param_index: {:?} trait_ref: {}",
+                   type_param_bounds.repr(vcx.tcx()),
+                   param_index,
+                   trait_ref.repr(vcx.tcx()));
+            let ret = lookup_vtable_from_bounds(vcx.tcx(),
+                                                vcx.infcx,
+                                                span,
+                                                type_param_bounds.as_slice(),
+                                                param_index,
+                                                trait_ref.clone());
+            if ret.is_some() {
+                return Ok(ret);
+            }
+
+            match vcx.if_missing_ty_param {
+                IfMissingTyParamGiveUp => {
+                    let msg = format!("No vtable found for ty param {}", ty.repr(vcx.tcx()));
+                    return Err((span, msg));
+                }
+                IfMissingTyParamSearch => {
+                    // fall through to search below
+                }
+            }
         }
 
         // Default case just falls through
-        _ => None
+        _ => {}
     };
 
-    if vtable_opt.is_some() { return Ok(vtable_opt); }
-
     // If we aren't a self type or param, or it was, but we didn't find it,
     // do a search.
-    search_for_vtable(vcx, span, ty, trait_ref, is_early)
+    search_for_vtable(vcx, span, ty, trait_ref)
 }
 
 // Given a list of bounds on a type, search those bounds to see if any
@@ -423,7 +460,7 @@ fn search_for_vtable(vcx: &VtableContext,
                      ty: ty::t,
                      trait_ref: Rc<ty::TraitRef>,
                      is_early: bool)
-                     -> Option<vtable_origin> {
+                     -> VtResult<Option<vtable_origin>> {
     let tcx = vcx.tcx();
 
     // First, check to see whether this is a call to the `call` method of an
@@ -538,8 +575,7 @@ fn search_for_vtable(vcx: &VtableContext,
         let subres = try!(lookup_vtables(vcx,
                                          span,
                                          &im_generics.types,
-                                         &substs,
-                                         is_early));
+                                         &substs));
 
         // substs might contain type variables, so we call
         // fixup_substs to resolve them.
@@ -548,10 +584,10 @@ fn search_for_vtable(vcx: &VtableContext,
                                           span,
                                           trait_ref.def_id,
                                           substs,
-                                          is_early) {
+                                          vcx.is_early()) {
             Some(ref substs) => (*substs).clone(),
             None => {
-                assert!(is_early);
+                assert!(vcx.is_early());
                 // Bail out with a bogus answer
                 return Ok(Some(vtable_error));
             }
@@ -582,7 +618,7 @@ fn search_for_vtable(vcx: &VtableContext,
         0 => { return Ok(None) }
         1 => return Ok(Some(found.get(0).clone())),
         _ => {
-            if !is_early {
+            if !vcx.is_early() {
                 span_err!(vcx.tcx().sess, span, E0096,
                           "multiple applicable methods in scope");
             }
@@ -612,11 +648,11 @@ pub fn fixup_substs(tcx: &ty::ctxt,
 }
 
 pub fn fixup_ty(tcx: &ty::ctxt,
-            infcx: &infer::InferCtxt,
-            span: Span,
-            ty: ty::t,
-            is_early: bool)
-            -> Option<ty::t> {
+                infcx: &infer::InferCtxt,
+                span: Span,
+                ty: ty::t,
+                is_early: bool)
+                -> Option<ty::t> {
     match resolve_type(infcx, Some(span), ty, resolve_and_force_all_but_regions) {
         Ok(new_type) => Some(new_type),
         Err(e) if !is_early => {
@@ -682,7 +718,6 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {
                   _ => {}
               }
           }
-<<<<<<< HEAD
           (&ty::ty_uniq(..), &ty::ty_uniq(..) )
           | (&ty::ty_ptr(..), &ty::ty_ptr(..) )
           | (&ty::ty_ptr(..), &ty::ty_rptr(..)) => {}
@@ -691,141 +726,6 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {
                              infer::RelateObjectBound(ex.span),
                              r_t,
                              r_s);
-||||||| merged common ancestors
-
-          (&ty::ty_uniq(ty), &ty::ty_uniq(..) ) |
-          (&ty::ty_rptr(_, ty::mt{ty, ..}), &ty::ty_rptr(..)) => {
-              match ty::get(ty).sty {
-                  ty::ty_trait(box ty::TyTrait {
-                      def_id: target_def_id, substs: ref target_substs, ..
-                  }) => {
-                      debug!("nrc correct path");
-                      let typ = match &ty::get(src_ty).sty {
-                          &ty::ty_uniq(typ) => typ,
-                          &ty::ty_rptr(_, mt) => mt.ty,
-                          _ => fail!("shouldn't get here"),
-                      };
-
-                      let vcx = fcx.vtable_context();
-
-                      // Take the type parameters from the object
-                      // type, but set the Self type (which is
-                      // unknown, for the object type) to be the type
-                      // we are casting from.
-                      let mut target_types = target_substs.types.clone();
-                      assert!(target_types.get_self().is_none());
-                      target_types.push(subst::SelfSpace, typ);
-
-                      let target_trait_ref = Rc::new(ty::TraitRef {
-                          def_id: target_def_id,
-                          substs: subst::Substs {
-                              regions: target_substs.regions.clone(),
-                              types: target_types
-                          }
-                      });
-
-                      let param_bounds = ty::ParamBounds {
-                          builtin_bounds: ty::empty_builtin_bounds(),
-                          trait_bounds: vec!(target_trait_ref)
-                      };
-                      let vtables =
-                            lookup_vtables_for_param(&vcx,
-                                                     ex.span,
-                                                     None,
-                                                     &param_bounds,
-                                                     typ,
-                                                     is_early);
-
-                      if !is_early {
-                          let mut r = VecPerParamSpace::empty();
-                          r.push(subst::SelfSpace, vtables);
-                          insert_vtables(fcx, key, r);
-                      }
-
-                      // Now, if this is &trait, we need to link the
-                      // regions.
-                      match (&ty::get(src_ty).sty, &ty::get(target_ty).sty) {
-                          (&ty::ty_rptr(ra, _), &ty::ty_rptr(rb, _)) => {
-                              debug!("nrc - make subr");
-                              infer::mk_subr(fcx.infcx(),
-                                             false,
-                                             infer::RelateObjectBound(ex.span),
-                                             rb,
-                                             ra);
-                          }
-                          _ => {}
-                      }
-                  }
-                  _ => {}
-              }
-=======
-
-          (&ty::ty_uniq(ty), &ty::ty_uniq(..) ) |
-          (&ty::ty_rptr(_, ty::mt{ty, ..}), &ty::ty_rptr(..)) => {
-              match ty::get(ty).sty {
-                  ty::ty_trait(box ty::TyTrait {
-                      def_id: target_def_id, substs: ref target_substs, ..
-                  }) => {
-                      debug!("nrc correct path");
-                      let typ = match &ty::get(src_ty).sty {
-                          &ty::ty_uniq(typ) => typ,
-                          &ty::ty_rptr(_, mt) => mt.ty,
-                          _ => fail!("shouldn't get here"),
-                      };
-
-                      let vcx = fcx.vtable_context();
-
-                      // Take the type parameters from the object
-                      // type, but set the Self type (which is
-                      // unknown, for the object type) to be the type
-                      // we are casting from.
-                      let mut target_types = target_substs.types.clone();
-                      assert!(target_types.get_self().is_none());
-                      target_types.push(subst::SelfSpace, typ);
-
-                      let target_trait_ref = Rc::new(ty::TraitRef {
-                          def_id: target_def_id,
-                          substs: subst::Substs {
-                              regions: target_substs.regions.clone(),
-                              types: target_types
-                          }
-                      });
-
-                      let param_bounds = ty::ParamBounds {
-                          builtin_bounds: ty::empty_builtin_bounds(),
-                          trait_bounds: vec!(target_trait_ref)
-                      };
-                      let vtables = vcx.ok_or_die(
-                          lookup_vtables_for_param(&vcx,
-                                                   ex.span,
-                                                   None,
-                                                   &param_bounds,
-                                                   typ,
-                                                   is_early));
-
-                      if !is_early {
-                          let mut r = VecPerParamSpace::empty();
-                          r.push(subst::SelfSpace, vtables);
-                          insert_vtables(fcx, key, r);
-                      }
-
-                      // Now, if this is &trait, we need to link the
-                      // regions.
-                      match (&ty::get(src_ty).sty, &ty::get(target_ty).sty) {
-                          (&ty::ty_rptr(ra, _), &ty::ty_rptr(rb, _)) => {
-                              debug!("nrc - make subr");
-                              infer::mk_subr(fcx.infcx(),
-                                             false,
-                                             infer::RelateObjectBound(ex.span),
-                                             rb,
-                                             ra);
-                          }
-                          _ => {}
-                      }
-                  }
-                  _ => {}
-              }
->>>>>>> FIXME rust-needsdrop checkpoint: mashup of foundational support for `trait QuietEarlyDrop`.
           }
           (&ty::ty_uniq(ty), _) => {
               match ty::get(ty).sty {
@@ -924,12 +824,12 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {
                    fcx.infcx().ty_to_string(item_ty.ty));
             debug!("early_resolve_expr: looking up vtables for type params {}",
                    item_ty.generics.types.repr(fcx.tcx()));
-            let vcx = fcx.vtable_context();
+            let vcx = fcx.vtable_context().make_early_vcx(is_early);
             let vtbls = vcx.ok_or_die(
                 lookup_vtables(&vcx, ex.span,
                                &item_ty.generics.types,
-                               &item_substs.substs, is_early));
-            if !is_early {
+                               &item_substs.substs));
+            if !vcx.is_early() {
                 insert_vtables(fcx, MethodCall::expr(ex.id), vtbls);
             }
         });
@@ -950,12 +850,12 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {
               let type_param_defs =
                   ty::method_call_type_param_defs(fcx, method.origin);
               let substs = fcx.method_ty_substs(ex.id);
-              let vcx = fcx.vtable_context();
+              let vcx = fcx.vtable_context().make_early_vcx(is_early);
               let vtbls = vcx.ok_or_die(
                   lookup_vtables(&vcx, ex.span,
                                  &type_param_defs,
-                                 &substs, is_early));
-              if !is_early {
+                                 &substs));
+              if !vcx.is_early() {
                   insert_vtables(fcx, MethodCall::expr(ex.id), vtbls);
               }
           }
@@ -1010,12 +910,12 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {
                                        ex.repr(fcx.tcx()));
                                 let type_param_defs =
                                     ty::method_call_type_param_defs(cx.tcx, method.origin);
-                                let vcx = fcx.vtable_context();
+                                let vcx = fcx.vtable_context().make_early_vcx(is_early);
                                 let vtbls = vcx.ok_or_die(
                                     lookup_vtables(&vcx, ex.span,
                                                    &type_param_defs,
-                                                   &method.substs, is_early));
-                                if !is_early {
+                                                   &method.substs));
+                                if !vcx.is_early() {
                                     insert_vtables(fcx, method_call, vtbls);
                                 }
                             }
@@ -1137,8 +1037,10 @@ pub fn resolve_impl(tcx: &ty::ctxt,
     let unboxed_closures = RefCell::new(DefIdMap::new());
     let vcx = VtableContext {
         infcx: infcx,
-        param_env: &param_env.bounds,
+        param_bounds: &param_env.bounds,
         unboxed_closures: &unboxed_closures,
+        if_missing_ty_param: IfMissingTyParamSearch,
+        is_early: NotEarly,
     };
 
     // Resolve the vtables for the trait reference on the impl.  This
@@ -1168,8 +1070,7 @@ pub fn resolve_impl(tcx: &ty::ctxt,
         lookup_vtables(&vcx,
                        impl_item.span,
                        &trait_def.generics.types,
-                       &impl_trait_ref.substs,
-                       false));
+                       &impl_trait_ref.substs));
 
     infcx.resolve_regions_and_report_errors();
 
@@ -1194,13 +1095,14 @@ pub fn trans_resolve_method(tcx: &ty::ctxt, id: ast::NodeId,
         infcx: &infer::new_infer_ctxt(tcx),
         param_bounds: &param_env.bounds,
         unboxed_closures: &unboxed_closures,
+        if_missing_ty_param: IfMissingTyParamSearch,
+        is_early: NotEarly,
     };
 
     vcx.ok_or_die(lookup_vtables(&vcx,
                                  tcx.map.span(id),
                                  &generics.types,
-                                 substs,
-                                 false))
+                                 substs))
 }
 
 impl<'a, 'b, 'tcx> visit::Visitor<()> for &'a FnCtxt<'b, 'tcx> {

commit 8db398ca14485cc3b5437a6627671dd1bcbffe9f
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Mon Aug 11 23:22:40 2014 +0200

    root testsuite: some more cases uncovered while bootstrapping.
---
 Makefile      |  3 ++-
 foo46_run.rs  | 46 ++++++++++++++++++++++++++++++++++++++++++++++
 foo51.rs      | 41 +++++++++++++++++++++++++++++++++++++++++
 foo52_warn.rs | 21 +++++++++++++++++++++
 4 files changed, 110 insertions(+), 1 deletion(-)

diff --git a/Makefile b/Makefile
index c9525be..c6d4aca 100644
--- a/Makefile
+++ b/Makefile
@@ -5,7 +5,8 @@ FILES_WARN=foo01_warn.rs               foo03_warn.rs foo04_warn.rs foo05_warn.rs
            foo26_warn.rs foo27_warn.rs foo28_warn.rs                             \
            foo31_warn.rs                                                         \
                                        foo43_warn.rs                             \
-                                       foo48_warn.rs               foo50_warn.rs
+                                       foo48_warn.rs               foo50_warn.rs \
+                         foo52_warn.rs
 
 FILES_FINE=              foo02_fine.rs                                           \
            foo11_fine.rs foo12_fine.rs foo13_fine.rs foo14_fine.rs foo15_fine.rs \
diff --git a/foo46_run.rs b/foo46_run.rs
new file mode 100644
index 0000000..22c1c05
--- /dev/null
+++ b/foo46_run.rs
@@ -0,0 +1,46 @@
+#![feature(lang_items)]
+
+pub struct Foo<X,Y> { _x: X, _y: Y, z: Option<OneOhOne> }
+
+pub struct OneOhOne {
+    ptr: *mut int
+}
+
+impl Drop for OneOhOne {
+    fn drop(&mut self) {
+        unsafe {
+            *self.ptr = 101;
+        }
+    }
+}
+
+fn main() {
+    let r = foo(true, || { Foo { _x: 1i, _y: 2i, z: None } }, |_| 10i, |_| 11i);
+    println!("r: {}", r);
+}
+
+pub fn foo<X,Y:Copy>(b: bool, c: || -> Foo<X,Y>, f: |X| -> int, _g: |Y| -> int) -> int {
+    let mut ret = 4;
+    let mut s = c();
+    {
+        s.z = Some(OneOhOne { ptr: &mut ret as *mut int });
+        //                                                          // NEEDS_DROP={s}
+        if b {
+            //                                                          // NEEDS_DROP={s}
+            f(s._x) // Path s._x moved in this branch ...
+                //                                                          // NEEDS_DROP={}
+        } else {
+            //                                                          // NEEDS_DROP={s}
+            3    // ... but not this one ...
+                //                                                          // NEEDS_DROP={s}
+        }; // ... but the only thing remaining is a read, so ... is it fine?
+    }
+
+    match true {
+        #[cfg(illustrate)]
+        true => std::mem::drop(s.z),
+        _ => {}
+    }
+
+    ret
+}
diff --git a/foo51.rs b/foo51.rs
new file mode 100644
index 0000000..58dafb0
--- /dev/null
+++ b/foo51.rs
@@ -0,0 +1,41 @@
+// #![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+// extracted version of ICE I encountered while bootstrapping libstd
+
+extern crate core;
+extern crate libc;
+extern crate rustrt;
+extern crate collections;
+
+use rustrt::c_str::{CString, ToCStr};
+use core::option::Option;
+use core::ptr;
+use core::result::{Result,Ok,Err};
+use collections::string::String;
+
+pub fn check_for_errors_in<T>(f: || -> T) -> Result<T, String> {
+    use rustrt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};
+    static mut lock: StaticNativeMutex = NATIVE_MUTEX_INIT;
+    unsafe {
+        // dlerror isn't thread safe, so we need to lock around this entire
+        // sequence
+        let _guard = lock.lock();
+        let _old_error = dlerror();
+
+        let result = f();
+
+        let last_error = dlerror() as *const _;
+        let ret = if ptr::null() == last_error {
+            Ok(result)
+            } else {
+            Err(String::from_str(CString::new(last_error, false).as_str()
+                                 .unwrap()))
+        };
+
+        ret
+    }
+}
+
+fn dlerror() -> *mut libc::c_char { loop { } }
diff --git a/foo52_warn.rs b/foo52_warn.rs
new file mode 100644
index 0000000..e2b0246
--- /dev/null
+++ b/foo52_warn.rs
@@ -0,0 +1,21 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+// reduced version of foo51.rs
+#[lang="sized"] pub trait Sized { }
+
+#[lang="quiet_early_drop"]
+pub trait QuietEarlyDrop { }
+
+pub fn foo<T>(b: || -> bool, f: || -> T) -> T {
+    let result = f();
+
+    let ret = if b() {
+        result
+    } else {
+        f()
+    };
+
+    ret
+}

commit a8738910d0f5e99ce25207c76ca90f459dd5d40b
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Mon Aug 11 16:14:56 2014 +0200

    root testsuite: Add various tests of things I added or tried to add over the weekend.
    
    foo45: test of treating a local variable read as pure, w.r.t early-drop.
    I later realized that this is not necessarily sound, which you can see
    illustrated in the next test.
    
    foo46: illustration of how an impure drop can write to a local
    variable. (I am pretty sure that interior mutability means that one
    can construct examples of this that do not even employ any unsafe
    code. I should try to make such an example.)
    
    foo47_fine: Simple example of `QuietEarlyDrop` trait implemented directly.
    
    foo48_warn: Simple example of `warn(quiet_early_drop)` attribute.
    
    foo49_fine: Simple example of `Quiet_Early_Drop` trait implmented indirectly.
    
    foo50_warn: Simple example of `Quiet_Early_Drop` trait *not* implmented indirectly.
---
 Makefile      | 11 +++++++----
 foo45.rs      | 30 ++++++++++++++++++++++++++++++
 foo46.rs      | 47 +++++++++++++++++++++++++++++++++++++++++++++++
 foo47_fine.rs | 35 +++++++++++++++++++++++++++++++++++
 foo48_warn.rs | 36 ++++++++++++++++++++++++++++++++++++
 foo49_fine.rs | 37 +++++++++++++++++++++++++++++++++++++
 foo50_warn.rs | 36 ++++++++++++++++++++++++++++++++++++
 7 files changed, 228 insertions(+), 4 deletions(-)

diff --git a/Makefile b/Makefile
index 809173c..c9525be 100644
--- a/Makefile
+++ b/Makefile
@@ -4,13 +4,16 @@ FILES_WARN=foo01_warn.rs               foo03_warn.rs foo04_warn.rs foo05_warn.rs
                                                                    foo25_warn.rs \
            foo26_warn.rs foo27_warn.rs foo28_warn.rs                             \
            foo31_warn.rs                                                         \
-                                       foo43_warn.rs
+                                       foo43_warn.rs                             \
+                                       foo48_warn.rs               foo50_warn.rs
+
 FILES_FINE=              foo02_fine.rs                                           \
            foo11_fine.rs foo12_fine.rs foo13_fine.rs foo14_fine.rs foo15_fine.rs \
                                        foo23_fine.rs foo24_fine.rs               \
                                                      foo29_fine.rs foo30_fine.rs \
                          foo32_fine.rs foo33_fine.rs foo34_fine.rs               \
-                         foo42_fine.rs               foo44_fine.rs
+                         foo42_fine.rs               foo44_fine.rs               \
+                         foo47_fine.rs               foo49_fine.rs
 
 FILES_UNCATEGORIZED=                                                             \
            foo16.rs                                  foo19.rs      foo20.rs      \
@@ -48,7 +51,7 @@ objdir-dbg/x86_64-apple-darwin/stage1/rustc: src/etc/rustc-wrapper.macosx.sh obj
 	cp $< $@
 	chmod +x $@
 
-RUST_LOG=rustc::middle::borrowck,rustc::middle::ty,rustc::middle::typeck,rustc::middle::expr_use_visitor,rustc::middle::region,rustc::middle::trans,rustc::middle::resolve,rustc::middle::mem_categorization
+RUST_LOG=rustc::middle::borrowck,rustc::middle::ty,rustc::middle::typeck,rustc::middle::expr_use_visitor,rustc::middle::region,rustc::middle::trans,rustc::middle::resolve,rustc::middle::mem_categorization::rustc::util::common
 
 %.dot: %.rs Makefile objdir-dbg/x86_64-apple-darwin/stage1/rustc
 	$(RUSTC_LIB) -Z flowgraph-print-all --pretty flowgraph=foo $< -o $@
@@ -57,7 +60,7 @@ RUST_LOG=rustc::middle::borrowck,rustc::middle::ty,rustc::middle::typeck,rustc::
 	$(RUSTC_LIB)                        --pretty expanded,identified $< -o $@
 
 %.log: %.rs Makefile objdir-dbg/x86_64-apple-darwin/stage1/rustc
-	RUST_LOG=$(RUST_LOG) RUST_BACKTRACE=1 $(RUSTC_LIB) $< 2> $@
+	RUST_LOG=$(RUST_LOG) RUST_BACKTRACE=1 $(RUSTC_LIB) -Z verbose $< 2> $@
 
 #	RUST_LOG=$(RUST_LOG) $(RUSTC_LIB) -Z flowgraph-print-all --pretty flowgraph=foo $< -o $@.dot 2> $@
 
diff --git a/foo45.rs b/foo45.rs
new file mode 100644
index 0000000..cc145d0
--- /dev/null
+++ b/foo45.rs
@@ -0,0 +1,30 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+#[lang="drop"] pub trait Drop { fn drop(&mut self); }
+
+pub enum Option<T> { None, Some(T), }
+
+pub struct Foo<'a,X,Y> { _x: X, _y: Y, z: Option<&'a mut int> }
+
+pub fn foo<X,Y:Copy>(b: bool, c: <'a> || -> Foo<'a,X,Y>, f: |X| -> int, _g: |Y| -> int) -> int {
+    let mut ret = 4;
+    {
+        let mut s = c();
+        s.z = Some(&mut ret);
+        //                                                          // NEEDS_DROP={s}
+        if b {
+            //                                                          // NEEDS_DROP={s}
+            f(s._x) // Path s._x moved in this branch ...
+                //                                                          // NEEDS_DROP={}
+        } else {
+            //                                                          // NEEDS_DROP={s}
+            3    // ... but not this one ...
+                //                                                          // NEEDS_DROP={s}
+        }; // ... but the only thing remaining is a read, so fine.
+    }
+    ret
+}
diff --git a/foo46.rs b/foo46.rs
new file mode 100644
index 0000000..9504464
--- /dev/null
+++ b/foo46.rs
@@ -0,0 +1,47 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+#[lang="drop"] pub trait Drop { fn drop(&mut self); }
+
+pub enum Option<T> { None, Some(T), }
+
+pub struct Foo<X,Y> { _x: X, _y: Y, z: OneOhOne }
+
+pub struct OneOhOne {
+    ptr: Option<*mut int>
+}
+
+impl Drop for OneOhOne {
+    fn drop(&mut self) {
+        match self.ptr {
+            None => {}
+            Some(ptr) => {
+                unsafe {
+                    *ptr = 101;
+                }
+            }
+        }
+    }
+}
+
+pub fn foo<X,Y:Copy>(b: bool, c: || -> Foo<X,Y>, f: |X| -> int, _g: |Y| -> int) -> int {
+    let mut ret = 4;
+    let mut s = c();
+    {
+        s.z = OneOhOne { ptr: Some(&mut ret as *mut int) };
+        //                                                          // NEEDS_DROP={s}
+        if b {
+            //                                                          // NEEDS_DROP={s}
+            f(s._x) // Path s._x moved in this branch ...
+                //                                                          // NEEDS_DROP={}
+        } else {
+            //                                                          // NEEDS_DROP={s}
+            3    // ... but not this one ...
+                //                                                          // NEEDS_DROP={s}
+        }; // ... but the only thing remaining is a read, so ... is it fine?
+    }
+    ret
+}
diff --git a/foo47_fine.rs b/foo47_fine.rs
new file mode 100644
index 0000000..60f2a1e
--- /dev/null
+++ b/foo47_fine.rs
@@ -0,0 +1,35 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+#[lang="drop"] pub trait Drop { fn drop(&mut self); }
+
+pub struct Foo<X,Y> { _x: X, _y: Y }
+
+#[lang="quiet_early_drop"]
+pub trait QuietEarlyDrop {
+}
+
+pub struct S;
+
+impl QuietEarlyDrop for S { }
+
+impl Drop for S { fn drop(&mut self) { } }
+
+pub fn foo<Y:Copy>(b: bool, c: || -> Foo<S,Y>, f: |S| -> int, _g: |Y| -> int) -> int {
+    let s = c();
+    //                                                          // NEEDS_DROP={s}
+    let ret = if b {
+    //                                                          // NEEDS_DROP={s}
+        f(s._x) // Path s._x moved in this branch ...
+    //                                                          // NEEDS_DROP={}
+    } else {
+    //                                                          // NEEDS_DROP={s}
+        3    // ... but not this one ...
+    //                                                          // NEEDS_DROP={s}
+    }; // ... but S is quiet_early_drop, so fine.
+    c();
+    ret
+}
diff --git a/foo48_warn.rs b/foo48_warn.rs
new file mode 100644
index 0000000..8ea376e
--- /dev/null
+++ b/foo48_warn.rs
@@ -0,0 +1,36 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+#[lang="drop"] pub trait Drop { fn drop(&mut self); }
+
+pub struct Foo<X,Y> { _x: X, _y: Y }
+
+#[lang="quiet_early_drop"]
+pub trait QuietEarlyDrop {
+}
+
+pub struct S;
+
+impl QuietEarlyDrop for S { }
+
+impl Drop for S { fn drop(&mut self) { } }
+
+#[warn(quiet_early_drop)]
+pub fn foo<Y:Copy>(b: bool, c: || -> Foo<S,Y>, f: |S| -> int, _g: |Y| -> int) -> int {
+    let s = c();
+    //                                                          // NEEDS_DROP={s}
+    let ret = if b {
+    //                                                          // NEEDS_DROP={s}
+        f(s._x) // Path s._x moved in this branch ...
+    //                                                          // NEEDS_DROP={}
+    } else {
+    //                                                          // NEEDS_DROP={s}
+        3    // ... but not this one ...
+    //                                                          // NEEDS_DROP={s}
+    }; // ... thus expect notice here (requested warn on quiet_early_drop)
+    c();
+    ret
+}
diff --git a/foo49_fine.rs b/foo49_fine.rs
new file mode 100644
index 0000000..56bc34e
--- /dev/null
+++ b/foo49_fine.rs
@@ -0,0 +1,37 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+#[lang="drop"] pub trait Drop { fn drop(&mut self); }
+
+pub struct Foo<X,Y> { _x: X, _y: Y }
+
+#[lang="quiet_early_drop"]
+pub trait QuietEarlyDrop {
+}
+
+pub struct S;
+pub struct T<X> { _s: X }
+
+impl QuietEarlyDrop for S { }
+impl<X:QuietEarlyDrop> QuietEarlyDrop for T<X> { }
+
+impl Drop for S { fn drop(&mut self) { } }
+
+pub fn foo<Y:Copy>(b: bool, c: || -> Foo<T<S>,Y>, f: |T<S>| -> int, _g: |Y| -> int) -> int {
+    let s = c();
+    //                                                          // NEEDS_DROP={s}
+    let ret = if b {
+    //                                                          // NEEDS_DROP={s}
+        f(s._x) // Path s._x moved in this branch ...
+    //                                                          // NEEDS_DROP={}
+    } else {
+    //                                                          // NEEDS_DROP={s}
+        3    // ... but not this one ...
+    //                                                          // NEEDS_DROP={s}
+    }; // ... but T<S> is quiet_early_drop, so fine.
+    c();
+    ret
+}
diff --git a/foo50_warn.rs b/foo50_warn.rs
new file mode 100644
index 0000000..9f70d9c
--- /dev/null
+++ b/foo50_warn.rs
@@ -0,0 +1,36 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+#[lang="drop"] pub trait Drop { fn drop(&mut self); }
+
+pub struct Foo<X,Y> { _x: X, _y: Y }
+
+#[lang="quiet_early_drop"]
+pub trait QuietEarlyDrop {
+}
+
+pub struct S;
+pub struct T<X> { _s: S }
+
+impl<X:QuietEarlyDrop> QuietEarlyDrop for T<X> { }
+
+impl Drop for S { fn drop(&mut self) { } }
+
+pub fn foo<Y:Copy>(b: bool, c: || -> Foo<T<S>,Y>, f: |T<S>| -> int, _g: |Y| -> int) -> int {
+    let s = c();
+    //                                                          // NEEDS_DROP={s}
+    let ret = if b {
+    //                                                          // NEEDS_DROP={s}
+        f(s._x) // Path s._x moved in this branch ...
+    //                                                          // NEEDS_DROP={}
+    } else {
+    //                                                          // NEEDS_DROP={s}
+        3    // ... but not this one ...
+    //                                                          // NEEDS_DROP={s}
+    }; // ... thus expect notice at this join-point (note T<S> is not quiet_early_drop).
+    c();
+    ret
+}

commit 9173d3f5b039a273cd6edc8b7e0b5a8bf7d1ab03
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Mon Aug 11 16:07:05 2014 +0200

    rust-needsdrop: Add `trait QuietEarlyDrop`.
---
 src/libcore/ops.rs                | 16 ++++++++++++++++
 src/librustc/middle/lang_items.rs |  1 +
 2 files changed, 17 insertions(+)

diff --git a/src/libcore/ops.rs b/src/libcore/ops.rs
index 836285b..966230e 100644
--- a/src/libcore/ops.rs
+++ b/src/libcore/ops.rs
@@ -87,6 +87,22 @@ pub trait Drop {
 
 /**
  *
+ * The `QuietEarlyDrop` trait is used to tag types whose drop
+ * invocations can be safely moved to earlier than the end of their
+ * scope without significant potential for interference with other
+ * side-effects in user code.  For example, a type whose drop method
+ * solely deallocates storage is a likely candidate for implementing
+ * `QuietEarlyDrop`.
+ *
+ * See also the `quiet_early_drop` and `unmarked_early_drop` lints.
+ */
+#[lang="quiet_early_drop"]
+pub trait QuietEarlyDrop {
+    // empty
+}
+
+/**
+ *
  * The `Add` trait is used to specify the functionality of `+`.
  *
  * # Example
diff --git a/src/librustc/middle/lang_items.rs b/src/librustc/middle/lang_items.rs
index 2602ec4..5d55fc0 100644
--- a/src/librustc/middle/lang_items.rs
+++ b/src/librustc/middle/lang_items.rs
@@ -221,6 +221,7 @@ lets_do_this! {
     SyncTraitLangItem,               "sync",                    sync_trait;
 
     DropTraitLangItem,               "drop",                    drop_trait;
+    QuietEarlyDropTraitLangItem,     "quiet_early_drop",        quiet_early_drop;
 
     AddTraitLangItem,                "add",                     add_trait;
     SubTraitLangItem,                "sub",                     sub_trait;

commit 224ed2628414a1e03529215ac52b217425ee8713
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Mon Aug 11 16:06:33 2014 +0200

    FIXME rust-needsdrop checkpoint: mashup of foundational support for `trait QuietEarlyDrop`.
    
    Most critical, generalized `lookup_vtable` to return a Result so that
    we can use it as the basis for a `is_type_impl_of_trait` predicate.
    
    There is a lot of other hackery mixed in here though (e.g. artifacts
    of other false starts), so this commit needs some heavy history edit
    love to trim it down to its cricial core.
---
 src/librustc/middle/borrowck/check_drops.rs | 238 +++++++++++++++++++++++++++++++++++++++++++++++++++++-------------
 src/librustc/middle/typeck/check/method.rs  |   2 +-
 src/librustc/middle/typeck/check/mod.rs     |  14 ++--
 src/librustc/middle/typeck/check/vtable.rs  | 398 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-------------------------------
 4 files changed, 489 insertions(+), 163 deletions(-)

diff --git a/src/librustc/middle/borrowck/check_drops.rs b/src/librustc/middle/borrowck/check_drops.rs
index 6d80d77..92ba8bf 100644
--- a/src/librustc/middle/borrowck/check_drops.rs
+++ b/src/librustc/middle/borrowck/check_drops.rs
@@ -19,15 +19,31 @@ use lint;
 use mc = middle::mem_categorization;
 use middle::dataflow;
 use middle::graph;
+use middle::lang_items::QuietEarlyDropTraitLangItem;
 use middle::cfg;
+use middle::subst::Subst;
+use middle::subst;
 use middle::ty;
 use middle::ty::TypeContents;
+use middle::typeck::check;
+use middle::typeck::infer;
+use middle::typeck;
+use middle::typeck::check::vtable::relate_trait_refs; // FIXME
+use middle::typeck::check::vtable::connect_trait_tps; // FIXME
+use middle::typeck::check::vtable::fixup_substs; // FIXME
+use middle::typeck::check::vtable::fixup_ty; // FIXME
+use middle::typeck::check::vtable::lookup_vtable_from_bounds; // FIXME
+use middle::typeck::check::vtable::lookup_vtable; // FIXME
+use middle::typeck::check::vtable; // FIXME
+use util::ppaux::Repr;
+use util::nodemap::DefIdMap;
+
+use std::cell::RefCell;
 use std::rc::Rc;
 use std::collections::hashmap::HashMap;
 use std::sync::atomics;
 use syntax::{ast,ast_map,ast_util,codemap};
 use syntax::attr::AttrMetaMethods;
-use util::ppaux::Repr;
 
 static mut warning_count: atomics::AtomicUint = atomics::INIT_ATOMIC_UINT;
 
@@ -36,7 +52,7 @@ pub fn check_drops(bccx: &BorrowckCtxt,
                    cfg: &cfg::CFG,
                    decl: &ast::FnDecl,
                    body: &ast::Block) {
-    debug!("check_dtors(body id={:?})", body.id);
+    debug!("check_drops(body id={:?})", body.id);
 
     cfg.graph.each_node(|node_index, node| {
         // Special case: do not flag violations for control flow from
@@ -177,10 +193,14 @@ pub fn check_drops(bccx: &BorrowckCtxt,
                     // (and therefore we can safely auto-drop `lp`
                     // without warning the user)
                     let kill_id = lp.kill_id(bccx.tcx);
-                    if scan_forward_for_kill_id(bccx, cfg, node_index, kill_id) {
-                        debug!("check_drops can ignore lp={} as its scope-end is imminent.",
-                               lp.repr(bccx.tcx));
-                        return true;
+                    match scan_forward_for_kill_id(bccx, cfg, node_index, kill_id)
+                    {
+                        FoundScopeEndPure => {
+                            debug!("check_drops can ignore lp={} as its scope-end is imminent.",
+                                   lp.repr(bccx.tcx));
+                            return true;
+                        }
+                        AbandonedScan => {}
                     }
 
                     // At this point, we are committed to reporting a warning to the user
@@ -203,32 +223,10 @@ pub fn check_drops(bccx: &BorrowckCtxt,
                                        on it or reinitializing it as necessary); count: {}",
                                       loan_path_str, where, count);
 
-                    // Check if the type of `lp` has #[quiet_early_drop] attribute,
-                    // and select the appropriate lint to signal.
-                    let t = lp.to_type(bccx.tcx);
-                    let is_quiet_early_drop = match ty::get(t).sty {
-                        ty::ty_struct(did, _) |
-                        ty::ty_enum(did, _) => {
-                            with_attrs_for_did(bccx.tcx, did, |attrs| {
-                                for attr in attrs.iter() {
-                                    if attr.check_name("quiet_early_drop") {
-                                        return true
-                                    }
-                                }
-                                return false;
-                            })
-                        }
-                        ty::ty_closure(ref f) => {
-                            match f.store {
-                                ty::RegionTraitStore(..) => true,
-                                ty::UniqTraitStore => false,
-                            }
-                        }
-                        ty::ty_unboxed_closure(_) => false,
-                        _ => false,
-                    };
-
-                    let lint_category = if is_quiet_early_drop {
+                    // Check if type of `lp` has #[quiet_early_drop]
+                    // attribute or implements `QuietEarlyDrop`;
+                    // select the appropriate lint to signal.
+                    let lint_category = if is_quiet_early_drop(bccx.tcx, &**lp) {
                         lint::builtin::QUIET_EARLY_DROP
                     } else {
                         lint::builtin::UNMARKED_EARLY_DROP
@@ -279,10 +277,19 @@ pub fn check_drops(bccx: &BorrowckCtxt,
     });
 }
 
+// This uses an enum rather than a bool to support future handling of
+// walking over paths with potentially significant effects; e.g. see
+// notes below with ExprPath.
+#[deriving(PartialEq)]
+enum ForwardScanResult {
+    FoundScopeEndPure,
+    AbandonedScan,
+}
+
 fn scan_forward_for_kill_id(bccx: &BorrowckCtxt,
-                           cfg: &cfg::CFG,
-                           start: cfg::CFGIndex,
-                           kill_id: ast::NodeId) -> bool {
+                            cfg: &cfg::CFG,
+                            start: cfg::CFGIndex,
+                            kill_id: ast::NodeId) -> ForwardScanResult {
     //! returns true only if there is a unique effect-free successor
     //! chain from `start` to `kill_id` or to `cfg.exit`
 
@@ -300,27 +307,33 @@ fn scan_forward_for_kill_id(bccx: &BorrowckCtxt,
 
         if count != 1 {
             debug!("fwd-scan: broken successor chain; give up");
-            return false;
+            return AbandonedScan;
         }
 
         cursor = cfg.graph.edge(successor.unwrap()).target();
         if cursor == cfg.exit {
             debug!("fwd-scan: success (hit exit), no need for warning");
-            return true;
+            return FoundScopeEndPure;
         }
 
         let successor_id = cfg.graph.node(cursor).data.id;
         if successor_id == ast::DUMMY_NODE_ID {
             debug!("fwd-scan: dummy node in flow graph; give up");
-            return false;
+            return AbandonedScan;
         }
 
         if successor_id == kill_id {
             debug!("fwd-scan: success (hit {}), no need for warning", kill_id);
-            return true;
+            return FoundScopeEndPure;
         }
 
         match bccx.tcx.map.get(successor_id) {
+            // See notes below about ExprPath handling.  Note that
+            // NodeLocal and NodeArg correespond to binding sites, not
+            // uses. Skipping these is likely to not matter too much
+            // until some ExprPath's are treated as pure.
+            ast_map::NodeLocal(_) |
+            ast_map::NodeArg(_)   |
             ast_map::NodeBlock(_) => {
                 debug!("fwd-scan: node {} effect-free; continue looking",
                        successor_id);
@@ -331,12 +344,17 @@ fn scan_forward_for_kill_id(bccx: &BorrowckCtxt,
                 // Keep in mind when reading these cases that the
                 // NodeId associated with an expression node like
                 // ExprIf is at the *end* of the expression, where the
-                // two arms of the if join.
+                // two arms of the if meet.
                 match e.node {
+                    // node is where arms of match meet.
                     ast::ExprMatch(..) |
+                    // node is where block exits.
                     ast::ExprBlock(..) |
+                    // (<expr>) is definitely pure.
                     ast::ExprParen(..) |
+                    // node is after arg is evaluated; before return itself.
                     ast::ExprRet(..)   |
+                    // node is where arms of if meet.
                     ast::ExprIf(..) => {
                         debug!("fwd-scan: expr {} effect-free; \
                                 continue looking",
@@ -344,22 +362,65 @@ fn scan_forward_for_kill_id(bccx: &BorrowckCtxt,
                         continue;
                     }
 
+                    // variable lookup
+                    ast::ExprPath(ref p) => {
+                        // Strictly speaking, this is an observable
+                        // effect. In particular, if a destructor has
+                        // access to the address of this path and
+                        // imperatively overwrites it, then a client
+                        // will care about the drop order.
+                        //
+                        // A captured `&mut`-ref cannot actually alias
+                        // such a path, according to Rust's borrowing
+                        // rules. Therefore, the scenario only arises
+                        // with either (1.) a `*mut`-pointer or (2.) a
+                        // `&`-ref to a type with interior mutability
+                        // (type_interior_is_unsafe). Still, it can
+                        // arise.
+                        //
+                        // The easy conservative approach is to simply
+                        // treat this as an effect and abandon the
+                        // forward-scan.
+
+                        // FIXME: A less-conservative but still sound
+                        // approach would be to treat reads of
+                        // non-local variables that had never been
+                        // borrowed as effect-free as well, and it
+                        // would probably cover many cases of
+                        // interest.  We can put that in later
+                        // (pnkfelix).
+
+                        // FIXME: A "less sound" but potentially
+                        // useful approach would be to further tier
+                        // the lint structure here to allow the user
+                        // to specify whether all variable-reads
+                        // should be treated as pure.  But I am
+                        // hesistant to make that part of the default
+                        // set of lints, at least for now (pnkfelix).
+
+                        debug!("fwd-scan: expr {} path read {} \
+                                potentially effectful; give up",
+                               successor_id, p);
+
+                        return AbandonedScan;
+                    }
+
                     _ => {
                         debug!("fwd-scan: expr {} potentially effectful; \
                                 give up",
                                successor_id);
-                        return false;
+                        return AbandonedScan;
                     }
 
                 }
             }
 
-            ast_map::NodeStmt(_)       | ast_map::NodeArg(_) |
-            ast_map::NodeLocal(_)      | ast_map::NodePat(_) |
+            ast_map::NodeStmt(_)       |
+            ast_map::NodePat(_) |
             ast_map::NodeStructCtor(_) => {
                 debug!("fwd-scan: node {} potentially effectful; give up",
                        successor_id);
-                return false;
+                return AbandonedScan;
             }
 
             ast_map::NodeItem(_)        | ast_map::NodeForeignItem(_) |
@@ -371,6 +432,56 @@ fn scan_forward_for_kill_id(bccx: &BorrowckCtxt,
     }
 }
 
+fn is_quiet_early_drop(tcx: &ty::ctxt, lp: &LoanPath) -> bool {
+    let t = lp.to_type(tcx);
+    match ty::get(t).sty {
+        ty::ty_struct(did, _) |
+        ty::ty_enum(did, _) => {
+            let found_attr = with_attrs_for_did(tcx, did, |attrs| {
+                for attr in attrs.iter() {
+                    if attr.check_name("quiet_early_drop") {
+                        return true
+                    }
+                }
+                return false;
+            });
+            if found_attr {
+                return true;
+            }
+        }
+        ty::ty_closure(ref f) => {
+            match f.store {
+                // by-ref closure
+                ty::RegionTraitStore(..) => return true,
+                ty::UniqTraitStore => {}
+            }
+        }
+        ty::ty_unboxed_closure(_) => {}
+        _ => {}
+    }
+
+    // Okay, so far we know that the type does not have the
+    // `quiet_early_drop` attribute marker, nor is it a by-ref
+    // closure.
+    //
+    // But still, it could implement the `QuietEarlyDrop` trait.
+    // Let's find out.
+
+    let opt_trait_did = tcx.lang_items.require(QuietEarlyDropTraitLangItem);
+    let trait_did = match opt_trait_did {
+        Ok(trait_did) => trait_did,
+        Err(_) => {
+            // if there is no `QuietEarlyDrop` lang item, then
+            // just do not bother trying to handle this case.
+            return false;
+        }
+    };
+
+    let ret = type_implements_trait(tcx, t, trait_did);
+    debug!("is_quiet_early_drop: type_implements_trait is {}", ret);
+    ret
+}
+
 fn with_attrs_for_did<A>(tcx: &ty::ctxt,
                          did: ast::DefId,
                          f: |&[ast::Attribute]| -> A) -> A {
@@ -389,3 +500,42 @@ fn with_attrs_for_did<A>(tcx: &ty::ctxt,
         result.unwrap()
     }
 }
+
+fn type_implements_trait(tcx: &ty::ctxt,
+                         ty: ty::t,
+                         trait_did: ast::DefId) -> bool {
+    // largely modelled after lookup_vtable
+
+    let infcx = infer::new_infer_ctxt(tcx);
+    let span = codemap::DUMMY_SP;
+    let substs = subst::Substs::empty();
+
+    let trait_def = ty::lookup_trait_def(tcx, trait_did);
+    let trait_ref = &trait_def.trait_ref;
+
+    debug!("type_implements_trait ty={} trait_ref={}",
+           ty.repr(tcx),
+           trait_ref.repr(tcx));
+
+    ty::populate_implementations_for_trait_if_necessary(tcx, trait_ref.def_id);
+
+    let substs = substs.with_self_ty(ty);
+
+    // Substitute the values of the type parameters that may
+    // appear in the bound.
+    debug!("about to subst: {}, {}", trait_ref.repr(tcx), substs.repr(tcx));
+    let trait_ref = trait_ref.subst(tcx, &substs);
+
+    debug!("after subst: {}", trait_ref.repr(tcx));
+
+    let param_bounds = subst::VecPerParamSpace::empty();
+    let unboxed_closure_types = RefCell::new(DefIdMap::new());
+
+    let vcx = vtable::VtableContext {
+        infcx: &infcx,
+        param_bounds: &param_bounds,
+        unboxed_closure_types: &unboxed_closure_types,
+    };
+
+    return lookup_vtable(&vcx, span, ty, trait_ref, false).is_ok();
+}
diff --git a/src/librustc/middle/typeck/check/method.rs b/src/librustc/middle/typeck/check/method.rs
index 88d9a58..827eed9 100644
--- a/src/librustc/middle/typeck/check/method.rs
+++ b/src/librustc/middle/typeck/check/method.rs
@@ -820,7 +820,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {
         let TypeAndSubsts {
             substs: impl_substs,
             ty: impl_ty
-        } = impl_self_ty(&vcx, span, impl_did);
+        } = impl_self_ty(vcx.tcx(), vcx.infcx, span, impl_did);
 
         let candidates = if is_extension {
             &mut self.extension_candidates
diff --git a/src/librustc/middle/typeck/check/mod.rs b/src/librustc/middle/typeck/check/mod.rs
index 9cd227d..5c3dc4e 100644
--- a/src/librustc/middle/typeck/check/mod.rs
+++ b/src/librustc/middle/typeck/check/mod.rs
@@ -1583,7 +1583,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {
     pub fn vtable_context<'a>(&'a self) -> VtableContext<'a, 'tcx> {
         VtableContext {
             infcx: self.infcx(),
-            param_env: &self.inh.param_env,
+            param_bounds: &self.inh.param_env.bounds,
             unboxed_closures: &self.inh.unboxed_closures,
         }
     }
@@ -2571,20 +2571,18 @@ fn check_expr_with_lvalue_pref(fcx: &FnCtxt, expr: &ast::Expr,
 // declared on the impl declaration e.g., `impl<A,B> for ~[(A,B)]`
 // would return ($0, $1) where $0 and $1 are freshly instantiated type
 // variables.
-pub fn impl_self_ty(vcx: &VtableContext,
+pub fn impl_self_ty(tcx: &ty::ctxt,
+                    infcx: &infer::InferCtxt,
                     span: Span, // (potential) receiver for this impl
-                    did: ast::DefId)
-                    -> TypeAndSubsts {
-    let tcx = vcx.tcx();
-
+                    did: ast::DefId) -> TypeAndSubsts {
     let ity = ty::lookup_item_type(tcx, did);
     let (n_tps, rps, raw_ty) =
         (ity.generics.types.len(subst::TypeSpace),
          ity.generics.regions.get_slice(subst::TypeSpace),
          ity.ty);
 
-    let rps = vcx.infcx.region_vars_for_defs(span, rps);
-    let tps = vcx.infcx.next_ty_vars(n_tps);
+    let rps = infcx.region_vars_for_defs(span, rps);
+    let tps = infcx.next_ty_vars(n_tps);
     let substs = subst::Substs::new_type(tps, rps);
     let substd_ty = raw_ty.subst(tcx, &substs);
 
diff --git a/src/librustc/middle/typeck/check/vtable.rs b/src/librustc/middle/typeck/check/vtable.rs
index 16136fc..a222025 100644
--- a/src/librustc/middle/typeck/check/vtable.rs
+++ b/src/librustc/middle/typeck/check/vtable.rs
@@ -70,20 +70,30 @@ use syntax::visit::Visitor;
 /// and a list of unboxed closure types.
 pub struct VtableContext<'a, 'tcx: 'a> {
     pub infcx: &'a infer::InferCtxt<'a, 'tcx>,
-    pub param_env: &'a ty::ParameterEnvironment,
+    pub param_bounds: &'a VecPerParamSpace<ty::ParamBounds>,
     pub unboxed_closures: &'a RefCell<DefIdMap<ty::UnboxedClosure>>,
 }
 
 impl<'a, 'tcx> VtableContext<'a, 'tcx> {
     pub fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.infcx.tcx }
+
+    fn ok_or_die<A>(&self, r: VtResult<A>) -> A {
+        match r {
+            Ok(r) => r,
+            Err((span, msg)) => self.tcx().sess.span_fatal(span, msg.as_slice()),
+        }
+    }
 }
 
-fn lookup_vtables(vcx: &VtableContext,
+pub type ErrMsg = (Span, String);
+pub type VtResult<A> = Result<A, ErrMsg>;
+
+pub fn lookup_vtables(vcx: &VtableContext,
                   span: Span,
                   type_param_defs: &VecPerParamSpace<ty::TypeParameterDef>,
                   substs: &subst::Substs,
                   is_early: bool)
-                  -> VecPerParamSpace<vtable_param_res> {
+                  -> VtResult<VecPerParamSpace<vtable_param_res>> {
     debug!("lookup_vtables(\
            type_param_defs={}, \
            substs={}",
@@ -91,31 +101,44 @@ fn lookup_vtables(vcx: &VtableContext,
            substs.repr(vcx.tcx()));
 
     // We do this backwards for reasons discussed above.
-    let result = type_param_defs.map_rev(|def| {
+    let result = type_param_defs.try_map_rev(|def| {
         let ty = *substs.types.get(def.space, def.index);
         lookup_vtables_for_param(vcx, span, Some(substs),
                                  &def.bounds, ty, is_early)
     });
 
-    debug!("lookup_vtables result(\
-            type_param_defs={}, \
-            substs={}, \
-            result={})",
-           type_param_defs.repr(vcx.tcx()),
-           substs.repr(vcx.tcx()),
-           result.repr(vcx.tcx()));
+    match result {
+        Ok(ref result) => {
+            debug!("lookup_vtables result(\
+                   type_param_defs={}, \
+                   substs={}, \
+                   result={})",
+                   type_param_defs.repr(vcx.tcx()),
+                   substs.repr(vcx.tcx()),
+                   result.repr(vcx.tcx()));
+        }
+        Err(ref payload) => {
+            debug!("lookup_vtables result err(\
+                   type_param_defs={}, \
+                   substs={}, \
+                   result={})",
+                   type_param_defs.repr(vcx.tcx()),
+                   substs.repr(vcx.tcx()),
+                   payload.ref1());
+        }
+    }
 
     result
 }
 
-fn lookup_vtables_for_param(vcx: &VtableContext,
+pub fn lookup_vtables_for_param(vcx: &VtableContext,
                             span: Span,
                             // None for substs means the identity
                             substs: Option<&subst::Substs>,
                             type_param_bounds: &ty::ParamBounds,
                             ty: ty::t,
                             is_early: bool)
-                            -> vtable_param_res {
+                            -> VtResult<vtable_param_res> {
     let tcx = vcx.tcx();
 
     debug!("lookup_vtables_for_param(ty={}, type_param_bounds={}, is_early={})",
@@ -125,6 +148,7 @@ fn lookup_vtables_for_param(vcx: &VtableContext,
 
     // ty is the value supplied for the type parameter A...
     let mut param_result = Vec::new();
+    let mut first_error = None;
 
     ty::each_bound_trait_and_supertraits(tcx,
                                          type_param_bounds.trait_bounds
@@ -151,34 +175,46 @@ fn lookup_vtables_for_param(vcx: &VtableContext,
         debug!("after subst: {}", trait_ref.repr(tcx));
 
         match lookup_vtable(vcx, span, ty, trait_ref.clone(), is_early) {
-            Some(vtable) => param_result.push(vtable),
-            None => {
-                vcx.tcx().sess.span_err(span,
+            Ok(Some(vtable)) => {
+                param_result.push(vtable);
+            }
+            Ok(None) => {
+                let msg =
                     format!("failed to find an implementation of \
-                          trait {} for {}",
-                         vcx.infcx.trait_ref_to_string(&*trait_ref),
-                         vcx.infcx.ty_to_string(ty)).as_slice());
+                            trait {} for {}",
+                            vcx.infcx.trait_ref_to_string(&*trait_ref),
+                            vcx.infcx.ty_to_string(ty).as_slice());
                 param_result.push(vtable_error)
+                first_error = Some((span, msg));
+            }
+            Err(msg) => {
+                first_error = Some(msg);
             }
         }
-        true
+        first_error.is_none()
     });
 
-    debug!("lookup_vtables_for_param result(\
-            type_param_bounds={}, \
-            ty={}, \
-            result={})",
-           type_param_bounds.repr(vcx.tcx()),
-           ty.repr(vcx.tcx()),
-           param_result.repr(vcx.tcx()));
-
-    param_result
+    match first_error {
+        Some(error_payload) => Err(error_payload),
+        None => {
+            debug!("lookup_vtables_for_param result(\
+                   type_param_bounds={}, \
+                   ty={}, \
+                   result={})",
+                   type_param_bounds.repr(vcx.tcx()),
+                   ty.repr(vcx.tcx()),
+                   param_result.repr(vcx.tcx()));
+            Ok(param_result)
+        }
+    }
 }
 
-fn relate_trait_refs(vcx: &VtableContext,
-                     span: Span,
-                     act_trait_ref: Rc<ty::TraitRef>,
-                     exp_trait_ref: Rc<ty::TraitRef>) {
+// FIXME: this does not belong in this module anymore.
+pub fn relate_trait_refs(tcx: &ty::ctxt,
+                         infcx: &infer::InferCtxt,
+                         span: Span,
+                         act_trait_ref: Rc<ty::TraitRef>,
+                         exp_trait_ref: Rc<ty::TraitRef>) {
     /*!
      *
      * Checks that an implementation of `act_trait_ref` is suitable
@@ -186,7 +222,7 @@ fn relate_trait_refs(vcx: &VtableContext,
      * error otherwise.
      */
 
-    match infer::mk_sub_trait_refs(vcx.infcx,
+    match infer::mk_sub_trait_refs(infcx,
                                    false,
                                    infer::RelateTraitRefs(span),
                                    act_trait_ref.clone(),
@@ -197,9 +233,9 @@ fn relate_trait_refs(vcx: &VtableContext,
             // the message good.
             // Resolve any type vars in the trait refs
             let r_act_trait_ref =
-                vcx.infcx.resolve_type_vars_in_trait_ref_if_possible(&*act_trait_ref);
+                infcx.resolve_type_vars_in_trait_ref_if_possible(&*act_trait_ref);
             let r_exp_trait_ref =
-                vcx.infcx.resolve_type_vars_in_trait_ref_if_possible(&*exp_trait_ref);
+                infcx.resolve_type_vars_in_trait_ref_if_possible(&*exp_trait_ref);
             // Only print the message if there aren't any previous type errors
             // inside the types.
             if !ty::trait_ref_contains_error(&r_act_trait_ref) &&
@@ -216,19 +252,19 @@ fn relate_trait_refs(vcx: &VtableContext,
 }
 
 // Look up the vtable implementing the trait `trait_ref` at type `t`
-fn lookup_vtable(vcx: &VtableContext,
+pub fn lookup_vtable(vcx: &VtableContext,
                  span: Span,
                  ty: ty::t,
                  trait_ref: Rc<ty::TraitRef>,
                  is_early: bool)
-                 -> Option<vtable_origin>
+                 -> VtResult<Option<vtable_origin>>
 {
     debug!("lookup_vtable(ty={}, trait_ref={})",
            ty.repr(vcx.tcx()),
            trait_ref.repr(vcx.tcx()));
     let _i = indenter();
 
-    let ty = match fixup_ty(vcx, span, ty, is_early) {
+    let ty = match fixup_ty(vcx.tcx(), vcx.infcx, span, ty, is_early) {
         Some(ty) => ty,
         None => {
             // fixup_ty can only fail if this is early resolution
@@ -236,21 +272,22 @@ fn lookup_vtable(vcx: &VtableContext,
             // The type has unconstrained type variables in it, so we can't
             // do early resolution on it. Return some completely bogus vtable
             // information: we aren't storing it anyways.
-            return Some(vtable_error);
+            return Ok(Some(vtable_error));
         }
     };
 
     if ty::type_is_error(ty) {
-        return Some(vtable_error);
+        return Ok(Some(vtable_error));
     }
 
     // If the type is self or a param, we look at the trait/supertrait
     // bounds to see if they include the trait we are looking for.
     let vtable_opt = match ty::get(ty).sty {
         ty::ty_param(ParamTy {space, idx: n, ..}) => {
-            let env_bounds = &vcx.param_env.bounds;
+            let env_bounds = &vcx.param_bounds;
             let type_param_bounds = &env_bounds.get(space, n).trait_bounds;
-            lookup_vtable_from_bounds(vcx,
+            lookup_vtable_from_bounds(vcx.tcx(),
+                                      vcx.infcx,
                                       span,
                                       type_param_bounds.as_slice(),
                                       param_index {
@@ -264,7 +301,7 @@ fn lookup_vtable(vcx: &VtableContext,
         _ => None
     };
 
-    if vtable_opt.is_some() { return vtable_opt; }
+    if vtable_opt.is_some() { return Ok(vtable_opt); }
 
     // If we aren't a self type or param, or it was, but we didn't find it,
     // do a search.
@@ -273,22 +310,21 @@ fn lookup_vtable(vcx: &VtableContext,
 
 // Given a list of bounds on a type, search those bounds to see if any
 // of them are the vtable we are looking for.
-fn lookup_vtable_from_bounds(vcx: &VtableContext,
-                             span: Span,
-                             bounds: &[Rc<ty::TraitRef>],
-                             param: param_index,
-                             trait_ref: Rc<ty::TraitRef>)
-                             -> Option<vtable_origin> {
-    let tcx = vcx.tcx();
-
+pub fn lookup_vtable_from_bounds(tcx: &ty::ctxt,
+                                 infcx: &infer::InferCtxt,
+                                 span: Span,
+                                 bounds: &[Rc<ty::TraitRef>],
+                                 param: param_index,
+                                 trait_ref: Rc<ty::TraitRef>)
+                                 -> Option<vtable_origin> {
     let mut n_bound = 0;
     let mut ret = None;
     ty::each_bound_trait_and_supertraits(tcx, bounds, |bound_trait_ref| {
         debug!("checking bounds trait {}",
-               bound_trait_ref.repr(vcx.tcx()));
+               bound_trait_ref.repr(tcx));
 
         if bound_trait_ref.def_id == trait_ref.def_id {
-            relate_trait_refs(vcx, span, bound_trait_ref, trait_ref.clone());
+            relate_trait_refs(tcx, infcx, span, bound_trait_ref, trait_ref.clone());
             let vtable = vtable_param(param, n_bound);
             debug!("found param vtable: {:?}",
                    vtable);
@@ -302,7 +338,7 @@ fn lookup_vtable_from_bounds(vcx: &VtableContext,
     ret
 }
 
-fn search_for_unboxed_closure_vtable(vcx: &VtableContext,
+pub fn search_for_unboxed_closure_vtable(vcx: &VtableContext,
                                      span: Span,
                                      ty: ty::t,
                                      trait_ref: Rc<ty::TraitRef>)
@@ -375,7 +411,7 @@ fn search_for_unboxed_closure_vtable(vcx: &VtableContext,
                 ty)
         });
 
-        relate_trait_refs(vcx, span, corresponding_trait_ref, trait_ref);
+        relate_trait_refs(vcx.tcx(), vcx.infcx, span, corresponding_trait_ref, trait_ref);
         return Some(vtable_unboxed_closure(closure_def_id))
     }
 
@@ -396,7 +432,7 @@ fn search_for_vtable(vcx: &VtableContext,
                                             span,
                                             ty,
                                             trait_ref.clone()) {
-        Some(vtable_origin) => return Some(vtable_origin),
+        Some(vtable_origin) => return Ok(Some(vtable_origin)),
         None => {}
     }
 
@@ -412,7 +448,7 @@ fn search_for_vtable(vcx: &VtableContext,
     let impls = match tcx.trait_impls.borrow().find_copy(&trait_ref.def_id) {
         Some(impls) => impls,
         None => {
-            return None;
+            return Ok(None);
         }
     };
     // impls is the list of all impls in scope for trait_ref.
@@ -451,7 +487,7 @@ fn search_for_vtable(vcx: &VtableContext,
         let TypeAndSubsts {
             substs: substs,
             ty: for_ty
-        } = impl_self_ty(vcx, span, impl_did);
+        } = impl_self_ty(vcx.tcx(), vcx.infcx, span, impl_did);
         match infer::mk_eqty(vcx.infcx,
                              false,
                              infer::RelateSelfType(span),
@@ -484,7 +520,7 @@ fn search_for_vtable(vcx: &VtableContext,
                vcx.infcx.trait_ref_to_string(&*trait_ref),
                vcx.infcx.trait_ref_to_string(&*of_trait_ref));
 
-        relate_trait_refs(vcx, span, of_trait_ref, trait_ref.clone());
+        relate_trait_refs(vcx.tcx(), vcx.infcx, span, of_trait_ref, trait_ref.clone());
 
 
         // Recall that trait_ref -- the trait type we're casting to --
@@ -499,15 +535,17 @@ fn search_for_vtable(vcx: &VtableContext,
         // later in the kind checking pass.
         let im_generics =
             ty::lookup_item_type(tcx, impl_did).generics;
-        let subres = lookup_vtables(vcx,
-                                    span,
-                                    &im_generics.types,
-                                    &substs,
-                                    is_early);
+        let subres = try!(lookup_vtables(vcx,
+                                         span,
+                                         &im_generics.types,
+                                         &substs,
+                                         is_early));
 
         // substs might contain type variables, so we call
         // fixup_substs to resolve them.
-        let substs_f = match fixup_substs(vcx, span,
+        let substs_f = match fixup_substs(vcx.tcx(),
+                                          vcx.infcx,
+                                          span,
                                           trait_ref.def_id,
                                           substs,
                                           is_early) {
@@ -515,7 +553,7 @@ fn search_for_vtable(vcx: &VtableContext,
             None => {
                 assert!(is_early);
                 // Bail out with a bogus answer
-                return Some(vtable_error);
+                return Ok(Some(vtable_error));
             }
         };
 
@@ -532,7 +570,7 @@ fn search_for_vtable(vcx: &VtableContext,
         // I am a little confused about this, since it seems to be
         // very similar to the relate_trait_refs we already do,
         // but problems crop up if it is removed, so... -sully
-        connect_trait_tps(vcx, span, &substs_f, trait_ref.clone(), impl_did);
+        connect_trait_tps(vcx.tcx(), vcx.infcx, span, &substs_f, trait_ref.clone(), impl_did);
 
         // Finally, we register that we found a matching impl, and
         // record the def ID of the impl as well as the resolved list
@@ -541,31 +579,31 @@ fn search_for_vtable(vcx: &VtableContext,
     }
 
     match found.len() {
-        0 => { return None }
-        1 => return Some(found.get(0).clone()),
+        0 => { return Ok(None) }
+        1 => return Ok(Some(found.get(0).clone())),
         _ => {
             if !is_early {
                 span_err!(vcx.tcx().sess, span, E0096,
                           "multiple applicable methods in scope");
             }
-            return Some(found.get(0).clone());
+            return Ok(Some(found.get(0).clone()));
         }
     }
 }
 
-
-fn fixup_substs(vcx: &VtableContext,
-                span: Span,
-                id: ast::DefId,
-                substs: subst::Substs,
-                is_early: bool)
-                -> Option<subst::Substs> {
-    let tcx = vcx.tcx();
+// FIXME: may not belong here anymore
+pub fn fixup_substs(tcx: &ty::ctxt,
+                    infcx: &infer::InferCtxt,
+                    span: Span,
+                    id: ast::DefId,
+                    substs: subst::Substs,
+                    is_early: bool)
+                    -> Option<subst::Substs> {
     // use a dummy type just to package up the substs that need fixing up
     let t = ty::mk_trait(tcx,
                          id, substs,
                          ty::region_existential_bound(ty::ReStatic));
-    fixup_ty(vcx, span, t, is_early).map(|t_f| {
+    fixup_ty(vcx, infcx, span, t, is_early).map(|t_f| {
         match ty::get(t_f).sty {
           ty::ty_trait(ref inner) => inner.substs.clone(),
           _ => fail!("t_f should be a trait")
@@ -573,13 +611,13 @@ fn fixup_substs(vcx: &VtableContext,
     })
 }
 
-fn fixup_ty(vcx: &VtableContext,
+pub fn fixup_ty(tcx: &ty::ctxt,
+            infcx: &infer::InferCtxt,
             span: Span,
             ty: ty::t,
             is_early: bool)
             -> Option<ty::t> {
-    let tcx = vcx.tcx();
-    match resolve_type(vcx.infcx, Some(span), ty, resolve_and_force_all_but_regions) {
+    match resolve_type(infcx, Some(span), ty, resolve_and_force_all_but_regions) {
         Ok(new_type) => Some(new_type),
         Err(e) if !is_early => {
             tcx.sess.span_err(span,
@@ -594,24 +632,23 @@ fn fixup_ty(vcx: &VtableContext,
     }
 }
 
-fn connect_trait_tps(vcx: &VtableContext,
+pub fn connect_trait_tps(tcx: &ty::ctxt,
+                     infcx: &infer::InferCtxt,
                      span: Span,
                      impl_substs: &subst::Substs,
                      trait_ref: Rc<ty::TraitRef>,
                      impl_did: ast::DefId) {
-    let tcx = vcx.tcx();
-
     let impl_trait_ref = match ty::impl_trait_ref(tcx, impl_did) {
         Some(t) => t,
-        None => vcx.tcx().sess.span_bug(span,
+        None => tcx.sess.span_bug(span,
                                   "connect_trait_tps invoked on a type impl")
     };
 
     let impl_trait_ref = impl_trait_ref.subst(tcx, impl_substs);
-    relate_trait_refs(vcx, span, impl_trait_ref, trait_ref);
+    relate_trait_refs(tcx, infcx, span, impl_trait_ref, trait_ref);
 }
 
-fn insert_vtables(fcx: &FnCtxt, vtable_key: MethodCall, vtables: vtable_res) {
+pub fn insert_vtables(fcx: &FnCtxt, vtable_key: MethodCall, vtables: vtable_res) {
     debug!("insert_vtables(vtable_key={}, vtables={})",
            vtable_key, vtables.repr(fcx.tcx()));
     fcx.inh.vtable_map.borrow_mut().insert(vtable_key, vtables);
@@ -645,6 +682,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {
                   _ => {}
               }
           }
+<<<<<<< HEAD
           (&ty::ty_uniq(..), &ty::ty_uniq(..) )
           | (&ty::ty_ptr(..), &ty::ty_ptr(..) )
           | (&ty::ty_ptr(..), &ty::ty_rptr(..)) => {}
@@ -653,6 +691,141 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {
                              infer::RelateObjectBound(ex.span),
                              r_t,
                              r_s);
+||||||| merged common ancestors
+
+          (&ty::ty_uniq(ty), &ty::ty_uniq(..) ) |
+          (&ty::ty_rptr(_, ty::mt{ty, ..}), &ty::ty_rptr(..)) => {
+              match ty::get(ty).sty {
+                  ty::ty_trait(box ty::TyTrait {
+                      def_id: target_def_id, substs: ref target_substs, ..
+                  }) => {
+                      debug!("nrc correct path");
+                      let typ = match &ty::get(src_ty).sty {
+                          &ty::ty_uniq(typ) => typ,
+                          &ty::ty_rptr(_, mt) => mt.ty,
+                          _ => fail!("shouldn't get here"),
+                      };
+
+                      let vcx = fcx.vtable_context();
+
+                      // Take the type parameters from the object
+                      // type, but set the Self type (which is
+                      // unknown, for the object type) to be the type
+                      // we are casting from.
+                      let mut target_types = target_substs.types.clone();
+                      assert!(target_types.get_self().is_none());
+                      target_types.push(subst::SelfSpace, typ);
+
+                      let target_trait_ref = Rc::new(ty::TraitRef {
+                          def_id: target_def_id,
+                          substs: subst::Substs {
+                              regions: target_substs.regions.clone(),
+                              types: target_types
+                          }
+                      });
+
+                      let param_bounds = ty::ParamBounds {
+                          builtin_bounds: ty::empty_builtin_bounds(),
+                          trait_bounds: vec!(target_trait_ref)
+                      };
+                      let vtables =
+                            lookup_vtables_for_param(&vcx,
+                                                     ex.span,
+                                                     None,
+                                                     &param_bounds,
+                                                     typ,
+                                                     is_early);
+
+                      if !is_early {
+                          let mut r = VecPerParamSpace::empty();
+                          r.push(subst::SelfSpace, vtables);
+                          insert_vtables(fcx, key, r);
+                      }
+
+                      // Now, if this is &trait, we need to link the
+                      // regions.
+                      match (&ty::get(src_ty).sty, &ty::get(target_ty).sty) {
+                          (&ty::ty_rptr(ra, _), &ty::ty_rptr(rb, _)) => {
+                              debug!("nrc - make subr");
+                              infer::mk_subr(fcx.infcx(),
+                                             false,
+                                             infer::RelateObjectBound(ex.span),
+                                             rb,
+                                             ra);
+                          }
+                          _ => {}
+                      }
+                  }
+                  _ => {}
+              }
+=======
+
+          (&ty::ty_uniq(ty), &ty::ty_uniq(..) ) |
+          (&ty::ty_rptr(_, ty::mt{ty, ..}), &ty::ty_rptr(..)) => {
+              match ty::get(ty).sty {
+                  ty::ty_trait(box ty::TyTrait {
+                      def_id: target_def_id, substs: ref target_substs, ..
+                  }) => {
+                      debug!("nrc correct path");
+                      let typ = match &ty::get(src_ty).sty {
+                          &ty::ty_uniq(typ) => typ,
+                          &ty::ty_rptr(_, mt) => mt.ty,
+                          _ => fail!("shouldn't get here"),
+                      };
+
+                      let vcx = fcx.vtable_context();
+
+                      // Take the type parameters from the object
+                      // type, but set the Self type (which is
+                      // unknown, for the object type) to be the type
+                      // we are casting from.
+                      let mut target_types = target_substs.types.clone();
+                      assert!(target_types.get_self().is_none());
+                      target_types.push(subst::SelfSpace, typ);
+
+                      let target_trait_ref = Rc::new(ty::TraitRef {
+                          def_id: target_def_id,
+                          substs: subst::Substs {
+                              regions: target_substs.regions.clone(),
+                              types: target_types
+                          }
+                      });
+
+                      let param_bounds = ty::ParamBounds {
+                          builtin_bounds: ty::empty_builtin_bounds(),
+                          trait_bounds: vec!(target_trait_ref)
+                      };
+                      let vtables = vcx.ok_or_die(
+                          lookup_vtables_for_param(&vcx,
+                                                   ex.span,
+                                                   None,
+                                                   &param_bounds,
+                                                   typ,
+                                                   is_early));
+
+                      if !is_early {
+                          let mut r = VecPerParamSpace::empty();
+                          r.push(subst::SelfSpace, vtables);
+                          insert_vtables(fcx, key, r);
+                      }
+
+                      // Now, if this is &trait, we need to link the
+                      // regions.
+                      match (&ty::get(src_ty).sty, &ty::get(target_ty).sty) {
+                          (&ty::ty_rptr(ra, _), &ty::ty_rptr(rb, _)) => {
+                              debug!("nrc - make subr");
+                              infer::mk_subr(fcx.infcx(),
+                                             false,
+                                             infer::RelateObjectBound(ex.span),
+                                             rb,
+                                             ra);
+                          }
+                          _ => {}
+                      }
+                  }
+                  _ => {}
+              }
+>>>>>>> FIXME rust-needsdrop checkpoint: mashup of foundational support for `trait QuietEarlyDrop`.
           }
           (&ty::ty_uniq(ty), _) => {
               match ty::get(ty).sty {
@@ -752,9 +925,10 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {
             debug!("early_resolve_expr: looking up vtables for type params {}",
                    item_ty.generics.types.repr(fcx.tcx()));
             let vcx = fcx.vtable_context();
-            let vtbls = lookup_vtables(&vcx, ex.span,
-                                       &item_ty.generics.types,
-                                       &item_substs.substs, is_early);
+            let vtbls = vcx.ok_or_die(
+                lookup_vtables(&vcx, ex.span,
+                               &item_ty.generics.types,
+                               &item_substs.substs, is_early));
             if !is_early {
                 insert_vtables(fcx, MethodCall::expr(ex.id), vtbls);
             }
@@ -777,9 +951,10 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {
                   ty::method_call_type_param_defs(fcx, method.origin);
               let substs = fcx.method_ty_substs(ex.id);
               let vcx = fcx.vtable_context();
-              let vtbls = lookup_vtables(&vcx, ex.span,
-                                         &type_param_defs,
-                                         &substs, is_early);
+              let vtbls = vcx.ok_or_die(
+                  lookup_vtables(&vcx, ex.span,
+                                 &type_param_defs,
+                                 &substs, is_early));
               if !is_early {
                   insert_vtables(fcx, MethodCall::expr(ex.id), vtbls);
               }
@@ -836,9 +1011,10 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {
                                 let type_param_defs =
                                     ty::method_call_type_param_defs(cx.tcx, method.origin);
                                 let vcx = fcx.vtable_context();
-                                let vtbls = lookup_vtables(&vcx, ex.span,
-                                                           &type_param_defs,
-                                                           &method.substs, is_early);
+                                let vtbls = vcx.ok_or_die(
+                                    lookup_vtables(&vcx, ex.span,
+                                                   &type_param_defs,
+                                                   &method.substs, is_early));
                                 if !is_early {
                                     insert_vtables(fcx, method_call, vtbls);
                                 }
@@ -961,7 +1137,7 @@ pub fn resolve_impl(tcx: &ty::ctxt,
     let unboxed_closures = RefCell::new(DefIdMap::new());
     let vcx = VtableContext {
         infcx: infcx,
-        param_env: &param_env,
+        param_env: &param_env.bounds,
         unboxed_closures: &unboxed_closures,
     };
 
@@ -988,11 +1164,12 @@ pub fn resolve_impl(tcx: &ty::ctxt,
     //     fn default_x<T:B, Self:A>(...) { .. .})
 
     let trait_def = ty::lookup_trait_def(tcx, impl_trait_ref.def_id);
-    let vtbls = lookup_vtables(&vcx,
-                                   impl_item.span,
-                                   &trait_def.generics.types,
-                                   &impl_trait_ref.substs,
-                                   false);
+    let vtbls = vcx.ok_or_die(
+        lookup_vtables(&vcx,
+                       impl_item.span,
+                       &trait_def.generics.types,
+                       &impl_trait_ref.substs,
+                       false));
 
     infcx.resolve_regions_and_report_errors();
 
@@ -1012,17 +1189,18 @@ pub fn trans_resolve_method(tcx: &ty::ctxt, id: ast::NodeId,
                             substs: &subst::Substs) -> vtable_res {
     let generics = ty::lookup_item_type(tcx, ast_util::local_def(id)).generics;
     let unboxed_closures = RefCell::new(DefIdMap::new());
+    let param_env = ty::construct_parameter_environment(tcx, &ty::Generics::empty(), id);
     let vcx = VtableContext {
         infcx: &infer::new_infer_ctxt(tcx),
-        param_env: &ty::construct_parameter_environment(tcx, &ty::Generics::empty(), id),
+        param_bounds: &param_env.bounds,
         unboxed_closures: &unboxed_closures,
     };
 
-    lookup_vtables(&vcx,
-                   tcx.map.span(id),
-                   &generics.types,
-                   substs,
-                   false)
+    vcx.ok_or_die(lookup_vtables(&vcx,
+                                 tcx.map.span(id),
+                                 &generics.types,
+                                 substs,
+                                 false))
 }
 
 impl<'a, 'b, 'tcx> visit::Visitor<()> for &'a FnCtxt<'b, 'tcx> {

commit 072927b36ccfaebd162eee1e688bca5f02e44c6c
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Mon Aug 11 15:59:52 2014 +0200

    result-generalization: add `try_map_rev` to VecPerParamSpace.
---
 src/librustc/middle/subst.rs | 29 +++++++++++++++++++++++++----
 1 file changed, 25 insertions(+), 4 deletions(-)

diff --git a/src/librustc/middle/subst.rs b/src/librustc/middle/subst.rs
index c1c23df..5731bce 100644
--- a/src/librustc/middle/subst.rs
+++ b/src/librustc/middle/subst.rs
@@ -18,6 +18,7 @@ use util::ppaux::Repr;
 use std::fmt;
 use std::mem;
 use std::raw;
+use std::result;
 use std::slice::{Items, MutItems};
 use std::vec::Vec;
 use syntax::codemap::{Span, DUMMY_SP};
@@ -467,18 +468,38 @@ impl<T> VecPerParamSpace<T> {
          * can be run to a fixed point
          */
 
-        let mut fns: Vec<U> = self.get_slice(FnSpace).iter().rev().map(|p| pred(p)).collect();
+        let f = |t:&T| -> Result<U,()> { Ok(pred(t)) };
+
+        self.try_map_rev::<U,()>(f).unwrap()
+    }
+
+    pub fn try_map_rev<U,E>(&self, f: |&T| -> Result<U, E>) -> Result<VecPerParamSpace<U>, E> {
+        /*!
+         * If all of the calls to `f` are `Ok`, then behaves like
+         * `map_rev`, (executing the map but in reverse order).
+         * Otherwise, returns the first error encountered during the
+         * map execution.
+         */
+
+        let mut fns: Vec<U> = try!(result::collect(
+            self.get_slice(FnSpace).iter().rev().map(|p| f(p))));
 
         // NB: Calling foo.rev().map().rev() causes the calls to map
         // to occur in the wrong order. This was somewhat surprising
         // to me, though it makes total sense.
         fns.reverse();
 
-        let mut selfs: Vec<U> = self.get_slice(SelfSpace).iter().rev().map(|p| pred(p)).collect();
+        let mut selfs: Vec<U> = try!(result::collect(
+            self.get_slice(SelfSpace).iter().rev().map(|p| f(p))));
+
         selfs.reverse();
-        let mut tys: Vec<U> = self.get_slice(TypeSpace).iter().rev().map(|p| pred(p)).collect();
+
+        let mut tys: Vec<U> = try!(result::collect(
+            self.get_slice(TypeSpace).iter().rev().map(|p| f(p))));
+
         tys.reverse();
-        VecPerParamSpace::new(tys, selfs, fns)
+
+        Ok(VecPerParamSpace::new(tys, selfs, fns))
     }
 
     pub fn split(self) -> (Vec<T>, Vec<T>, Vec<T>) {

commit c35b731e58e11681d2def0b610ce11e11f38dc8e
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Sat Aug 9 14:52:51 2014 +0200

    rust-needsdrop: Make by-ref closures implicitly #[quiet_early_drop].
    
    The reasoning here is that by-ref closures cannot have any
    side-effects when they are dropped (hile by-move closures might have
    side-effects when dropped).
---
 src/librustc/middle/borrowck/check_drops.rs | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/src/librustc/middle/borrowck/check_drops.rs b/src/librustc/middle/borrowck/check_drops.rs
index f40df53..6d80d77 100644
--- a/src/librustc/middle/borrowck/check_drops.rs
+++ b/src/librustc/middle/borrowck/check_drops.rs
@@ -218,6 +218,13 @@ pub fn check_drops(bccx: &BorrowckCtxt,
                                 return false;
                             })
                         }
+                        ty::ty_closure(ref f) => {
+                            match f.store {
+                                ty::RegionTraitStore(..) => true,
+                                ty::UniqTraitStore => false,
+                            }
+                        }
+                        ty::ty_unboxed_closure(_) => false,
                         _ => false,
                     };
 

commit 5c5418c439c18cf6680b2d86a0d64d6a9dd8b37d
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Sat Aug 9 12:45:47 2014 +0200

    root testsuite: test quiet_early_drop attribute.
    
    In tandem, test quiet_early_drop and unmarked_early_drop lint settings.
---
 Makefile      |  7 ++++---
 foo42_fine.rs | 30 ++++++++++++++++++++++++++++++
 foo43_warn.rs | 31 +++++++++++++++++++++++++++++++
 foo44_fine.rs | 30 ++++++++++++++++++++++++++++++
 4 files changed, 95 insertions(+), 3 deletions(-)

diff --git a/Makefile b/Makefile
index 1edfa73..809173c 100644
--- a/Makefile
+++ b/Makefile
@@ -3,13 +3,14 @@ FILES_WARN=foo01_warn.rs               foo03_warn.rs foo04_warn.rs foo05_warn.rs
                          foo17_warn.rs foo18_warn.rs                             \
                                                                    foo25_warn.rs \
            foo26_warn.rs foo27_warn.rs foo28_warn.rs                             \
-           foo31_warn.rs
-
+           foo31_warn.rs                                                         \
+                                       foo43_warn.rs
 FILES_FINE=              foo02_fine.rs                                           \
            foo11_fine.rs foo12_fine.rs foo13_fine.rs foo14_fine.rs foo15_fine.rs \
                                        foo23_fine.rs foo24_fine.rs               \
                                                      foo29_fine.rs foo30_fine.rs \
-                         foo32_fine.rs foo33_fine.rs foo34_fine.rs
+                         foo32_fine.rs foo33_fine.rs foo34_fine.rs               \
+                         foo42_fine.rs               foo44_fine.rs
 
 FILES_UNCATEGORIZED=                                                             \
            foo16.rs                                  foo19.rs      foo20.rs      \
diff --git a/foo42_fine.rs b/foo42_fine.rs
new file mode 100644
index 0000000..32ed6d2
--- /dev/null
+++ b/foo42_fine.rs
@@ -0,0 +1,30 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+#[lang="drop"] pub trait Drop { fn drop(&mut self); }
+
+pub struct Foo<X,Y> { _x: X, _y: Y }
+
+#[quiet_early_drop]
+pub struct S;
+
+impl Drop for S { fn drop(&mut self) { } }
+
+pub fn foo<Y:Copy>(b: bool, c: || -> Foo<S,Y>, f: |S| -> int, _g: |Y| -> int) -> int {
+    let s = c();
+    //                                                          // NEEDS_DROP={s}
+    let ret = if b {
+    //                                                          // NEEDS_DROP={s}
+        f(s._x) // Path s._x moved in this branch ...
+    //                                                          // NEEDS_DROP={}
+    } else {
+    //                                                          // NEEDS_DROP={s}
+        3    // ... but not this one ...
+    //                                                          // NEEDS_DROP={s}
+    }; // ... but S is quiet_early_drop, so fine.
+    c();
+    ret
+}
diff --git a/foo43_warn.rs b/foo43_warn.rs
new file mode 100644
index 0000000..c3c254e
--- /dev/null
+++ b/foo43_warn.rs
@@ -0,0 +1,31 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+#[lang="drop"] pub trait Drop { fn drop(&mut self); }
+
+pub struct Foo<X,Y> { _x: X, _y: Y }
+
+#[quiet_early_drop]
+pub struct S;
+
+impl Drop for S { fn drop(&mut self) { } }
+
+#[warn(quiet_early_drop)]
+pub fn foo<Y:Copy>(b: bool, c: || -> Foo<S,Y>, f: |S| -> int, _g: |Y| -> int) -> int {
+    let s = c();
+    //                                                          // NEEDS_DROP={s}
+    let ret = if b {
+    //                                                          // NEEDS_DROP={s}
+        f(s._x) // Path s._x moved in this branch ...
+    //                                                          // NEEDS_DROP={}
+    } else {
+    //                                                          // NEEDS_DROP={s}
+        3    // ... but not this one ...
+    //                                                          // NEEDS_DROP={s}
+    }; // ... thus expect notice here (requested warn on quiet_early_drop)
+    c();
+    ret
+}
diff --git a/foo44_fine.rs b/foo44_fine.rs
new file mode 100644
index 0000000..de4d8d0
--- /dev/null
+++ b/foo44_fine.rs
@@ -0,0 +1,30 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+#[lang="drop"] pub trait Drop { fn drop(&mut self); }
+
+pub struct Foo<X,Y> { _x: X, _y: Y }
+
+pub struct S;
+
+impl Drop for S { fn drop(&mut self) { } }
+
+#[allow(unmarked_early_drop)]
+pub fn foo<Y:Copy>(b: bool, c: || -> Foo<S,Y>, f: |S| -> int, _g: |Y| -> int) -> int {
+    let s = c();
+    //                                                          // NEEDS_DROP={s}
+    let ret = if b {
+    //                                                          // NEEDS_DROP={s}
+        f(s._x) // Path s._x moved in this branch ...
+    //                                                          // NEEDS_DROP={}
+    } else {
+    //                                                          // NEEDS_DROP={s}
+        3    // ... but not this one ...
+    //                                                          // NEEDS_DROP={s}
+    }; // ... but we allow unmarked_early_drop above, so fine.
+    c();
+    ret
+}

commit 7b3d2d1350d8ee8e3309ae8b82a96a86399551df
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Sat Aug 9 12:42:01 2014 +0200

    rust-needsdrop: support quiet_early_drop attribute for individual types.
    
    Note that such quieting is not transitive, nor does it check the
    interior of the structure.  E.g. given quiet_early_drop `S`,
    `Option<S>` is still loud, at moment.  (I want to see how much bang
    for buck I get out of this simple version, though I suspect a trait
    bound is probably inevitable.)
---
 src/librustc/lint/builtin.rs                | 11 ++++++++---
 src/librustc/middle/borrowck/check_drops.rs | 48 ++++++++++++++++++++++++++++++++++++++++++++++--
 2 files changed, 54 insertions(+), 5 deletions(-)

diff --git a/src/librustc/lint/builtin.rs b/src/librustc/lint/builtin.rs
index 8458d30..ded7044 100644
--- a/src/librustc/lint/builtin.rs
+++ b/src/librustc/lint/builtin.rs
@@ -618,6 +618,7 @@ impl LintPass for UnusedAttribute {
             "must_use",
             "stable",
             "unstable",
+            "quiet_early_drop",
         ];
 
         static CRATE_ATTRS: &'static [&'static str] = &[
@@ -1554,8 +1555,11 @@ declare_lint!(pub VISIBLE_PRIVATE_TYPES, Warn,
 declare_lint!(pub UNREACHABLE_CODE, Warn,
               "detects unreachable code")
 
-declare_lint!(pub EARLY_DROP, Warn,
-              "detect drops that will happen earlier when drop flags are gone")
+declare_lint!(pub QUIET_EARLY_DROP, Allow,
+              "detect (soon to be) early drops of #[quiet_early_drop] types")
+
+declare_lint!(pub UNMARKED_EARLY_DROP, Warn,
+              "detect (soon to be) early drops of non-#[quiet_early_drop] types")
 
 declare_lint!(pub WARNINGS, Warn,
               "mass-change the level for lints which produce warnings")
@@ -1585,7 +1589,8 @@ impl LintPass for HardwiredLints {
             UNUSED_VARIABLE,
             DEAD_ASSIGNMENT,
             DEAD_CODE,
-            EARLY_DROP,
+            QUIET_EARLY_DROP,
+            UNMARKED_EARLY_DROP,
             VISIBLE_PRIVATE_TYPES,
             UNREACHABLE_CODE,
             WARNINGS,
diff --git a/src/librustc/middle/borrowck/check_drops.rs b/src/librustc/middle/borrowck/check_drops.rs
index d85ab6a..f40df53 100644
--- a/src/librustc/middle/borrowck/check_drops.rs
+++ b/src/librustc/middle/borrowck/check_drops.rs
@@ -11,6 +11,7 @@
 #![allow(unused_imports)]
 #![allow(unused_variable)]
 
+use metadata::csearch;
 use middle::borrowck::*;
 use middle::borrowck::move_data::{Assignment, Move};
 use euv = middle::expr_use_visitor;
@@ -24,7 +25,8 @@ use middle::ty::TypeContents;
 use std::rc::Rc;
 use std::collections::hashmap::HashMap;
 use std::sync::atomics;
-use syntax::{ast,ast_map,codemap};
+use syntax::{ast,ast_map,ast_util,codemap};
+use syntax::attr::AttrMetaMethods;
 use util::ppaux::Repr;
 
 static mut warning_count: atomics::AtomicUint = atomics::INIT_ATOMIC_UINT;
@@ -201,7 +203,30 @@ pub fn check_drops(bccx: &BorrowckCtxt,
                                        on it or reinitializing it as necessary); count: {}",
                                       loan_path_str, where, count);
 
-                    bccx.tcx.sess.add_lint(lint::builtin::EARLY_DROP,
+                    // Check if the type of `lp` has #[quiet_early_drop] attribute,
+                    // and select the appropriate lint to signal.
+                    let t = lp.to_type(bccx.tcx);
+                    let is_quiet_early_drop = match ty::get(t).sty {
+                        ty::ty_struct(did, _) |
+                        ty::ty_enum(did, _) => {
+                            with_attrs_for_did(bccx.tcx, did, |attrs| {
+                                for attr in attrs.iter() {
+                                    if attr.check_name("quiet_early_drop") {
+                                        return true
+                                    }
+                                }
+                                return false;
+                            })
+                        }
+                        _ => false,
+                    };
+
+                    let lint_category = if is_quiet_early_drop {
+                        lint::builtin::QUIET_EARLY_DROP
+                    } else {
+                        lint::builtin::UNMARKED_EARLY_DROP
+                    };
+                    bccx.tcx.sess.add_lint(lint_category,
                                            source_id,
                                            opt_source_span.unwrap_or(codemap::DUMMY_SP),
                                            msg);
@@ -338,3 +363,22 @@ fn scan_forward_for_kill_id(bccx: &BorrowckCtxt,
         }
     }
 }
+
+fn with_attrs_for_did<A>(tcx: &ty::ctxt,
+                         did: ast::DefId,
+                         f: |&[ast::Attribute]| -> A) -> A {
+    if ast_util::is_local(did) {
+        match tcx.map.get(did.node) {
+            ast_map::NodeItem(it) => f(it.attrs.as_slice()),
+            _ => fail!("must have entry for struct or enum"),
+        }
+    } else {
+        // FIXME: interface of `get_item_attrs` could be generalized
+        // to support this directly.
+        let mut result = None;
+        csearch::get_item_attrs(&tcx.sess.cstore, did, |attrs| {
+            result = Some(f(attrs.as_slice()))
+        });
+        result.unwrap()
+    }
+}

commit 0f3dfb209e1bf6a6e3cfb94d227b36f881679367
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Fri Aug 8 19:33:14 2014 +0200

    root testsuite: added tests that attempted to check macro backtraces from extern crates.
    
    It actually failed to recreate the problem I was seeing though, which is this:
    
    https://gist.github.com/pnkfelix/383606c1fd56fa827f40
---
 Makefile         | 12 ++++++++++++
 foo41.rs         | 21 +++++++++++++++++++++
 foo41_support.rs | 12 ++++++++++++
 3 files changed, 45 insertions(+)

diff --git a/Makefile b/Makefile
index f3c4d13..1edfa73 100644
--- a/Makefile
+++ b/Makefile
@@ -59,3 +59,15 @@ RUST_LOG=rustc::middle::borrowck,rustc::middle::ty,rustc::middle::typeck,rustc::
 	RUST_LOG=$(RUST_LOG) RUST_BACKTRACE=1 $(RUSTC_LIB) $< 2> $@
 
 #	RUST_LOG=$(RUST_LOG) $(RUSTC_LIB) -Z flowgraph-print-all --pretty flowgraph=foo $< -o $@.dot 2> $@
+
+foo41.dot: foo41.rs libfoo41_support.rlib
+	RUST_BACKTRACE=1 $(RUSTC_LIB) -L . -Z flowgraph-print-all --pretty flowgraph=foo $< -o $@
+
+foo41: foo41.rs libfoo41_support.rlib
+	RUST_BACKTRACE=1 $(RUSTC_LIB) -L . $<
+
+foo41.llog: foo41.rs libfoo41_support.rlib
+	RUST_LOG=$(RUST_LOG) RUST_BACKTRACE=1 $(RUSTC_LIB) -L . $< 2> $@
+
+libfoo41_support.rlib: foo41_support.rs Makefile objdir-dbg/x86_64-apple-darwin/stage1/rustc
+	objdir-dbg/x86_64-apple-darwin/stage1/bin/rustc  foo41_support.rs --out-dir .
diff --git a/foo41.rs b/foo41.rs
new file mode 100644
index 0000000..c5a0c06
--- /dev/null
+++ b/foo41.rs
@@ -0,0 +1,21 @@
+#![feature(lang_items)]
+#![feature(macro_rules)]
+#![feature(phase)]
+#![no_std]
+#![crate_type="lib"]
+
+#[phase(plugin)]
+extern crate foo41_support;
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+
+pub fn foo() {
+    let a1 = box 3i;
+    let a2 = box 4i;
+    let b = debug_or!(proc(x:int)x+*a1,proc(y:int)y+*a2);
+    let _c = b(1);
+}
+
+pub fn main() { foo() }
diff --git a/foo41_support.rs b/foo41_support.rs
new file mode 100644
index 0000000..0324dbd
--- /dev/null
+++ b/foo41_support.rs
@@ -0,0 +1,12 @@
+#![feature(lang_items)]
+#![feature(macro_rules)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+#[macro_export]
+macro_rules! debug_or(
+    ($arg1:expr, $arg2:expr) => (if cfg!(not(ndebug)) { $arg1 } else { $arg2 })
+)

commit 0fec0fcb9ab97aaf86a447bc7b32a3c153a1d6d0
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Fri Aug 8 14:59:01 2014 +0200

    rust-needsdrop: handle arm `s @ Err(_) | s @ Ok(_) => ...` properly.
    
    To accomplish this:
    
      mem_categorization: track when we are in pat context `id @ []`.
    
      expr_use_visitor: filter out moving into wildcards when
      the pat_is_already_bound_by_value flag is set.
---
 src/librustc/middle/expr_use_visitor.rs   | 14 +++++++++++++-
 src/librustc/middle/mem_categorization.rs | 31 +++++++++++++++++++------------
 2 files changed, 32 insertions(+), 13 deletions(-)

diff --git a/src/librustc/middle/expr_use_visitor.rs b/src/librustc/middle/expr_use_visitor.rs
index 810716a..6d376a7 100644
--- a/src/librustc/middle/expr_use_visitor.rs
+++ b/src/librustc/middle/expr_use_visitor.rs
@@ -1012,7 +1012,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {
                         // Thus check the `pat_already_bound` flag to
                         // distinguish the latter two cases.
 
-                        if ! mc.pat_already_bound {
+                        if !mc.pat_is_already_bound_by_value {
                             let mode = copy_or_move(typer.tcx(), cmt_pat.ty, PatBindingMove);
                             delegate.consume_pat(pat, cmt_pat, mode);
                         }
@@ -1079,6 +1079,18 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {
         return_if_err!(mc.cat_pattern(cmt_discr, &*pat, |mc, cmt_pat, pat| {
             let def_map = def_map.borrow();
             let tcx = typer.tcx();
+            let match_mode = if mc.pat_is_already_bound_by_value {
+                // A pat in the context of `id @ ... pat ...` cannot
+                // be moved into, it can at most copy or borrow.
+                //
+                // Actually, post PR #16053, we cannot do *any*
+                // binding in such a context, but I am writing this
+                // code in anticipation of loosening that rule (FSK).
+                BorrowingMatch
+            } else {
+                match_mode
+            };
+
             match pat.node {
                 ast::PatEnum(_, _) | ast::PatIdent(_, _, None) | ast::PatStruct(..) => {
                     match def_map.find(&pat.id) {
diff --git a/src/librustc/middle/mem_categorization.rs b/src/librustc/middle/mem_categorization.rs
index 57bb1e8..a392e81 100644
--- a/src/librustc/middle/mem_categorization.rs
+++ b/src/librustc/middle/mem_categorization.rs
@@ -241,11 +241,11 @@ impl ast_node for ast::Pat {
 }
 
 pub struct MemCategorizationContext<'t,TYPER:'t> {
-    // `already_bound` tracks whether we are looking at `pat` in the
-    // context of `id @ (... pat ...)` (it affects whether we move
-    // into a wildcard or not).
-    pub pat_already_bound: bool,
-    typer: &'t TYPER
+    typer: &'t TYPER,
+
+    // tracks when looking at `pat` in context of `id @ (... pat ...)`
+    // (it affects whether we move into a wildcard or not).
+    pub pat_is_already_bound_by_value: bool,
 }
 
 pub type McResult<T> = Result<T, ()>;
@@ -381,13 +381,20 @@ macro_rules! if_ok(
 
 impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {
     pub fn new(typer: &'t TYPER) -> MemCategorizationContext<'t,TYPER> {
-        MemCategorizationContext { pat_already_bound: false,
-                                   typer: typer }
+        MemCategorizationContext {
+            typer: typer,
+            pat_is_already_bound_by_value: false,
+        }
     }
 
-    fn with_pat_already_bound(&self) -> MemCategorizationContext<'t,TYPER> {
-        MemCategorizationContext { pat_already_bound: true,
-                                   typer: self.typer }
+    fn already_bound(&self, mode: ast::BindingMode) -> MemCategorizationContext<'t,TYPER> {
+        match mode {
+            ast::BindByRef(_) => *self,
+            ast::BindByValue(_) => MemCategorizationContext {
+                pat_is_already_bound_by_value: true,
+                ..*self
+            }
+        }
     }
 
     fn tcx(&self) -> &'t ty::ctxt<'tcx> {
@@ -1105,8 +1112,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {
             }
           }
 
-          ast::PatIdent(_, _, Some(ref subpat)) => {
-              if_ok!(self.with_pat_already_bound().cat_pattern(
+          ast::PatIdent(binding_mode, _, Some(ref subpat)) => {
+              if_ok!(self.already_bound(binding_mode).cat_pattern(
                   cmt, &**subpat, op));
           }
 

commit f2c7516647a5e0ac1a61e1536e7264592b0996b7
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Fri Aug 8 14:30:34 2014 +0200

    Use `pat_already_bound` to track whether wildcard could not consume input.
---
 src/librustc/middle/expr_use_visitor.rs | 30 ++++++++++++++++++++++++------
 1 file changed, 24 insertions(+), 6 deletions(-)

diff --git a/src/librustc/middle/expr_use_visitor.rs b/src/librustc/middle/expr_use_visitor.rs
index 71d8322..810716a 100644
--- a/src/librustc/middle/expr_use_visitor.rs
+++ b/src/librustc/middle/expr_use_visitor.rs
@@ -989,17 +989,35 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {
                                              r, bk, RefBinding);
                     }
 
-                    (&ast::PatIdent(ast::BindByValue(_), _, _), _) |
-                    (&ast::PatWild(_), MovingMatch) => {
-                        // FIXME: I may need to distinguish these two
-                        // cases, since the PatWild case may end up
-                        // implying auto-drop without warning at the
-                        // end of the scope (FSK).
+                    (&ast::PatIdent(ast::BindByValue(_), _, _), _) => {
                         let mode = copy_or_move(typer.tcx(), cmt_pat.ty, PatBindingMove);
                         debug!("walk_pat binding consuming pat");
                         delegate.consume_pat(pat, cmt_pat, mode);
                     }
 
+                    (&ast::PatWild(_), MovingMatch) => {
+
+                        // On `enum E { Variant(Box<T>) }`, both of
+                        // the match arms:
+                        //
+                        //    Variant(a) => ...
+                        //    Variant(_) => ...
+                        //
+                        // are conceptually moving into the `Variant`
+                        // pattern, while the match arm:
+                        //
+                        //    a @ Variant(_) => ...
+                        //
+                        // is *not* moving into the `Variant(_)`.
+                        // Thus check the `pat_already_bound` flag to
+                        // distinguish the latter two cases.
+
+                        if ! mc.pat_already_bound {
+                            let mode = copy_or_move(typer.tcx(), cmt_pat.ty, PatBindingMove);
+                            delegate.consume_pat(pat, cmt_pat, mode);
+                        }
+                    }
+
                     (&ast::PatWild(_), NonBindingMatch) |
                     (&ast::PatWild(_), BorrowingMatch) |
                     (&ast::PatWild(_), CopyingMatch)  => {}

commit b27a24d79ac755ee0a341eed87e42368326e1a2a
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Fri Aug 8 14:29:33 2014 +0200

    rust-needsdrop mem_categorization: track when we are in pat context `id @ []`.
---
 src/librustc/middle/mem_categorization.rs | 15 +++++++++++++--
 1 file changed, 13 insertions(+), 2 deletions(-)

diff --git a/src/librustc/middle/mem_categorization.rs b/src/librustc/middle/mem_categorization.rs
index d899e8f..57bb1e8 100644
--- a/src/librustc/middle/mem_categorization.rs
+++ b/src/librustc/middle/mem_categorization.rs
@@ -241,6 +241,10 @@ impl ast_node for ast::Pat {
 }
 
 pub struct MemCategorizationContext<'t,TYPER:'t> {
+    // `already_bound` tracks whether we are looking at `pat` in the
+    // context of `id @ (... pat ...)` (it affects whether we move
+    // into a wildcard or not).
+    pub pat_already_bound: bool,
     typer: &'t TYPER
 }
 
@@ -377,7 +381,13 @@ macro_rules! if_ok(
 
 impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {
     pub fn new(typer: &'t TYPER) -> MemCategorizationContext<'t,TYPER> {
-        MemCategorizationContext { typer: typer }
+        MemCategorizationContext { pat_already_bound: false,
+                                   typer: typer }
+    }
+
+    fn with_pat_already_bound(&self) -> MemCategorizationContext<'t,TYPER> {
+        MemCategorizationContext { pat_already_bound: true,
+                                   typer: self.typer }
     }
 
     fn tcx(&self) -> &'t ty::ctxt<'tcx> {
@@ -1096,7 +1106,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {
           }
 
           ast::PatIdent(_, _, Some(ref subpat)) => {
-              if_ok!(self.cat_pattern(cmt, &**subpat, op));
+              if_ok!(self.with_pat_already_bound().cat_pattern(
+                  cmt, &**subpat, op));
           }
 
           ast::PatIdent(_, _, None) => {

commit 515d3b41d5a979bff21e322f4ce05a95bf1fed30
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Fri Aug 8 12:49:09 2014 +0200

    root testsuite: test cases uncovered from bootstrapping `std::io:stdio`.
    
    These should both compile, preferably without any warnings.  Right now
    `foo40` emits a warning.  And worse, `foo39` causes a compile error.
---
 foo39.rs | 17 +++++++++++++++++
 foo40.rs | 17 +++++++++++++++++
 2 files changed, 34 insertions(+)

diff --git a/foo39.rs b/foo39.rs
new file mode 100644
index 0000000..a29ed9a
--- /dev/null
+++ b/foo39.rs
@@ -0,0 +1,17 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub enum Result<T,E> { Ok(T), Err(E) }
+
+pub fn foo<X,Y>(c: || -> Result<X,Y>) -> Result<X,Y> {
+    let s = c();
+    let ret = match s {
+        s @ Err(_) | s @ Ok(_) => s,
+    };
+    c();
+    ret
+}
diff --git a/foo40.rs b/foo40.rs
new file mode 100644
index 0000000..a29ed9a
--- /dev/null
+++ b/foo40.rs
@@ -0,0 +1,17 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub enum Result<T,E> { Ok(T), Err(E) }
+
+pub fn foo<X,Y>(c: || -> Result<X,Y>) -> Result<X,Y> {
+    let s = c();
+    let ret = match s {
+        s @ Err(_) | s @ Ok(_) => s,
+    };
+    c();
+    ret
+}

commit 9fad9281dbd01223f46ddbe14e24246d83b02715
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Fri Aug 8 12:24:49 2014 +0200

    rust-needsdrop: Revised MatchMode to include NonBindingMode explicitly.
---
 src/librustc/middle/borrowck/move_data.rs |  6 ++++--
 src/librustc/middle/expr_use_visitor.rs   | 99 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++------------------------------------
 2 files changed, 67 insertions(+), 38 deletions(-)

diff --git a/src/librustc/middle/borrowck/move_data.rs b/src/librustc/middle/borrowck/move_data.rs
index 948c908..a2ef1b1 100644
--- a/src/librustc/middle/borrowck/move_data.rs
+++ b/src/librustc/middle/borrowck/move_data.rs
@@ -832,8 +832,10 @@ impl MoveData {
 
         for variant_match in self.variant_matches.borrow().iter() {
             match variant_match.mode {
-                euv::BorrowingMatch => {}
-                euv::ConsumingMatch(_consume_mode) => {
+                euv::NonBindingMatch |
+                euv::BorrowingMatch |
+                euv::CopyingMatch => {}
+                euv::MovingMatch => {
                     debug!("remove_drop_obligations variant_match {}", variant_match.to_string(self, tcx));
                     self.remove_drop_obligations(tcx, variant_match, dfcx_needs_drop);
                     // FIXME: do I need to also remove_ignored_drops here? (FSK)
diff --git a/src/librustc/middle/expr_use_visitor.rs b/src/librustc/middle/expr_use_visitor.rs
index 596b269..71d8322 100644
--- a/src/librustc/middle/expr_use_visitor.rs
+++ b/src/librustc/middle/expr_use_visitor.rs
@@ -109,55 +109,80 @@ pub enum MoveReason {
 }
 
 #[deriving(PartialEq,Show)]
+pub enum MatchMode {
+    NonBindingMatch,
+    BorrowingMatch,
+    CopyingMatch,
+    MovingMatch,
+}
+
+#[deriving(PartialEq,Show)]
 enum TrackMatchMode {
     Unknown, Definite(MatchMode), Conflicting
 }
 
 impl TrackMatchMode {
+    // Builds up the whole match mode for a pattern from its constituent
+    // parts.  The lattice looks like this:
+    //
+    //             Conflicting
+    //              /      \
+    //             /       \
+    //       Borrowing    Moving
+    //            \        /
+    //            \       /
+    //             Copying
+    //                |
+    //            NonBinding
+    //                |
+    //             Unknown
+    //
+    // examples:
+    //
+    // * `(_, some_int)` pattern is Copying, since
+    //   NonBinding + Copying => Copying
+    //
+    // * `(some_int, some_box)` pattern is Moving, since
+    //   Copying + Moving => Moving
+    //
+    // * `(ref x, some_box)` pattern is Conflicting, since
+    //   Borrowing + Moving => Conflicting
+    //
+    // Note that the `Unknown` and `Conflicting` states are
+    // represented separately from the other more interesting
+    // `Definite` states, which simplifies logic here somewhat.
     fn meet(&mut self, mode: MatchMode) {
         *self = match (*self, mode) {
+            // Note that clause order below is very significant.
             (Unknown, new) => Definite(new),
             (Definite(old), new) if old == new => Definite(old),
-            (Definite(old), ConsumingMatch(Copy)) => Definite(old),
-            (Definite(ConsumingMatch(Copy)), new) => Definite(new),
+
+            (Definite(old), NonBindingMatch) => Definite(old),
+            (Definite(NonBindingMatch), new) => Definite(new),
+
+            (Definite(old), CopyingMatch) => Definite(old),
+            (Definite(CopyingMatch), new) => Definite(new),
+
             _ => Conflicting
         };
     }
 
     fn mode(self) -> MatchMode {
         match self {
-            // if we don't know, then there was no binding,
-            // and the match will just borrow.
-            Unknown => BorrowingMatch,
+            // if we don't know, then there was no binding.
+            Unknown => NonBindingMatch,
 
             Definite(mm) => mm,
 
             // if there were conflicting results, then we will hit a
-            // compiler error later.  But just to let the rustc make
-            // progress now, claim that it was a consuming match.
-            Conflicting => ConsumingMatch(Move(PatBindingMove)),
-        }
-    }
-
-    #[allow(dead_code)]
-    fn mode_within(self, outer_context: &TrackMatchMode) -> MatchMode {
-        match self {
-            // if we don't know, or if this is a copy, then inherit
-            // from the outer_context.
-            Unknown |
-            Definite(ConsumingMatch(Copy)) => outer_context.mode(),
-            _ => self.mode()
+            // compiler error later.  But to let rustc make progress
+            // now, claim it was a move (i.e. consumes the input).
+            Conflicting => MovingMatch,
         }
     }
 }
 
 #[deriving(PartialEq,Show)]
-pub enum MatchMode {
-    BorrowingMatch,
-    ConsumingMatch(ConsumeMode),
-}
-
-#[deriving(PartialEq,Show)]
 pub enum MutateMode {
     Init,
     JustWrite,    // x = y
@@ -899,8 +924,12 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {
                 match pat.node {
                     ast::PatIdent(ast::BindByRef(_), _, _) =>
                         mode.meet(BorrowingMatch),
-                    ast::PatIdent(ast::BindByValue(_), _, _) =>
-                        mode.meet(ConsumingMatch(copy_or_move(tcx, cmt_pat.ty, PatBindingMove))),
+                    ast::PatIdent(ast::BindByValue(_), _, _) => {
+                        match copy_or_move(tcx, cmt_pat.ty, PatBindingMove) {
+                            Copy => mode.meet(CopyingMatch),
+                            Move(_) => mode.meet(MovingMatch),
+                        }
+                    }
                     _ => {
                         // we will report the error here in the actual
                         // pass, after the prepass is completed.
@@ -917,9 +946,6 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {
         debug!("walk_pat cmt_discr={} pat={} outer_context_mode={}",
                cmt_discr.repr(self.tcx()), pat.repr(self.tcx()), outer_context_mode);
 
-        // let mut local_mode = Unknown;
-        // self.walk_pat_prepass(cmt_discr.clone(), pat, &mut local_mode);
-        // let match_mode = local_mode.mode_within(outer_context_mode);
         let match_mode = outer_context_mode.mode();
 
         let mc = &self.mc;
@@ -964,18 +990,19 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {
                     }
 
                     (&ast::PatIdent(ast::BindByValue(_), _, _), _) |
-                    (&ast::PatWild(_), ConsumingMatch(Move(_))) => {
+                    (&ast::PatWild(_), MovingMatch) => {
                         // FIXME: I may need to distinguish these two
-                        // cases, since the PatWild case will probably
-                        // imply auto-drop without warning at the end
-                        // of the scope (FSK).
+                        // cases, since the PatWild case may end up
+                        // implying auto-drop without warning at the
+                        // end of the scope (FSK).
                         let mode = copy_or_move(typer.tcx(), cmt_pat.ty, PatBindingMove);
                         debug!("walk_pat binding consuming pat");
                         delegate.consume_pat(pat, cmt_pat, mode);
                     }
 
-                    (&ast::PatWild(_), ConsumingMatch(Copy)) |
-                    (&ast::PatWild(_), BorrowingMatch) => {}
+                    (&ast::PatWild(_), NonBindingMatch) |
+                    (&ast::PatWild(_), BorrowingMatch) |
+                    (&ast::PatWild(_), CopyingMatch)  => {}
 
                     _ => {
                         typer.tcx().sess.span_bug(

commit 52b2d064a3c0d54af82111155f68ecd80a933369
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Fri Aug 8 11:40:24 2014 +0200

    root testsuite: some cases I encountered while bootstrapping.
    
    They may sort-of exist in the existing root test suite, but not
    exactly like these cases.
---
 foo38.rs |  39 +++++++++++++++++++++++++++++++++++++++
 iter3.rs | 141 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 180 insertions(+)

diff --git a/foo38.rs b/foo38.rs
new file mode 100644
index 0000000..2d59048
--- /dev/null
+++ b/foo38.rs
@@ -0,0 +1,39 @@
+#![feature(intrinsics)]
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="sized"] pub trait Sized { }
+
+#[lang = "owned_box"]
+pub struct Box<T>(*mut T);
+pub enum Option<T> { None, Some(T), }
+
+// Attempting to recreate warning for 
+//   src/libcollections/trie.rs:344:48: 350:26
+//     error: Storage at `(children[..]->trie::External)` is left ...
+// which seems to be falsely arising, since there should not be a
+// move occurring in this case, since the pattern is of the form
+// `External(stored, _)`, and stored is an int (i.e. :Copy), so the
+// whole thing should be pass by copy, with no drop obligation.
+
+pub struct TrieNode<'a,T> {
+    children: &'a [Child<'a,T>],
+}
+
+pub enum Child<'a,T> {
+    Internal(Box<TrieNode<'a,T>>),
+    External(uint, T),
+}
+
+pub fn foo<'a, T>(node_orig: *mut TrieNode<T>, idx: uint) {
+    let mut _node = node_orig;
+    let children = unsafe { &mut (*_node).children };
+    match children[idx] {
+        Internal(ref _x) => {}
+        External(_stored, _) => {}
+    }
+    no_op();
+}
+
+fn no_op() { }
diff --git a/iter3.rs b/iter3.rs
new file mode 100644
index 0000000..8468975
--- /dev/null
+++ b/iter3.rs
@@ -0,0 +1,141 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub fn drop<T>(_x: T) { }
+
+/// `MinMaxResult` is an enum returned by `min_max`. See `OrdIterator::min_max` for more detail.
+pub enum MinMaxResult<T> {
+    /// Empty iterator
+    NoElements,
+
+    /// Iterator with one element, so the minimum and maximum are the same
+    OneElement(T),
+
+    /// More than one element in the iterator, the first element is not larger than the second
+    MinMax(T, T)
+}
+
+pub trait OrdIterator<A> {
+    fn min_max(&mut self) -> MinMaxResult<A>;
+}
+
+pub fn foo<A: PartialOrd, T: Iterator<A>>(self_: &mut T) -> MinMaxResult<A> {
+    let (mut min, mut max) = match self_.next() {
+        None => return NoElements,
+        Some(x) => {
+            match self_.next() {
+                None => return OneElement(x),
+                Some(y) => if x < y {(x, y)} else {(y,x)}
+            }
+        }
+    };
+
+    loop {
+        // `first` and `second` are the two next elements we want to look at.
+        // We first compare `first` and `second` (#1). The smaller one is then compared to
+        // current minimum (#2). The larger one is compared to current maximum (#3). This
+        // way we do 3 comparisons for 2 elements.
+        let first = match self_.next() {
+            None => break,
+            Some(x) => x
+        };
+        let second = match self_.next() {
+            None => {
+                if first < min {
+                    min = first;
+                } else if first > max {
+                    max = first;
+                }
+                break;
+            }
+            Some(x) => x
+        };
+        if first < second {
+            if first < min {min = first;}
+            if max < second {max = second;}
+        } else {
+            if second < min {min = second;}
+            if max < first {max = first;}
+        }
+    }
+
+    MinMax(min, max)
+}
+
+#[lang="eq"]
+pub trait PartialEq {
+    /// This method tests for `self` and `other` values to be equal, and is used by `==`.
+    fn eq(&self, other: &Self) -> bool;
+
+    /// This method tests for `!=`.
+     fn ne(&self, other: &Self) -> bool { !self.eq(other) }
+}
+
+#[lang="ord"]
+pub trait PartialOrd: PartialEq {
+    /// This method returns an ordering between `self` and `other` values
+    /// if one exists.
+    fn partial_cmp(&self, other: &Self) -> Option<Ordering>;
+
+    /// This method tests less than (for `self` and `other`) and is used by the `<` operator.
+    fn lt(&self, other: &Self) -> bool {
+        match self.partial_cmp(other) {
+            Some(Less) => true,
+            _ => false,
+        }
+    }
+
+    /// This method tests less than or equal to (`<=`).
+    #[inline]
+    fn le(&self, other: &Self) -> bool {
+        match self.partial_cmp(other) {
+            Some(Less) | Some(Equal) => true,
+            _ => false,
+        }
+    }
+
+    /// This method tests greater than (`>`).
+    #[inline]
+    fn gt(&self, other: &Self) -> bool {
+        match self.partial_cmp(other) {
+            Some(Greater) => true,
+            _ => false,
+        }
+    }
+
+    /// This method tests greater than or equal to (`>=`).
+    #[inline]
+    fn ge(&self, other: &Self) -> bool {
+        match self.partial_cmp(other) {
+            Some(Greater) | Some(Equal) => true,
+            _ => false,
+        }
+    }
+}
+
+#[stable]
+pub enum Ordering {
+   /// An ordering where a compared value is less [than another].
+   Less = -1i,
+   /// An ordering where a compared value is equal [to another].
+   Equal = 0i,
+   /// An ordering where a compared value is greater [than another].
+   Greater = 1i,
+}
+
+pub enum Option<T> {
+    /// No value
+    None,
+    /// Some value `T`
+    Some(T)
+}
+
+#[lang="iterator"]
+pub trait Iterator<A> {
+    /// Advance the iterator and return the next value. Return `None` when the end is reached.
+    fn next(&mut self) -> Option<A>;
+}

commit 6fb7e41087984e5589d37f035844b3389c6119d1
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Fri Aug 8 10:04:49 2014 +0200

    rust-needsdrop: Revised early_drop warning message to try to clarify
    that the problem cannot necessarily be fixed at the point that is
    highlighted by the span.
---
 src/librustc/middle/borrowck/check_drops.rs | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/src/librustc/middle/borrowck/check_drops.rs b/src/librustc/middle/borrowck/check_drops.rs
index 49bad5c..d85ab6a 100644
--- a/src/librustc/middle/borrowck/check_drops.rs
+++ b/src/librustc/middle/borrowck/check_drops.rs
@@ -195,10 +195,10 @@ pub fn check_drops(bccx: &BorrowckCtxt,
                         ""
                     };
 
-                    let msg = format!("Storage at `{:s}` is left initialized here{:s}, \
-                                       but uninitialized on other control flow paths. \
-                                       (Consider either calling `drop()` on it here, \
-                                       or reinitializing it on the other paths); count: {}",
+                    let msg = format!("Storage at `{:s}` is left initialized on some paths \
+                                       exiting here{:s}, but uninitialized on others. \
+                                       (Consider either using Option, or calling `drop()` \
+                                       on it or reinitializing it as necessary); count: {}",
                                       loan_path_str, where, count);
 
                     bccx.tcx.sess.add_lint(lint::builtin::EARLY_DROP,

commit 585f6722c4008d5ae1ffe1a3129f94afb32e2b6f
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Fri Aug 8 09:42:36 2014 +0200

    rust-needsdrop: fix expr_use_visitor post reversion of ast::Arm NodeId change.
---
 src/librustc/middle/expr_use_visitor.rs | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/librustc/middle/expr_use_visitor.rs b/src/librustc/middle/expr_use_visitor.rs
index 6f14a01..596b269 100644
--- a/src/librustc/middle/expr_use_visitor.rs
+++ b/src/librustc/middle/expr_use_visitor.rs
@@ -424,8 +424,8 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {
                 let discr_cmt = return_if_err!(self.mc.cat_expr(&**discr));
                 for arm in arms.iter() {
                     let mut mode = Unknown;
-                    self.walk_arm_prepass(discr_cmt.clone(), &**arm, &mut mode);
-                    self.walk_arm(discr_cmt.clone(), &**arm, &mode);
+                    self.walk_arm_prepass(discr_cmt.clone(), arm, &mut mode);
+                    self.walk_arm(discr_cmt.clone(), arm, &mode);
                 }
             }
 

commit 10d581f7e1cad895b285b617a0149defa438c0ef
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Wed Aug 6 18:40:44 2014 +0200

    backed out the addition of NodeId to ast::Arm, since we do not need it anymore.
---
 src/libregex_macros/lib.rs                   |   1 -
 src/librustc/driver/driver.rs                |   4 ----
 src/librustc/lint/context.rs                 |   7 ++----
 src/librustc/middle/borrowck/check_drops.rs  |   2 +-
 src/librustc/middle/cfg/construct.rs         |  10 +++------
 src/librustc/middle/dataflow.rs              |   1 -
 src/librustc/middle/region.rs                | 129 +++++++++++++++++---------------------------------------------------------------------------------------------
 src/librustc/middle/trans/cleanup.rs         |  22 -------------------
 src/librustc/middle/trans/expr.rs            |   2 --
 src/librustc/middle/trans/monomorphize.rs    |   1 -
 src/librustc/middle/typeck/check/mod.rs      |   2 --
 src/librustc/middle/typeck/check/regionck.rs |   2 --
 src/librustc/util/ppaux.rs                   |   3 ---
 src/libsyntax/ast.rs                         |   3 +--
 src/libsyntax/ast_map/mod.rs                 |  16 --------------
 src/libsyntax/ast_util.rs                    |   5 -----
 src/libsyntax/ext/build.rs                   |   5 ++---
 src/libsyntax/ext/deriving/primitive.rs      |   2 --
 src/libsyntax/ext/expand.rs                  |   9 ++++----
 src/libsyntax/fold.rs                        |  36 +++----------------------------
 src/libsyntax/parse/parser.rs                |   3 +--
 src/libsyntax/print/pprust.rs                |  42 ------------------------------------
 src/libsyntax/visit.rs                       |   2 +-
 23 files changed, 38 insertions(+), 271 deletions(-)

diff --git a/src/libregex_macros/lib.rs b/src/libregex_macros/lib.rs
index 05bba09..8aa9a2f 100644
--- a/src/libregex_macros/lib.rs
+++ b/src/libregex_macros/lib.rs
@@ -590,7 +590,6 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,
     // Creates a wild-card match arm with the expression `body`.
     fn wild_arm_expr(&self, body: Gc<ast::Expr>) -> ast::Arm {
         ast::Arm {
-            id: ast::DUMMY_NODE_ID,
             attrs: vec!(),
             pats: vec!(box(GC) ast::Pat{
                 id: ast::DUMMY_NODE_ID,
diff --git a/src/librustc/driver/driver.rs b/src/librustc/driver/driver.rs
index 1983e9c..1eee45b 100644
--- a/src/librustc/driver/driver.rs
+++ b/src/librustc/driver/driver.rs
@@ -906,10 +906,6 @@ impl pprust::PpAnn for IdentifiedAnnotation {
                 try!(pp::space(&mut s.s));
                 s.synth_comment(format!("pat {}", pat.id))
             }
-            pprust::NodeArm(arm) => {
-                try!(pp::space(&mut s.s));
-                s.synth_comment(format!("arm {}", arm.id))
-            }
             pprust::NodeMethod(m) => {
                 try!(pp::space(&mut s.s));
                 s.synth_comment(format!("method {}", m.id))
diff --git a/src/librustc/lint/context.rs b/src/librustc/lint/context.rs
index 5e2b660..26ed5cb 100644
--- a/src/librustc/lint/context.rs
+++ b/src/librustc/lint/context.rs
@@ -607,11 +607,8 @@ impl<'a, 'tcx> Visitor<()> for Context<'a, 'tcx> {
     }
 
     fn visit_arm(&mut self, a: &ast::Arm, _: ()) {
-        self.with_lint_attrs(a.attrs.as_slice(), |cx| {
-            run_lints!(cx, check_arm, a);
-            cx.visit_ids(|v| v.visit_arm(a, ()));
-            visit::walk_arm(cx, a, ());
-        })
+        run_lints!(self, check_arm, a);
+        visit::walk_arm(self, a, ());
     }
 
     fn visit_decl(&mut self, d: &ast::Decl, _: ()) {
diff --git a/src/librustc/middle/borrowck/check_drops.rs b/src/librustc/middle/borrowck/check_drops.rs
index 4f7150f..49bad5c 100644
--- a/src/librustc/middle/borrowck/check_drops.rs
+++ b/src/librustc/middle/borrowck/check_drops.rs
@@ -289,7 +289,7 @@ fn scan_forward_for_kill_id(bccx: &BorrowckCtxt,
         }
 
         match bccx.tcx.map.get(successor_id) {
-            ast_map::NodeBlock(_) | ast_map::NodeArm(_) => {
+            ast_map::NodeBlock(_) => {
                 debug!("fwd-scan: node {} effect-free; continue looking",
                        successor_id);
                 continue;
diff --git a/src/librustc/middle/cfg/construct.rs b/src/librustc/middle/cfg/construct.rs
index 75c121f..789c563 100644
--- a/src/librustc/middle/cfg/construct.rs
+++ b/src/librustc/middle/cfg/construct.rs
@@ -370,15 +370,12 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {
                 //     |       |
                 //     |       |
                 //     v 5     |
-                //  [body1]    |
-                //     |       |
-                //     | 6     |
-                //   [arm1]    v
+                //  [body1]    V
                 //     |     [cond2]
                 //     |      /  \
                 //     |    ...  ...
                 //     |     |    |
-                //     v 7   v    v
+                //     v 6   v    v
                 //  [.....expr.....]
                 //
                 let discr_exit = self.expr(discr.clone(), pred);         // 1
@@ -393,8 +390,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {
                                                    pats_exit);           // 4
                     let body_exit = self.expr(arm.body.clone(),
                                               guard_exit);               // 5
-                    let arm_exit = self.add_node(arm.id, [body_exit]);   // 6
-                    self.add_contained_edge(arm_exit, expr_exit);        // 7
+                    self.add_contained_edge(body_exit, expr_exit);       // 6
                 }
                 expr_exit
             }
diff --git a/src/librustc/middle/dataflow.rs b/src/librustc/middle/dataflow.rs
index 1f7b33c..22da628 100644
--- a/src/librustc/middle/dataflow.rs
+++ b/src/librustc/middle/dataflow.rs
@@ -123,7 +123,6 @@ impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O
             pprust::NodeItem(_) => 0,
             pprust::NodePat(pat) => pat.id,
             pprust::NodeMethod(m) => m.id,
-            pprust::NodeArm(arm) => arm.id, // TODO: double-check Arm on dataflow+cfg
         };
 
         if self.has_bitset_for_nodeid(id) {
diff --git a/src/librustc/middle/region.rs b/src/librustc/middle/region.rs
index 2c62dab..1e13966 100644
--- a/src/librustc/middle/region.rs
+++ b/src/librustc/middle/region.rs
@@ -86,29 +86,10 @@ pub struct RegionMaps {
 
 #[deriving(Clone)]
 pub struct Context {
-    /// THIS NEEDS DOCUMENTATION
     var_parent: Option<ast::NodeId>,
 
-    // Innermost enclosing scope (e.g. expression, match arm)
-    lifetime_parent: Option<ast::NodeId>,
-}
-
-impl Context {
-    fn new(id: ast::NodeId) -> Context {
-        Context {
-            var_parent: Some(id),
-            lifetime_parent: Some(id),
-        }
-    }
-    fn fresh() -> Context {
-        Context {
-            var_parent: None,
-            lifetime_parent: None,
-        }
-    }
-    fn with_lifetime_parent(&self, id: ast::NodeId) -> Context {
-        Context { lifetime_parent: Some(id), ..*self }
-    }
+    // Innermost enclosing expression
+    parent: Option<ast::NodeId>,
 }
 
 struct RegionResolutionVisitor<'a> {
@@ -250,7 +231,6 @@ impl RegionMaps {
 
         let mut s = subscope;
         while superscope != s {
-            debug!("is_subscope_of({}, {}) cursor s={}", subscope, superscope, s);
             match self.scope_map.borrow().find(&s) {
                 None => {
                     debug!("is_subscope_of({}, {}, s={})=false",
@@ -371,7 +351,7 @@ impl RegionMaps {
 
         fn ancestors_of(this: &RegionMaps, scope: ast::NodeId)
             -> Vec<ast::NodeId> {
-            debug!("ancestors_of(scope={})", scope);
+            // debug!("ancestors_of(scope={})", scope);
             let mut result = vec!(scope);
             let mut scope = scope;
             loop {
@@ -393,8 +373,7 @@ fn record_superlifetime(visitor: &mut RegionResolutionVisitor,
                         cx: Context,
                         child_id: ast::NodeId,
                         _sp: Span) {
-    debug!("record_superlifetime(child_id={})", child_id);
-    for &parent_id in cx.lifetime_parent.iter() {
+    for &parent_id in cx.parent.iter() {
         visitor.region_maps.record_encl_scope(child_id, parent_id);
     }
 }
@@ -433,14 +412,13 @@ fn resolve_block(visitor: &mut RegionResolutionVisitor,
     //   }
     //
 
-    let subcx = Context::new(blk.id);
+    let subcx = Context {var_parent: Some(blk.id), parent: Some(blk.id)};
     visit::walk_block(visitor, blk, subcx);
 }
 
 fn resolve_arm(visitor: &mut RegionResolutionVisitor,
                arm: &ast::Arm,
                cx: Context) {
-    debug!("resolve_arm(arm.id={})", arm.id);
     visitor.region_maps.mark_as_terminating_scope(arm.body.id);
 
     match arm.guard {
@@ -451,82 +429,11 @@ fn resolve_arm(visitor: &mut RegionResolutionVisitor,
     }
 
     visit::walk_arm(visitor, arm, cx);
-
-    // Regarding the commented out code below: it is difficult to
-    // figure out what to do for arm = {pat, guard, body}.
-    // In particular, it seems that currently, the scopes are
-    // set up to indcate that the parent of all three components
-    // is the whole match expression, which implies that the
-    // drops of pattern bindings occur at the end of the whole match,
-    // rather than at the end of an individual arm.
-    //
-    // In terms of the actual control flow, there is no distinction
-    // between the whole match and an individual arm.  But in terms of
-    // the control-flow graph representation, these seems to be
-    // very different things.
-    //
-    // pnkfelix's initial take on how to fix this was to explicitly
-    // represent the "scope of the arm" separately, and treat that as
-    // the parent for the pat and the expression.  But what about the
-    // guard?  That is where thing's got tricky, in part because the
-    // arm is not really a scope, and so it was not easy to figure out
-    // how to hack that in.  (Perhaps future changes to the language
-    // will make this make more sense, eg.. the proposal to make
-    // guards take bindings by-ref even if they are going to move for
-    // the body if the guard succeeds.  Or perhaps another approach
-    // would be to more fully distinguish between by-ref and by-move
-    // match arms, since the latter cannot have guards and the former
-    // ... do not need cleanup?  Is that right?  Not sure.)
-    //
-    // Anyway, pnkfelix is now revisiting his approach.  I.e. perhaps
-    // the answer is not to try to introduce some new notion of a
-    // match arm's "scope", but rather, "just" revise the move_data
-    // code for check_drops to treat the merge point for match as a
-    // special case.  Not yet sure.
-
-/*
-    // Deliberately not invoking `visit::walk_arm(visitor, arm, cx)`.
-    // Instead, walk each component in turn below, using `cx`
-    // (carrying the parent scope) for the pattern and optional guard,
-    // and a different context for the arm's expression body, thus
-    // encoding the distinct lifetime that is established for the
-    // expression body.
-
-    let &Arm { ref attrs, ref pats, guard, body, id: arm_id } = arm;
-
-    // (Slightly misleading hack: using body of an arm as its span.)
-    record_superlifetime(visitor, cx, arm_id, body.span);
-
-    // Bindings introduced by the pattern should be treated as having
-    // lifetime bounded by the arm itself.
-    let pat_subcx = cx.with_var_parent(arm_id);
-    for pattern in pats.iter() {
-        visitor.visit_pat(&**pattern, pat_subcx);
-    }
-
-    // For the guard, treat its lifetime parent as the arm itself.
-    //
-    // FIXME: would be nice to use `arm_id` here as well, for
-    // uniformity, but making that work requires trans hacking (FSK).
-    let arm_cx = Context::new(arm_id);
-    visit::walk_expr_opt(visitor, guard, arm_cx);
-
-    // The parent of the body expression is the arm itself (so that
-    // expressions within the arm will properly report that their
-    // lifetimes are contained within arm's superlifetime).
-    let body_cx = Context::new(arm_id);
-    visitor.visit_expr(&*body, body_cx);
-
-    for attr in attrs.iter() {
-        visitor.visit_attribute(attr, cx);
-    }
-*/
 }
 
 fn resolve_pat(visitor: &mut RegionResolutionVisitor,
                pat: &ast::Pat,
                cx: Context) {
-    debug!("resolve_pat(pat.id={})", pat.id);
     record_superlifetime(visitor, cx, pat.id, pat.span);
 
     // If this is a binding (or maybe a binding, I'm too lazy to check
@@ -550,7 +457,7 @@ fn resolve_stmt(visitor: &mut RegionResolutionVisitor,
     visitor.region_maps.mark_as_terminating_scope(stmt_id);
     record_superlifetime(visitor, cx, stmt_id, stmt.span);
 
-    let subcx = cx.with_lifetime_parent(stmt_id);
+    let subcx = Context {parent: Some(stmt_id), ..cx};
     visit::walk_stmt(visitor, stmt, subcx);
 }
 
@@ -561,7 +468,8 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor,
 
     record_superlifetime(visitor, cx, expr.id, expr.span);
 
-    let mut new_cx = cx.with_lifetime_parent(expr.id);
+    let mut new_cx = cx;
+    new_cx.parent = Some(expr.id);
     match expr.node {
         // Conditional or repeating scopes are always terminating
         // scopes, meaning that temporaries cannot outlive them.
@@ -602,7 +510,6 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor,
         }
 
         ast::ExprMatch(..) => {
-            // Might not be needed when Arm has its own scoped NodeId.
             new_cx.var_parent = Some(expr.id);
         }
 
@@ -887,9 +794,9 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor,
 
 fn resolve_item(visitor: &mut RegionResolutionVisitor,
                 item: &ast::Item,
-                _cx: Context) {
+                cx: Context) {
     // Items create a new outer block scope as far as we're concerned.
-    let new_cx = Context::fresh();
+    let new_cx = Context {var_parent: None, parent: None, ..cx};
     visit::walk_item(visitor, item, new_cx);
 }
 
@@ -903,22 +810,25 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,
     debug!("region::resolve_fn(id={}, \
                                span={:?}, \
                                body.id={}, \
-                               cx.lifetime_parent={})",
+                               cx.parent={})",
            id,
            visitor.sess.codemap().span_to_string(sp),
            body.id,
-           cx.lifetime_parent);
+           cx.parent);
 
     visitor.region_maps.mark_as_terminating_scope(body.id);
 
     // The arguments and `self` are parented to the body of the fn.
-    let decl_cx = Context::new(body.id);
+    let decl_cx = Context {parent: Some(body.id),
+                           var_parent: Some(body.id)};
     visit::walk_fn_decl(visitor, decl, decl_cx);
 
     // The body of the fn itself is either a root scope (top-level fn)
     // or it continues with the inherited scope (closures).
     let body_cx = match *fk {
-        visit::FkItemFn(..) | visit::FkMethod(..) => Context::fresh(),
+        visit::FkItemFn(..) | visit::FkMethod(..) => {
+            Context {parent: None, var_parent: None, ..cx}
+        }
         visit::FkFnBlock(..) => {
             // FIXME(#3696) -- at present we are place the closure body
             // within the region hierarchy exactly where it appears lexically.
@@ -977,7 +887,7 @@ pub fn resolve_crate(sess: &Session, krate: &ast::Crate) -> RegionMaps {
             sess: sess,
             region_maps: &maps
         };
-        let cx = Context::fresh();
+        let cx = Context { parent: None, var_parent: None };
         visit::walk_crate(&mut visitor, krate, cx);
     }
     return maps;
@@ -986,7 +896,8 @@ pub fn resolve_crate(sess: &Session, krate: &ast::Crate) -> RegionMaps {
 pub fn resolve_inlined_item(sess: &Session,
                             region_maps: &RegionMaps,
                             item: &ast::InlinedItem) {
-    let cx = Context::fresh();
+    let cx = Context {parent: None,
+                      var_parent: None};
     let mut visitor = RegionResolutionVisitor {
         sess: sess,
         region_maps: region_maps,
diff --git a/src/librustc/middle/trans/cleanup.rs b/src/librustc/middle/trans/cleanup.rs
index 6370c42..4d54308 100644
--- a/src/librustc/middle/trans/cleanup.rs
+++ b/src/librustc/middle/trans/cleanup.rs
@@ -144,27 +144,6 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {
 
     }
 
-    fn pop_and_trans_match_arm_cleanup_scope(&self,
-                                             bcx: &'a Block<'a>,
-                                             cleanup_scope: ast::NodeId)
-                                             -> &'a Block<'a> {
-        /*!
-         * Removes the cleanup scope for match arm with id
-         * `cleanup_scope`, which must be at the top of the cleanup
-         * stack, and generates the code to do its cleanups for normal
-         * exit.
-         */
-
-        debug!("pop_and_trans_match_arm_cleanup_scope({})",
-               self.ccx.tcx.map.node_to_string(cleanup_scope));
-
-        assert!(self.top_scope(|s| s.kind.is_ast_with_id(cleanup_scope)));
-
-        let scope = self.pop_scope();
-        self.trans_scope_cleanups(bcx, &scope)
-
-    }
-
     fn pop_loop_cleanup_scope(&self,
                               cleanup_scope: ast::NodeId) {
         /*!
@@ -1053,7 +1032,6 @@ pub trait CleanupMethods<'blk, 'tcx> {
                                    id: ast::NodeId,
                                    exits: [Block<'blk, 'tcx>, ..EXIT_MAX]);
     fn push_custom_cleanup_scope(&self) -> CustomScopeIndex;
-    fn push_match_arm_cleanup_scope(&self, id: ast::NodeId);
     fn pop_and_trans_ast_cleanup_scope(&self,
                                               bcx: Block<'blk, 'tcx>,
                                               cleanup_scope: ast::NodeId)
diff --git a/src/librustc/middle/trans/expr.rs b/src/librustc/middle/trans/expr.rs
index 9ca3935..4d74ba3 100644
--- a/src/librustc/middle/trans/expr.rs
+++ b/src/librustc/middle/trans/expr.rs
@@ -980,8 +980,6 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,
             controlflow::trans_if(bcx, expr.id, &**cond, thn.clone(), els, dest)
         }
         ast::ExprMatch(ref discr, ref arms) => {
-            let arms : Vec<ast::Arm> =
-                arms.as_slice().iter().map(|x|(**x).clone()).collect();
             _match::trans_match(bcx, expr, &**discr, arms.as_slice(), dest)
         }
         ast::ExprBlock(ref blk) => {
diff --git a/src/librustc/middle/trans/monomorphize.rs b/src/librustc/middle/trans/monomorphize.rs
index 12c98e4..1cf3e55 100644
--- a/src/librustc/middle/trans/monomorphize.rs
+++ b/src/librustc/middle/trans/monomorphize.rs
@@ -270,7 +270,6 @@ pub fn monomorphic_fn(ccx: &CrateContext,
         ast_map::NodeForeignItem(..) |
         ast_map::NodeLifetime(..) |
         ast_map::NodeExpr(..) |
-        ast_map::NodeArm(..) |
         ast_map::NodeStmt(..) |
         ast_map::NodeArg(..) |
         ast_map::NodeBlock(..) |
diff --git a/src/librustc/middle/typeck/check/mod.rs b/src/librustc/middle/typeck/check/mod.rs
index 58a972a..9cd227d 100644
--- a/src/librustc/middle/typeck/check/mod.rs
+++ b/src/librustc/middle/typeck/check/mod.rs
@@ -3801,8 +3801,6 @@ fn check_expr_with_unifier(fcx: &FnCtxt,
         }
       }
       ast::ExprMatch(ref discrim, ref arms) => {
-        let arms : Vec<ast::Arm> =
-            arms.as_slice().iter().map(|x|(**x).clone()).collect();
         _match::check_match(fcx, expr, &**discrim, arms.as_slice());
       }
       ast::ExprFnBlock(_, ref decl, ref body) => {
diff --git a/src/librustc/middle/typeck/check/regionck.rs b/src/librustc/middle/typeck/check/regionck.rs
index 0adaa43..ca5f113 100644
--- a/src/librustc/middle/typeck/check/regionck.rs
+++ b/src/librustc/middle/typeck/check/regionck.rs
@@ -732,8 +732,6 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {
         }
 
         ast::ExprMatch(ref discr, ref arms) => {
-            let arms : Vec<ast::Arm>
-                = arms.as_slice().iter().map(|x|(**x).clone()).collect();
             link_match(rcx, &**discr, arms.as_slice());
 
             visit::walk_expr(rcx, expr, ());
diff --git a/src/librustc/util/ppaux.rs b/src/librustc/util/ppaux.rs
index 3f8ec41..638ca5d 100644
--- a/src/librustc/util/ppaux.rs
+++ b/src/librustc/util/ppaux.rs
@@ -105,9 +105,6 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)
               let tag = item_scope_tag(&*it);
               explain_span(cx, tag, it.span)
           }
-          Some(ast_map::NodeArm(arm)) => {
-              explain_span(cx, "match arm", arm.body.span)
-          }
           Some(_) | None => {
             // this really should not happen
             fail!("unknown scope: {}.  Please report a bug.", node_id)
diff --git a/src/libsyntax/ast.rs b/src/libsyntax/ast.rs
index 369a909..68a1c52 100644
--- a/src/libsyntax/ast.rs
+++ b/src/libsyntax/ast.rs
@@ -477,7 +477,6 @@ pub enum Decl_ {
 /// represents one arm of a 'match'
 #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]
 pub struct Arm {
-    pub id: NodeId,
     pub attrs: Vec<Attribute>,
     pub pats: Vec<Gc<Pat>>,
     pub guard: Option<Gc<Expr>>,
@@ -532,7 +531,7 @@ pub enum Expr_ {
     // Conditionless loop (can be exited with break, cont, or ret)
     // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.
     ExprLoop(P<Block>, Option<Ident>),
-    ExprMatch(Gc<Expr>, Vec<Gc<Arm>>),
+    ExprMatch(Gc<Expr>, Vec<Arm>),
     ExprFnBlock(CaptureClause, P<FnDecl>, P<Block>),
     ExprProc(P<FnDecl>, P<Block>),
     ExprUnboxedFn(CaptureClause, UnboxedClosureKind, P<FnDecl>, P<Block>),
diff --git a/src/libsyntax/ast_map/mod.rs b/src/libsyntax/ast_map/mod.rs
index 5a04014..06b7583 100644
--- a/src/libsyntax/ast_map/mod.rs
+++ b/src/libsyntax/ast_map/mod.rs
@@ -108,7 +108,6 @@ pub enum Node {
     NodeLocal(Gc<Pat>),
     NodePat(Gc<Pat>),
     NodeBlock(P<Block>),
-    NodeArm(Gc<Arm>),
 
     /// NodeStructCtor represents a tuple struct.
     NodeStructCtor(Gc<StructDef>),
@@ -135,7 +134,6 @@ enum MapEntry {
     EntryLocal(NodeId, Gc<Pat>),
     EntryPat(NodeId, Gc<Pat>),
     EntryBlock(NodeId, P<Block>),
-    EntryArm(NodeId, Gc<Arm>),
     EntryStructCtor(NodeId, Gc<StructDef>),
     EntryLifetime(NodeId, Gc<Lifetime>),
 
@@ -163,7 +161,6 @@ impl MapEntry {
             EntryArg(id, _) => id,
             EntryLocal(id, _) => id,
             EntryPat(id, _) => id,
-            EntryArm(id, _) => id,
             EntryBlock(id, _) => id,
             EntryStructCtor(id, _) => id,
             EntryLifetime(id, _) => id,
@@ -184,7 +181,6 @@ impl MapEntry {
             EntryLocal(_, p) => NodeLocal(p),
             EntryPat(_, p) => NodePat(p),
             EntryBlock(_, p) => NodeBlock(p),
-            EntryArm(_, p) => NodeArm(p),
             EntryStructCtor(_, p) => NodeStructCtor(p),
             EntryLifetime(_, p) => NodeLifetime(p),
             NotPresent | RootCrate | RootInlinedParent(_) => return None,
@@ -465,7 +461,6 @@ impl Map {
             Some(NodeStmt(stmt)) => stmt.span,
             Some(NodeArg(pat)) | Some(NodeLocal(pat)) => pat.span,
             Some(NodePat(pat)) => pat.span,
-            Some(NodeArm(arm)) => arm.body.span,
             Some(NodeBlock(block)) => block.span,
             Some(NodeStructCtor(_)) => self.expect_item(self.get_parent(id)).span,
             _ => return None,
@@ -728,14 +723,6 @@ impl<'a, F: FoldOps> Folder for Ctx<'a, F> {
         expr
     }
 
-    fn fold_arm(&mut self, arm: Gc<Arm>) -> Gc<Arm> {
-        let arm = fold::noop_fold_arm(arm, self);
-
-        self.insert(arm.id, EntryArm(self.parent, arm));
-
-        arm
-    }
-
     fn fold_stmt(&mut self, stmt: &Stmt) -> SmallVector<Gc<Stmt>> {
         let stmt = fold::noop_fold_stmt(stmt, self).expect_one("expected one statement");
         self.insert(ast_util::stmt_id(&*stmt), EntryStmt(self.parent, stmt));
@@ -961,9 +948,6 @@ fn node_id_to_string(map: &Map, id: NodeId) -> String {
         Some(NodePat(ref pat)) => {
             format!("pat {} (id={})", pprust::pat_to_string(&**pat), id)
         }
-        Some(NodeArm(ref arm)) => {
-            format!("arm {} (id={})", pprust::arm_to_string(&**arm), id)
-        }
         Some(NodeBlock(ref block)) => {
             format!("block {} (id={})", pprust::block_to_string(&**block), id)
         }
diff --git a/src/libsyntax/ast_util.rs b/src/libsyntax/ast_util.rs
index 396f4ba..8ef13ef 100644
--- a/src/libsyntax/ast_util.rs
+++ b/src/libsyntax/ast_util.rs
@@ -451,11 +451,6 @@ impl<'a, O: IdVisitingOperation> Visitor<()> for IdVisitor<'a, O> {
         visit::walk_stmt(self, statement, env)
     }
 
-    fn visit_arm(&mut self, a: &Arm, env: ()) {
-        self.operation.visit_id(a.id);
-        visit::walk_arm(self, a, env)
-    }
-
     fn visit_pat(&mut self, pattern: &Pat, env: ()) {
         self.operation.visit_id(pattern.id);
         visit::walk_pat(self, pattern, env)
diff --git a/src/libsyntax/ext/build.rs b/src/libsyntax/ext/build.rs
index 0d679bb..64ab0e5 100644
--- a/src/libsyntax/ext/build.rs
+++ b/src/libsyntax/ext/build.rs
@@ -852,8 +852,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {
             attrs: vec!(),
             pats: pats,
             guard: None,
-            body: expr,
-            id: ast::DUMMY_NODE_ID,
+            body: expr
         }
     }
 
@@ -863,7 +862,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {
 
     fn expr_match(&self, span: Span, arg: Gc<ast::Expr>,
                   arms: Vec<ast::Arm>) -> Gc<Expr> {
-        self.expr(span, ast::ExprMatch(arg, arms.move_iter().map(|x| box(GC)x).collect()))
+        self.expr(span, ast::ExprMatch(arg, arms))
     }
 
     fn expr_if(&self, span: Span,
diff --git a/src/libsyntax/ext/deriving/primitive.rs b/src/libsyntax/ext/deriving/primitive.rs
index 20c5bdd..30dd8e9 100644
--- a/src/libsyntax/ext/deriving/primitive.rs
+++ b/src/libsyntax/ext/deriving/primitive.rs
@@ -118,7 +118,6 @@ fn cs_from(name: &str, cx: &mut ExtCtxt, trait_span: Span,
                             pats: vec!(cx.pat_wild(span)),
                             guard: Some(guard),
                             body: body,
-                            id: ast::DUMMY_NODE_ID,
                         };
 
                         arms.push(arm);
@@ -139,7 +138,6 @@ fn cs_from(name: &str, cx: &mut ExtCtxt, trait_span: Span,
                 pats: vec!(cx.pat_wild(trait_span)),
                 guard: None,
                 body: cx.expr_none(trait_span),
-                id: ast::DUMMY_NODE_ID,
             };
             arms.push(arm);
 
diff --git a/src/libsyntax/ext/expand.rs b/src/libsyntax/ext/expand.rs
index e52f31b..d0f3cf6 100644
--- a/src/libsyntax/ext/expand.rs
+++ b/src/libsyntax/ext/expand.rs
@@ -614,7 +614,7 @@ fn expand_non_macro_stmt(s: &Stmt, fld: &mut MacroExpander)
 }
 
 // expand the arm of a 'match', renaming for macro hygiene
-fn expand_arm(arm: &ast::Arm, fld: &mut MacroExpander) -> Gc<ast::Arm> {
+fn expand_arm(arm: &ast::Arm, fld: &mut MacroExpander) -> ast::Arm {
     // expand pats... they might contain macro uses:
     let expanded_pats : Vec<Gc<ast::Pat>> = arm.pats.iter().map(|pat| fld.fold_pat(*pat)).collect();
     if expanded_pats.len() == 0 {
@@ -635,12 +635,11 @@ fn expand_arm(arm: &ast::Arm, fld: &mut MacroExpander) -> Gc<ast::Arm> {
     let rewritten_guard =
         arm.guard.map(|g| fld.fold_expr(rename_fld.fold_expr(g)));
     let rewritten_body = fld.fold_expr(rename_fld.fold_expr(arm.body));
-    box(GC) ast::Arm {
+    ast::Arm {
         attrs: arm.attrs.iter().map(|x| fld.fold_attribute(*x)).collect(),
         pats: rewritten_pats,
         guard: rewritten_guard,
         body: rewritten_body,
-        id: arm.id,
     }
 }
 
@@ -950,8 +949,8 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {
         expand_block(&*block, self)
     }
 
-    fn fold_arm(&mut self, arm: Gc<ast::Arm>) -> Gc<ast::Arm> {
-        expand_arm(&*arm, self)
+    fn fold_arm(&mut self, arm: &ast::Arm) -> ast::Arm {
+        expand_arm(arm, self)
     }
 
     fn fold_method(&mut self, method: Gc<ast::Method>) -> SmallVector<Gc<ast::Method>> {
diff --git a/src/libsyntax/fold.rs b/src/libsyntax/fold.rs
index 86d5c29..7deabed 100644
--- a/src/libsyntax/fold.rs
+++ b/src/libsyntax/fold.rs
@@ -319,9 +319,7 @@ pub fn noop_fold_view_path<T: Folder>(view_path: Gc<ViewPath>, fld: &mut T) -> G
 }
 
 pub fn noop_fold_arm<T: Folder>(a: &Arm, fld: &mut T) -> Arm {
-    let id = fld.new_id(a.id);
     Arm {
-        id: id,
         attrs: a.attrs.iter().map(|x| fld.fold_attribute(*x)).collect(),
         pats: a.pats.iter().map(|x| fld.fold_pat(*x)).collect(),
         guard: a.guard.map(|x| fld.fold_expr(x)),
@@ -555,7 +553,6 @@ pub fn noop_fold_meta_item<T: Folder>(mi: &MetaItem, fld: &mut T) -> MetaItem {
 
 pub fn noop_fold_arg<T: Folder>(a: &Arg, fld: &mut T) -> Arg {
     let id = fld.new_id(a.id); // Needs to be first, for ast_map.
-    debug!("fold_arg_, id: {}", id);
     Arg {
         id: id,
         ty: fld.fold_ty(a.ty),
@@ -668,7 +665,6 @@ pub fn noop_fold_ty_param_bound<T: Folder>(tpb: &TyParamBound, fld: &mut T)
 
 pub fn noop_fold_ty_param<T: Folder>(tp: &TyParam, fld: &mut T) -> TyParam {
     let id = fld.new_id(tp.id);
-    debug!("fold_ty_param, id: {}", id);
     TyParam {
         ident: tp.ident,
         id: id,
@@ -686,7 +682,6 @@ pub fn noop_fold_ty_params<T: Folder>(tps: &[TyParam], fld: &mut T)
 
 pub fn noop_fold_lifetime<T: Folder>(l: &Lifetime, fld: &mut T) -> Lifetime {
     let id = fld.new_id(l.id);
-    debug!("noop_fold_lifetime, id: {}", id);
     Lifetime {
         id: id,
         span: fld.new_span(l.span),
@@ -765,7 +760,6 @@ pub fn noop_fold_struct_def<T: Folder>(struct_def: Gc<StructDef>,
 
 pub fn noop_fold_trait_ref<T: Folder>(p: &TraitRef, fld: &mut T) -> TraitRef {
     let id = fld.new_id(p.ref_id);
-    debug!("fold_trait_ref, id: {}", id);
     ast::TraitRef {
         path: fld.fold_path(&p.path),
         ref_id: id,
@@ -774,7 +768,6 @@ pub fn noop_fold_trait_ref<T: Folder>(p: &TraitRef, fld: &mut T) -> TraitRef {
 
 pub fn noop_fold_struct_field<T: Folder>(f: &StructField, fld: &mut T) -> StructField {
     let id = fld.new_id(f.node.id);
-    debug!("fold_struct_field, id: {}", id);
     Spanned {
         node: ast::StructField_ {
             kind: f.node.kind,
@@ -813,7 +806,6 @@ fn noop_fold_bounds<T: Folder>(bounds: &TyParamBounds, folder: &mut T)
 
 pub fn noop_fold_variant_arg<T: Folder>(va: &VariantArg, folder: &mut T) -> VariantArg {
     let id = folder.new_id(va.id);
-    debug!("fold_variant_arg_, id: {}", id);
     ast::VariantArg {
         ty: folder.fold_ty(va.ty),
         id: id,
@@ -842,7 +834,6 @@ pub fn noop_fold_view_item<T: Folder>(vi: &ViewItem, folder: &mut T)
 
 pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {
     let id = folder.new_id(b.id); // Needs to be first, for ast_map.
-    debug!("noop_fold_block, id: {}", id);
     let view_items = b.view_items.iter().map(|x| folder.fold_view_item(x)).collect();
     let stmts = b.stmts.iter().flat_map(|s| folder.fold_stmt(&**s).move_iter()).collect();
     P(Block {
@@ -935,7 +926,6 @@ pub fn noop_fold_item_underscore<T: Folder>(i: &Item_, folder: &mut T) -> Item_
 
 pub fn noop_fold_type_method<T: Folder>(m: &TypeMethod, fld: &mut T) -> TypeMethod {
     let id = fld.new_id(m.id); // Needs to be first, for ast_map.
-    debug!("noop_fold_type_method, id: {}", id);
     TypeMethod {
         id: id,
         ident: fld.fold_ident(m.ident),
@@ -980,7 +970,6 @@ pub fn noop_fold_item<T: Folder>(i: &Item,
 // fold one item into exactly one item
 pub fn noop_fold_item_simple<T: Folder>(i: &Item, folder: &mut T) -> Item {
     let id = folder.new_id(i.id); // Needs to be first, for ast_map.
-    debug!("noop_fold_item_, id: {}", id);
     let node = folder.fold_item_underscore(&i.node);
     let ident = match node {
         // The node may have changed, recompute the "pretty" impl name.
@@ -1003,7 +992,6 @@ pub fn noop_fold_item_simple<T: Folder>(i: &Item, folder: &mut T) -> Item {
 pub fn noop_fold_foreign_item<T: Folder>(ni: &ForeignItem,
                                          folder: &mut T) -> Gc<ForeignItem> {
     let id = folder.new_id(ni.id); // Needs to be first, for ast_map.
-    debug!("noop_fold_foreign_item, id: {}", id);
     box(GC) ForeignItem {
         id: id,
         ident: folder.fold_ident(ni.ident),
@@ -1030,7 +1018,6 @@ pub fn noop_fold_foreign_item<T: Folder>(ni: &ForeignItem,
 // Invariant: produces exactly one method.
 pub fn noop_fold_method<T: Folder>(m: &Method, folder: &mut T) -> SmallVector<Gc<Method>> {
     let id = folder.new_id(m.id); // Needs to be first, for ast_map.
-    debug!("noop_fold_method, id: {}", id);
     SmallVector::one(box(GC) Method {
         attrs: m.attrs.iter().map(|a| folder.fold_attribute(*a)).collect(),
         id: id,
@@ -1059,8 +1046,7 @@ pub fn noop_fold_method<T: Folder>(m: &Method, folder: &mut T) -> SmallVector<Gc
 }
 
 pub fn noop_fold_pat<T: Folder>(p: Gc<Pat>, folder: &mut T) -> Gc<Pat> {
-    let id = folder.new_id(p.id); // Needs to be first, for ast_map.
-    debug!("noop_fold_pat, id: {}", id);
+    let id = folder.new_id(p.id);
     let node = match p.node {
         PatWild(k) => PatWild(k),
         PatIdent(binding_mode, ref pth1, ref sub) => {
@@ -1106,8 +1092,7 @@ pub fn noop_fold_pat<T: Folder>(p: Gc<Pat>, folder: &mut T) -> Gc<Pat> {
 }
 
 pub fn noop_fold_expr<T: Folder>(e: Gc<Expr>, folder: &mut T) -> Gc<Expr> {
-    let id = folder.new_id(e.id); // Needs to be first, for ast_map.
-    debug!("noop_fold_expr, id: {}", id);
+    let id = folder.new_id(e.id);
     let node = match e.node {
         ExprBox(p, e) => {
             ExprBox(folder.fold_expr(p), folder.fold_expr(e))
@@ -1164,7 +1149,7 @@ pub fn noop_fold_expr<T: Folder>(e: Gc<Expr>, folder: &mut T) -> Gc<Expr> {
         }
         ExprMatch(expr, ref arms) => {
             ExprMatch(folder.fold_expr(expr),
-                      arms.iter().map(|&x| folder.fold_arm(x)).collect())
+                      arms.iter().map(|x| folder.fold_arm(x)).collect())
         }
         ExprFnBlock(capture_clause, ref decl, ref body) => {
             ExprFnBlock(capture_clause,
@@ -1236,19 +1221,16 @@ pub fn noop_fold_stmt<T: Folder>(s: &Stmt,
     let nodes = match s.node {
         StmtDecl(d, id) => {
             let id = folder.new_id(id);
-            debug!("noop_fold_stmt, id: {} StmtDecl", id);
             folder.fold_decl(d).move_iter()
                     .map(|d| StmtDecl(d, id))
                     .collect()
         }
         StmtExpr(e, id) => {
             let id = folder.new_id(id);
-            debug!("noop_fold_stmt, id: {} StmtExpr", id);
             SmallVector::one(StmtExpr(folder.fold_expr(e), id))
         }
         StmtSemi(e, id) => {
             let id = folder.new_id(id);
-            debug!("noop_fold_stmt, id: {} StmtSemi", id);
             SmallVector::one(StmtSemi(folder.fold_expr(e), id))
         }
         StmtMac(ref mac, semi) => SmallVector::one(StmtMac(folder.fold_mac(mac), semi))
@@ -1260,18 +1242,6 @@ pub fn noop_fold_stmt<T: Folder>(s: &Stmt,
     }).collect()
 }
 
-pub fn noop_fold_arm<T: Folder>(a: Gc<Arm>, folder: &mut T) -> Gc<Arm> {
-    let id = folder.new_id(a.id);
-    debug!("noop_fold_arm, id: {}", id);
-    box(GC) Arm {
-        attrs: a.attrs.iter().map(|x| folder.fold_attribute(*x)).collect(),
-        pats: a.pats.iter().map(|x| folder.fold_pat(*x)).collect(),
-        guard: a.guard.map(|x| folder.fold_expr(x)),
-        body: folder.fold_expr(a.body),
-        id: id,
-    }
-}
-
 #[cfg(test)]
 mod test {
     use std::io;
diff --git a/src/libsyntax/parse/parser.rs b/src/libsyntax/parse/parser.rs
index cba5ff2..936cabc 100644
--- a/src/libsyntax/parse/parser.rs
+++ b/src/libsyntax/parse/parser.rs
@@ -2777,7 +2777,7 @@ impl<'a> Parser<'a> {
         let lo = self.last_span.lo;
         let discriminant = self.parse_expr_res(RESTRICT_NO_STRUCT_LITERAL);
         self.commit_expr_expecting(discriminant, token::LBRACE);
-        let mut arms: Vec<Gc<Arm>> = Vec::new();
+        let mut arms: Vec<Arm> = Vec::new();
         while self.token != token::RBRACE {
             arms.push(self.parse_arm());
         }
@@ -2811,7 +2811,6 @@ impl<'a> Parser<'a> {
             pats: pats,
             guard: guard,
             body: expr,
-            id: ast::DUMMY_NODE_ID,
         }
     }
 
diff --git a/src/libsyntax/print/pprust.rs b/src/libsyntax/print/pprust.rs
index 37912d9..4458958 100644
--- a/src/libsyntax/print/pprust.rs
+++ b/src/libsyntax/print/pprust.rs
@@ -39,7 +39,6 @@ pub enum AnnNode<'a> {
     NodeItem(&'a ast::Item),
     NodeExpr(&'a ast::Expr),
     NodePat(&'a ast::Pat),
-    NodeArm(&'a ast::Arm),
     NodeMethod(&'a ast::Method),
 }
 
@@ -199,10 +198,6 @@ pub fn arm_to_string(arm: &ast::Arm) -> String {
     $to_string(|s| s.print_arm(arm))
 }
 
-pub fn arm_to_string(arm: &ast::Arm) -> String {
-    to_string(|s| s.print_arm(arm))
-}
-
 pub fn expr_to_string(e: &ast::Expr) -> String {
     $to_string(|s| s.print_expr(e))
 }
@@ -1825,43 +1820,6 @@ impl<'a> State<'a> {
         self.print_path_(path, false, bounds)
     }
 
-    pub fn print_arm(&mut self, arm: &ast::Arm) -> IoResult<()> {
-        try!(self.cbox(indent_unit));
-        try!(self.ibox(0u));
-        try!(self.print_outer_attributes(arm.attrs.as_slice()));
-        let mut first = true;
-        for p in arm.pats.iter() {
-            if first {
-                first = false;
-            } else {
-                try!(space(&mut self.s));
-                try!(self.word_space("|"));
-            }
-            try!(self.print_pat(&**p));
-        }
-        try!(space(&mut self.s));
-        match arm.guard {
-            Some(ref e) => {
-                try!(self.word_space("if"));
-                try!(self.print_expr(&**e));
-                try!(space(&mut self.s));
-            }
-            None => ()
-        }
-        try!(self.word_space("=>"));
-
-        match arm.body.node {
-            ast::ExprBlock(ref blk) => {
-                // the block will close the pattern's ibox
-                self.print_block_unclosed_indent(&**blk, indent_unit)
-            }
-            _ => {
-                try!(self.end()); // close the ibox for the pattern
-                self.print_expr(&*arm.body)
-            }
-        }
-    }
-
     pub fn print_pat(&mut self, pat: &ast::Pat) -> IoResult<()> {
         try!(self.maybe_print_comment(pat.span.lo));
         try!(self.ann.pre(self, NodePat(pat)));
diff --git a/src/libsyntax/visit.rs b/src/libsyntax/visit.rs
index c11eb98..65e192e 100644
--- a/src/libsyntax/visit.rs
+++ b/src/libsyntax/visit.rs
@@ -788,7 +788,7 @@ pub fn walk_expr<E: Clone, V: Visitor<E>>(visitor: &mut V, expression: &Expr, en
         ExprMatch(ref subexpression, ref arms) => {
             visitor.visit_expr(&**subexpression, env.clone());
             for arm in arms.iter() {
-                visitor.visit_arm(&**arm, env.clone())
+                visitor.visit_arm(arm, env.clone())
             }
         }
         ExprFnBlock(_, ref function_declaration, ref body) => {

commit af203fcd69dfd6461cc176d304f135fafd168382
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Wed Aug 6 01:14:25 2014 +0200

    rust-needsdrop: switch to lint infrastructure for "early drop" warnings.
    
    I have been having some difficulty bootstrapping this (I eventually
    resorted to switching to `-W warnings` in `mk/target.mk`).  Figure out
    whether I can indeed just do `#[warn(early_drop)]` to sidestep the
    outermost `-D warnings` or if there is something else going on here
    that I do not yet get.
---
 src/librustc/lint/builtin.rs                |  4 ++++
 src/librustc/middle/borrowck/check_drops.rs | 16 +++++++++-------
 2 files changed, 13 insertions(+), 7 deletions(-)

diff --git a/src/librustc/lint/builtin.rs b/src/librustc/lint/builtin.rs
index 5e3ab0f..8458d30 100644
--- a/src/librustc/lint/builtin.rs
+++ b/src/librustc/lint/builtin.rs
@@ -1554,6 +1554,9 @@ declare_lint!(pub VISIBLE_PRIVATE_TYPES, Warn,
 declare_lint!(pub UNREACHABLE_CODE, Warn,
               "detects unreachable code")
 
+declare_lint!(pub EARLY_DROP, Warn,
+              "detect drops that will happen earlier when drop flags are gone")
+
 declare_lint!(pub WARNINGS, Warn,
               "mass-change the level for lints which produce warnings")
 
@@ -1582,6 +1585,7 @@ impl LintPass for HardwiredLints {
             UNUSED_VARIABLE,
             DEAD_ASSIGNMENT,
             DEAD_CODE,
+            EARLY_DROP,
             VISIBLE_PRIVATE_TYPES,
             UNREACHABLE_CODE,
             WARNINGS,
diff --git a/src/librustc/middle/borrowck/check_drops.rs b/src/librustc/middle/borrowck/check_drops.rs
index 8ce37b4..4f7150f 100644
--- a/src/librustc/middle/borrowck/check_drops.rs
+++ b/src/librustc/middle/borrowck/check_drops.rs
@@ -14,6 +14,7 @@
 use middle::borrowck::*;
 use middle::borrowck::move_data::{Assignment, Move};
 use euv = middle::expr_use_visitor;
+use lint;
 use mc = middle::mem_categorization;
 use middle::dataflow;
 use middle::graph;
@@ -23,7 +24,7 @@ use middle::ty::TypeContents;
 use std::rc::Rc;
 use std::collections::hashmap::HashMap;
 use std::sync::atomics;
-use syntax::{ast,ast_map};
+use syntax::{ast,ast_map,codemap};
 use util::ppaux::Repr;
 
 static mut warning_count: atomics::AtomicUint = atomics::INIT_ATOMIC_UINT;
@@ -200,11 +201,12 @@ pub fn check_drops(bccx: &BorrowckCtxt,
                                        or reinitializing it on the other paths); count: {}",
                                       loan_path_str, where, count);
 
-                    match opt_source_span {
-                        Some(span) => bccx.tcx.sess.span_warn(span, msg.as_slice()),
-                        None => bccx.tcx.sess.warn(msg.as_slice()),
-                    }
-                    cfg.graph.each_incoming_edge(node_index, |edge_index, edge| {
+                    bccx.tcx.sess.add_lint(lint::builtin::EARLY_DROP,
+                                           source_id,
+                                           opt_source_span.unwrap_or(codemap::DUMMY_SP),
+                                           msg);
+
+                    if false { cfg.graph.each_incoming_edge(node_index, |edge_index, edge| {
                         let source2 = edge.source();
                         if !cfg.is_reachable(source2) {
                             return true;
@@ -232,7 +234,7 @@ pub fn check_drops(bccx: &BorrowckCtxt,
                             }
                         }
                         true
-                    });
+                    }); }
 
                     true
                 });

commit 9dcefd83eda9b06e764b15685ac18d683dde4d36
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Wed Aug 6 01:13:58 2014 +0200

    lint and ast_util: support Arm's as first class ast entities with node-id's.
---
 src/librustc/lint/context.rs | 7 +++++--
 src/libsyntax/ast_util.rs    | 5 +++++
 2 files changed, 10 insertions(+), 2 deletions(-)

diff --git a/src/librustc/lint/context.rs b/src/librustc/lint/context.rs
index 26ed5cb..5e2b660 100644
--- a/src/librustc/lint/context.rs
+++ b/src/librustc/lint/context.rs
@@ -607,8 +607,11 @@ impl<'a, 'tcx> Visitor<()> for Context<'a, 'tcx> {
     }
 
     fn visit_arm(&mut self, a: &ast::Arm, _: ()) {
-        run_lints!(self, check_arm, a);
-        visit::walk_arm(self, a, ());
+        self.with_lint_attrs(a.attrs.as_slice(), |cx| {
+            run_lints!(cx, check_arm, a);
+            cx.visit_ids(|v| v.visit_arm(a, ()));
+            visit::walk_arm(cx, a, ());
+        })
     }
 
     fn visit_decl(&mut self, d: &ast::Decl, _: ()) {
diff --git a/src/libsyntax/ast_util.rs b/src/libsyntax/ast_util.rs
index 8ef13ef..396f4ba 100644
--- a/src/libsyntax/ast_util.rs
+++ b/src/libsyntax/ast_util.rs
@@ -451,6 +451,11 @@ impl<'a, O: IdVisitingOperation> Visitor<()> for IdVisitor<'a, O> {
         visit::walk_stmt(self, statement, env)
     }
 
+    fn visit_arm(&mut self, a: &Arm, env: ()) {
+        self.operation.visit_id(a.id);
+        visit::walk_arm(self, a, env)
+    }
+
     fn visit_pat(&mut self, pattern: &Pat, env: ()) {
         self.operation.visit_id(pattern.id);
         visit::walk_pat(self, pattern, env)

commit b2820c4bbd5112c200d589f88bf23283010f32a4
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Tue Aug 5 11:05:00 2014 +0200

    rust-needsdrop: add cat_downcast on struct-like enum variants.
---
 src/librustc/middle/mem_categorization.rs | 14 +++++++++++++-
 1 file changed, 13 insertions(+), 1 deletion(-)

diff --git a/src/librustc/middle/mem_categorization.rs b/src/librustc/middle/mem_categorization.rs
index 4b33e6a..d899e8f 100644
--- a/src/librustc/middle/mem_categorization.rs
+++ b/src/librustc/middle/mem_categorization.rs
@@ -1105,9 +1105,21 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {
 
           ast::PatStruct(_, ref field_pats, _) => {
             // {f1: p1, ..., fN: pN}
+            let downcast_cmt = match self.tcx().def_map.borrow().find(&pat.id) {
+                Some(&def::DefVariant(enum_did, variant_did, _)) => {
+                    // variant{ a: x, b: y, c: z }
+                    if ty::enum_is_univariant(self.tcx(), enum_did) {
+                        cmt // univariant, no downcast needed
+                    } else {
+                        self.cat_downcast(pat, cmt.clone(), cmt.ty, variant_did)
+                    }
+                }
+                _ => cmt,
+            };
+
             for fp in field_pats.iter() {
                 let field_ty = if_ok!(self.pat_ty(&*fp.pat)); // see (*2)
-                let cmt_field = self.cat_field(pat, cmt.clone(), fp.ident, field_ty);
+                let cmt_field = self.cat_field(pat, downcast_cmt.clone(), fp.ident, field_ty);
                 if_ok!(self.cat_pattern(cmt_field, &*fp.pat, |x,y,z| op(x,y,z)));
             }
           }

commit 01adc09b678924a159bd531bea5f953815282fb7
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Tue Aug 5 10:53:03 2014 +0200

    Provide better info about what went wrong when we do not have enum_variant_info.
---
 src/librustc/middle/borrowck/move_data.rs | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/librustc/middle/borrowck/move_data.rs b/src/librustc/middle/borrowck/move_data.rs
index 1bdb162..948c908 100644
--- a/src/librustc/middle/borrowck/move_data.rs
+++ b/src/librustc/middle/borrowck/move_data.rs
@@ -711,7 +711,7 @@ impl MoveData {
                             .expect("enum_variant_with_id(): no variant exists with that ID")
                             .clone(),
                         None => {
-                            assert!(variants.len() == 1);
+                            assert_eq!(variants.len(), 1);
                             variants.pop().unwrap()
                         }
                     }

commit a2ee052d4032ff04a042ce0bd483c8f39cc5a064
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Mon Aug 4 20:53:35 2014 +0200

    rust-needsdrop: Ridculous hackery for support of array/slice elem access.
    
    Much refactoring still needed.  But this gets me to the point where
    both foo33 and foo34 work.
---
 src/librustc/middle/borrowck/mod.rs | 119 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++----------------------------
 1 file changed, 91 insertions(+), 28 deletions(-)

diff --git a/src/librustc/middle/borrowck/mod.rs b/src/librustc/middle/borrowck/mod.rs
index 539e1a6..2efe810 100644
--- a/src/librustc/middle/borrowck/mod.rs
+++ b/src/librustc/middle/borrowck/mod.rs
@@ -307,8 +307,8 @@ impl LoanPath {
         use Field = middle::mem_categorization::InteriorField;
 
         debug!("lp.to_type() for lp={:s}", self.repr(tcx));
-        let opt_ty = match *self {
-            LpUpvar(ty::UpvarId { var_id: id, closure_expr_id: _ }, capture) =>
+        let ty = match *self {
+            LpUpvar(ty::UpvarId { var_id: id, closure_expr_id: _ }, capture) => {
                 ty::node_id_to_type_opt(tcx, id).map(|t| {
                     match capture {
                         CaptureByVal => t,
@@ -317,14 +317,27 @@ impl LoanPath {
                                                    // making up immut here.
                                                    // Hopefully won't matter.
                                                    mutbl: ast::MutImmutable}),
-                    }}),
+                    }}).unwrap_or_else(|| {
+                    let id = self.kill_scope(tcx);
+                    let msg = format!("no type found for LpUpvar={:s}", self.repr(tcx));
+                    let opt_span = tcx.map.opt_span(id);
+                    tcx.sess.opt_span_bug(opt_span, msg.as_slice());
+                })
+            }
 
-            LpVar(id) => ty::node_id_to_type_opt(tcx, id),
+            LpVar(id) => {
+                ty::node_id_to_type_opt(tcx, id).unwrap_or_else(|| {
+                    let id = self.kill_scope(tcx);
+                    let msg = format!("no type found for LpVar={:s}", self.repr(tcx));
+                    let opt_span = tcx.map.opt_span(id);
+                    tcx.sess.opt_span_bug(opt_span, msg.as_slice());
+                })
+            }
 
             // treat the downcasted enum as having the enum's type;
             // extracting the particular types within the variant is
             // handled by `LpExtend` cases.
-            LpDowncast(ref lp, _variant_did) => Some(lp.to_type(tcx)),
+            LpDowncast(ref lp, _variant_did) => lp.to_type(tcx),
 
             LpExtend(ref lp, _mc, ref loan_path_elem) => {
                 let (opt_variant_did, lp) = match **lp {
@@ -337,27 +350,75 @@ impl LoanPath {
                 let t = lp.to_type(tcx);
                 let t_sty = &ty::get(t).sty;
 
+                let base_deref_t = match **lp {
+                    LpExtend(ref lp2, _, LpDeref(_)) => Some(lp2.to_type(tcx)),
+                    _                                => None,
+                };
+                let base_elem_t =
+                    base_deref_t.and_then(|t|ty::array_element_ty(t));
+
                 match (loan_path_elem, t_sty) {
+
                     (&LpDeref(_), &ty::ty_ptr(ty::mt{ty: t, ..})) |
                     (&LpDeref(_), &ty::ty_rptr(_, ty::mt{ty: t, ..})) |
                     (&LpDeref(_), &ty::ty_box(t)) |
-                    (&LpDeref(_), &ty::ty_uniq(t)) => Some(t),
+                    (&LpDeref(_), &ty::ty_uniq(t)) => t,
 
                     (&LpInterior(Field(mc::NamedField(ast_name))),
-                     _) => ty::named_element_ty(tcx, t, ast_name, opt_variant_did),
+                     _) => ty::named_element_ty(tcx, t, ast_name, opt_variant_did)
+                        .unwrap_or_else(|| {
+                            let id = self.kill_scope(tcx);
+                            let msg = format!("no type found for LpExtend LpInterior NamedField={:s}", self.repr(tcx));
+                            let opt_span = tcx.map.opt_span(id);
+                            tcx.sess.opt_span_bug(opt_span, msg.as_slice());
+                        }),
 
                     (&LpInterior(Field(mc::PositionalField(idx))),
-                     _) => ty::positional_element_ty(tcx, t, idx, opt_variant_did),
-
-                    // (Deliberately not using ty::array_element_ty
-                    // here, because that assumes r-value context and
-                    // returns deref'ed elem type, but loan structure
-                    // separates element-access from deref.)
-                    (&LpInterior(Element(_)), &ty::ty_str) =>
-                        Some(ty::mk_ptr(tcx, ty::mt{ty: ty::mk_u8(),
-                                                    mutbl: ast::MutImmutable})),
-                    (&LpInterior(Element(_)), &ty::ty_vec(mt, _len)) =>
-                        Some(ty::mk_ptr(tcx, mt)),
+                     _) => ty::positional_element_ty(tcx, t, idx, opt_variant_did)
+                        .unwrap_or_else(|| {
+                            let id = self.kill_scope(tcx);
+                            let msg = format!("no type found for LpExtend LpInterior PositionalField={:s}", self.repr(tcx));
+                            let opt_span = tcx.map.opt_span(id);
+                            tcx.sess.opt_span_bug(opt_span, msg.as_slice());
+                        }),
+
+                    // FIXME: Complete hack; array_element_ty does not
+                    // yet do Dynamically Sized Types (DST); (instead
+                    // it returns none for `[T]`).  So catch such
+                    // cases ahead of time, instead of returning a
+                    // type that we cannot actually handle recursively
+                    // (which is what the subsequent clauses would
+                    // do).  Though we should strongly consider just
+                    // revising array_element_ty to also map input
+                    // `[T]` to `Some(T)` rather than `None` (FSK).
+                    (&LpInterior(Element(_)), _) if base_elem_t.is_some() =>
+                        base_elem_t.unwrap().ty,
+
+                    // FIXME: At one point I was deliberately
+                    // eschewing ty::array_element_ty because I
+                    // thought it was presuming r-value context and
+                    // loan-path structure kept element-access
+                    // separate from deref.  But now I am not so sure
+                    // what is appropriate here anymore.  So I am
+                    // trying ty::array_element_ty out of desperation
+                    // mostly.  See also the complete hack in the
+                    // clause above (FSK).
+
+                    // FIXME I could at least merge the two clauses (FSK).
+
+                    (&LpInterior(Element(_)), _) => ty::array_element_ty(t)
+                        .unwrap_or_else(|| {
+                            // Once, we would get into this case when
+                            // we are given a `&[T]`, rather than a
+                            // `[T, ..N]`.  But now that is handled up
+                            // above.
+                            let id = self.kill_scope(tcx);
+                            let msg = format!("no array elem type found for \
+                                               LpExtend LpInterior Element={:s} t={}",
+                                              self.repr(tcx), t.repr(tcx));
+                            let opt_span = tcx.map.opt_span(id);
+                            tcx.sess.opt_span_bug(opt_span, msg.as_slice());
+                        }).ty,
 
                     (lp_elem, _) => {
                         let id = self.kill_scope(tcx);
@@ -371,15 +432,9 @@ impl LoanPath {
                 }
             }
         };
-        let t = opt_ty.unwrap_or_else(|| {
-            let id = self.kill_scope(tcx);
-            let msg = format!("no type found for lp={:s}", self.repr(tcx));
-            let opt_span = tcx.map.opt_span(id);
-            tcx.sess.opt_span_bug(opt_span, msg.as_slice());
-        });
-        debug!("lp.to_type() for lp={:s} returns t={:s}",
-               self.repr(tcx), t.repr(tcx));
-        t
+        debug!("lp.to_type() for lp={:s} returns ty={:s}",
+               self.repr(tcx), ty.repr(tcx));
+        ty
     }
 
     fn needs_drop(&self, tcx: &ty::ctxt) -> bool {
@@ -463,7 +518,15 @@ impl LoanPath {
 
                 type_contents.needs_drop_call(tcx)
             }
-            _ => fail!("encountered LpDowncast on non-enum base type."),
+            _ => {
+                debug!("needs_drop encountered LpDowncast on non-enum base type: {}",
+                       lp_type.repr(tcx));
+                let msg = format!("encountered LpDowncast on non-enum base type: {}.",
+                                  lp_type.repr(tcx));
+                tcx.sess.opt_span_warn(tcx.map.opt_span(self.kill_id(tcx)),
+                                       msg.as_slice());
+                false
+            }
         }
     }
 }

commit c793012fe90025e0a2a61f7ecb3cb57cf3b95dbd
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Mon Aug 4 16:56:24 2014 +0200

    rust-needsdrop: flow-sensitive filter of needs-drop values that are actually non-drop variants.
    
    The pieces of this puzzle are:
    
      * Expanded the `expr_use_visitor::Delegate` in `gather_loans` to
        pass through all match variants, regardless of whether they are
        borrowing or consuming.  Track the match mode (borrowing, copying,
        moving) in the `move_data::VariantMatch`.
    
      * In light of the above: we continue to filter out borrowing
        variants when updating the drop obligations (since a borrowing
        match is not consuming the input, while a moving match does, and
        its better for the overall results to continue having the
        needs_drop dataflow track that), but we also track when the
        particular variant actually implies that the drop is unnecessary:
        the latter is the `ignore_drop` state.
    
      * Added a simple dataflow analysis based on `ignore_drop`; that is
        `dfcx_ignore_drop`, and included it in the graphviz
        instrumentation.
    
      * In `check_drops`, if we encounter a claimed inconsistency on some
        control flow edge, check the `ignore_drop` state on the edge
        source node; if this drop is irrelevant because the variant is
        non-needs-drop on that control-flow branch, then we do not need to
        warn about this particular inconsistency, so skip it.
---
 src/librustc/driver/driver.rs                             |  1 +
 src/librustc/middle/borrowck/check_drops.rs               | 11 +++++++++++
 src/librustc/middle/borrowck/gather_loans/gather_moves.rs | 12 +++++++-----
 src/librustc/middle/borrowck/gather_loans/mod.rs          | 10 ++--------
 src/librustc/middle/borrowck/graphviz.rs                  | 28 ++++++++++++++++++++--------
 src/librustc/middle/borrowck/move_data.rs                 | 94 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++--------
 6 files changed, 127 insertions(+), 29 deletions(-)

diff --git a/src/librustc/driver/driver.rs b/src/librustc/driver/driver.rs
index 8163fcf..1983e9c 100644
--- a/src/librustc/driver/driver.rs
+++ b/src/librustc/driver/driver.rs
@@ -970,6 +970,7 @@ fn gather_flowgraph_variants(sess: &Session) -> Vec<borrowck_dot::Variant> {
     }
     if opt(print_all) || opt(print_needs_drop) {
         variants.push(borrowck_dot::NeedsDrop);
+        variants.push(borrowck_dot::IgnoreDrop);
     }
     variants
 }
diff --git a/src/librustc/middle/borrowck/check_drops.rs b/src/librustc/middle/borrowck/check_drops.rs
index 1d7fc2a..8ce37b4 100644
--- a/src/librustc/middle/borrowck/check_drops.rs
+++ b/src/librustc/middle/borrowck/check_drops.rs
@@ -24,6 +24,7 @@ use std::rc::Rc;
 use std::collections::hashmap::HashMap;
 use std::sync::atomics;
 use syntax::{ast,ast_map};
+use util::ppaux::Repr;
 
 static mut warning_count: atomics::AtomicUint = atomics::INIT_ATOMIC_UINT;
 
@@ -84,6 +85,7 @@ pub fn check_drops(bccx: &BorrowckCtxt,
 
         let move_data = &flowed_move_data.move_data;
         let needs_drop = &flowed_move_data.dfcx_needs_drop;
+        let ignore_drop = &flowed_move_data.dfcx_ignore_drop;
         let path_count = move_data.paths.borrow().len();
 
         let intersection = needs_drop.bitset_for(dataflow::Entry, node_index);
@@ -159,6 +161,13 @@ pub fn check_drops(bccx: &BorrowckCtxt,
                     let path = paths.get(bit_idx);
                     let lp = &path.loan_path;
 
+                    let ignored_paths = ignore_drop.bitset_for(dataflow::Exit, source);
+                    if dataflow::is_bit_set(ignored_paths.as_slice(), bit_idx) {
+                        debug!("check_drops can ignore lp={} as it is non-drop on this path.",
+                               lp.repr(bccx.tcx));
+                        return true;
+                    }
+
                     // Check if there is a single effect-free
                     // successor chain that leads to the end of the
                     // scope of the local variable at the base of `lp`
@@ -166,6 +175,8 @@ pub fn check_drops(bccx: &BorrowckCtxt,
                     // without warning the user)
                     let kill_id = lp.kill_id(bccx.tcx);
                     if scan_forward_for_kill_id(bccx, cfg, node_index, kill_id) {
+                        debug!("check_drops can ignore lp={} as its scope-end is imminent.",
+                               lp.repr(bccx.tcx));
                         return true;
                     }
 
diff --git a/src/librustc/middle/borrowck/gather_loans/gather_moves.rs b/src/librustc/middle/borrowck/gather_loans/gather_moves.rs
index 69fecf6..f007a0f 100644
--- a/src/librustc/middle/borrowck/gather_loans/gather_moves.rs
+++ b/src/librustc/middle/borrowck/gather_loans/gather_moves.rs
@@ -61,13 +61,14 @@ pub fn gather_move_from_expr(bccx: &BorrowckCtxt,
     gather_move(bccx, move_data, move_error_collector, move_info);
 }
 
-pub fn gather_move_into_variant(bccx: &BorrowckCtxt,
+pub fn gather_match_variant(bccx: &BorrowckCtxt,
                                 move_data: &MoveData,
                                 _move_error_collector: &MoveErrorCollector,
                                 move_pat: &ast::Pat,
-                                cmt: mc::cmt) { 
-    debug!("gather_match(move_pat={}, cmt={})",
-           move_pat.id, cmt.repr(bccx.tcx));
+                                cmt: mc::cmt,
+                                mode: euv::MatchMode) {
+    debug!("gather_match_variant(move_pat={}, cmt={}, mode={})",
+           move_pat.id, cmt.repr(bccx.tcx), mode);
 
     let opt_lp = opt_loan_path(&cmt, bccx.tcx);
     let opt_base_lp = match cmt.cat {
@@ -79,7 +80,8 @@ pub fn gather_move_into_variant(bccx: &BorrowckCtxt,
             move_data.add_variant_match(bccx.tcx,
                                         loan_path,
                                         move_pat.id,
-                                        base_loan_path);
+                                        base_loan_path,
+                                        mode);
         }
         (lp, base_lp) => {
             debug!("add_variant_match body for ({:?}, {:?}) NOT YET IMPLEMENTED", lp, base_lp);
diff --git a/src/librustc/middle/borrowck/gather_loans/mod.rs b/src/librustc/middle/borrowck/gather_loans/mod.rs
index 7dab3e3..26788ea 100644
--- a/src/librustc/middle/borrowck/gather_loans/mod.rs
+++ b/src/librustc/middle/borrowck/gather_loans/mod.rs
@@ -93,17 +93,11 @@ impl<'a, 'tcx> euv::Delegate for GatherLoanCtxt<'a, 'tcx> {
                cmt.repr(self.tcx()),
                mode);
 
-        match mode {
-            euv::BorrowingMatch |
-            euv::ConsumingMatch(euv::Copy) => return,
-            euv::ConsumingMatch(euv::Move(_)) => {}
-        }
-
         match cmt.cat {
             mc::cat_downcast(..) =>
-                gather_moves::gather_move_into_variant(
+                gather_moves::gather_match_variant(
                     self.bccx, &self.move_data, &self.move_error_collector,
-                    matched_pat, cmt),
+                    matched_pat, cmt, mode),
             _ => {}
         }
     }
diff --git a/src/librustc/middle/borrowck/graphviz.rs b/src/librustc/middle/borrowck/graphviz.rs
index 48a3c5f..48aed81 100644
--- a/src/librustc/middle/borrowck/graphviz.rs
+++ b/src/librustc/middle/borrowck/graphviz.rs
@@ -32,15 +32,17 @@ pub enum Variant {
     Moves,
     Assigns,
     NeedsDrop,
+    IgnoreDrop,
 }
 
 impl Variant {
     pub fn short_name(&self) -> &'static str {
         match *self {
-            Loans     => "loans",
-            Moves     => "moves",
-            Assigns   => "assigns",
-            NeedsDrop => "needs_drop",
+            Loans      => "loans",
+            Moves      => "moves",
+            Assigns    => "assigns",
+            NeedsDrop  => "needs_drop",
+            IgnoreDrop => "ignore_drop",
         }
     }
 }
@@ -70,10 +72,11 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {
     fn dataflow_for_variant(&self, e: EntryOrExit, n: &Node, v: Variant) -> String {
         let cfgidx = n.val0();
         match v {
-            Loans     => self.dataflow_loans_for(e, cfgidx),
-            Moves     => self.dataflow_moves_for(e, cfgidx),
-            Assigns   => self.dataflow_assigns_for(e, cfgidx),
-            NeedsDrop => self.dataflow_needs_drop_for(e, cfgidx),
+            Loans      => self.dataflow_loans_for(e, cfgidx),
+            Moves      => self.dataflow_moves_for(e, cfgidx),
+            Assigns    => self.dataflow_assigns_for(e, cfgidx),
+            NeedsDrop  => self.dataflow_needs_drop_for(e, cfgidx),
+            IgnoreDrop => self.dataflow_ignore_drop_for(e, cfgidx),
         }
     }
 
@@ -136,6 +139,15 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {
         };
         self.build_set(e, cfgidx, dfcx, needs_drop_index_to_path)
     }
+
+    fn dataflow_ignore_drop_for(&self, e: EntryOrExit, cfgidx: CFGIndex) -> String {
+        let dfcx = &self.analysis_data.move_data.dfcx_ignore_drop;
+        let ignore_drop_index_to_path = |ignore_drop_index| {
+            let move_data = &self.analysis_data.move_data.move_data;
+            move_data.path_loan_path(borrowck::move_data::MovePathIndex(ignore_drop_index))
+        };
+        self.build_set(e, cfgidx, dfcx, ignore_drop_index_to_path)
+    }
 }
 
 impl<'a, 'tcx> dot::Labeller<'a, Node<'a>, Edge<'a>> for DataflowLabeller<'a, 'tcx> {
diff --git a/src/librustc/middle/borrowck/move_data.rs b/src/librustc/middle/borrowck/move_data.rs
index b58b071..1bdb162 100644
--- a/src/librustc/middle/borrowck/move_data.rs
+++ b/src/librustc/middle/borrowck/move_data.rs
@@ -82,6 +82,11 @@ pub struct FlowedMoveData<'a, 'tcx: 'a> {
     pub dfcx_assign: AssignDataFlow<'a, 'tcx>
 
     pub dfcx_needs_drop: NeedsDropDataFlow<'a, 'tcx>,
+
+    /// If we match a variant for which no drop is necessary, then on
+    /// this branch (alone), no-drop is necessary for the original
+    /// path.  That flow-sensitive inforamtion is tracked here.
+    pub dfcx_ignore_drop: IgnoreDropDataFlow<'a, 'tcx>,
 }
 
 /// Index into `MoveData.paths`, used like a pointer
@@ -178,6 +183,9 @@ pub struct VariantMatch {
 
     /// id where variant's pattern occurs
     pub id: ast::NodeId,
+
+    /// says if variant established by move (and why), by copy, or by borrow.
+    pub mode: euv::MatchMode
 }
 
 #[deriving(Clone)]
@@ -194,6 +202,10 @@ pub type AssignDataFlow<'a, 'tcx> = DataFlowContext<'a, 'tcx, AssignDataFlowOper
 pub struct NeedsDropDataFlowOperator;
 pub type NeedsDropDataFlow<'a> = DataFlowContext<'a, NeedsDropDataFlowOperator>;
 
+#[deriving(Clone)]
+pub struct IgnoreDropDataFlowOperator;
+pub type IgnoreDropDataFlow<'a> = DataFlowContext<'a, IgnoreDropDataFlowOperator>;
+
 fn loan_path_is_precise(loan_path: &LoanPath) -> bool {
     match *loan_path {
         LpVar(_) | LpUpvar(..) => {
@@ -555,11 +567,12 @@ impl MoveData {
                          tcx: &ty::ctxt,
                          lp: Rc<LoanPath>,
                          pattern_id: ast::NodeId,
-                         base_lp: Rc<LoanPath>) {
+                         base_lp: Rc<LoanPath>,
+                         mode: euv::MatchMode) {
         /*!
          * Adds a new record for an match of `base_lp`, downcast to
          * variant `lp`, that occurs at location `pattern_id`.  (One
-         * should be able to recover teh span info from the
+         * should be able to recover the span info from the
          * `pattern_id` and the ast_map, I think.)
          */
         debug!("add_variant_match(lp={}, pattern_id={:?})",
@@ -573,6 +586,7 @@ impl MoveData {
             path: path_index,
             base_path: base_path_index,
             id: pattern_id,
+            mode: mode,
         };
 
         self.variant_matches.borrow_mut().push(variant_match);
@@ -764,7 +778,8 @@ impl MoveData {
                      tcx: &ty::ctxt,
                      dfcx_moves: &mut MoveDataFlow,
                      dfcx_assign: &mut AssignDataFlow,
-                     dfcx_needs_drop: &mut NeedsDropDataFlow) {
+                     dfcx_needs_drop: &mut NeedsDropDataFlow,
+                     dfcx_ignore_drop: &mut IgnoreDropDataFlow) {
         /*!
          * Adds the gen/kills for the various moves and
          * assignments into the provided data flow contexts.
@@ -812,13 +827,23 @@ impl MoveData {
             dfcx_moves.add_gen(move.id, i);
             debug!("remove_drop_obligations move {}", move.to_string(self, tcx));
             self.remove_drop_obligations(tcx, move, dfcx_needs_drop);
+            // FIXME: do I need to also remove_ignored_drops here? (FSK)
         }
 
         for variant_match in self.variant_matches.borrow().iter() {
-            debug!("remove_drop_obligations variant_match {}", variant_match.to_string(self, tcx));
-            self.remove_drop_obligations(tcx, variant_match, dfcx_needs_drop);
-            debug!("add_drop_obligations variant_match {}", variant_match.to_string(self, tcx));
-            self.add_drop_obligations(tcx, variant_match, dfcx_needs_drop);
+            match variant_match.mode {
+                euv::BorrowingMatch => {}
+                euv::ConsumingMatch(_consume_mode) => {
+                    debug!("remove_drop_obligations variant_match {}", variant_match.to_string(self, tcx));
+                    self.remove_drop_obligations(tcx, variant_match, dfcx_needs_drop);
+                    // FIXME: do I need to also remove_ignored_drops here? (FSK)
+                    debug!("add_drop_obligations variant_match {}", variant_match.to_string(self, tcx));
+                    self.add_drop_obligations(tcx, variant_match, dfcx_needs_drop);
+                }
+            }
+
+            debug!("add_ignored_drops variant_match {}", variant_match.to_string(self, tcx));
+            self.add_ignored_drops(tcx, variant_match, dfcx_ignore_drop);
         }
 
         for (i, assignment) in self.var_assignments.borrow().iter().enumerate() {
@@ -847,6 +872,7 @@ impl MoveData {
                            kill_id, path.loan_path.repr(tcx));
                     let rm = Removed { where: kill_id, what_path: move_path_index };
                     self.remove_drop_obligations(tcx, &rm, dfcx_needs_drop);
+                    // FIXME: do I need to also remove_ignored_drops here? (FSK)
                 }
                 LpUpvar(ty::UpvarId { var_id: _, closure_expr_id }, _) => {
                     let kill_id = closure_to_block(closure_expr_id, tcx);
@@ -856,6 +882,7 @@ impl MoveData {
                            kill_id, path.loan_path.repr(tcx));
                     let rm = Removed { where: kill_id, what_path: move_path_index };
                     self.remove_drop_obligations(tcx, &rm, dfcx_needs_drop);
+                    // FIXME: do I need to also remove_ignored_drops here? (FSK)
                 }
                 LpDowncast(..) => {} // FIXME: is this right, or should this loop to top?
                 LpExtend(..) => {}
@@ -1135,6 +1162,23 @@ impl MoveData {
 
         self.for_each_leaf(tcx, path, add_kill, report_variant);
     }
+
+    fn add_ignored_drops(&self,
+                         tcx: &ty::ctxt,
+                         variant_match: &VariantMatch,
+                         dfcx_ignore_drop: &mut IgnoreDropDataFlow) {
+        let path_lp = self.path_loan_path(variant_match.path);
+        let base_path_lp = self.path_loan_path(variant_match.base_path);
+
+        if !self.path_needs_drop(tcx, variant_match.path) {
+            debug!("add_ignored_drops(id={} lp={}) adds {}",
+                   variant_match.id, path_lp.repr(tcx), base_path_lp.repr(tcx));
+            dfcx_ignore_drop.add_gen(variant_match.id, variant_match.base_path.get());
+        } else {
+            debug!("add_ignored_drops(id={} lp={}) skipped {}",
+                   variant_match.id, path_lp.repr(tcx), base_path_lp.repr(tcx));
+        }
+    }
 }
 
 trait AddNeedsDropArg {
@@ -1203,24 +1247,37 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {
                                  NeedsDropDataFlowOperator,
                                  id_range,
                                  move_data.paths.borrow().len());
+        let mut dfcx_ignore_drop =
+            DataFlowContext::new(tcx,
+                                 "flowed_move_data_ignore_drop",
+                                 Some(decl),
+                                 cfg,
+                                 IgnoreDropDataFlowOperator,
+                                 id_range,
+                                 move_data.paths.borrow().len());
+
         move_data.add_gen_kills(tcx,
                                 &mut dfcx_moves,
                                 &mut dfcx_assign,
-                                &mut dfcx_needs_drop);
+                                &mut dfcx_needs_drop,
+                                &mut dfcx_ignore_drop);
 
         dfcx_moves.add_kills_from_flow_exits(cfg);
         dfcx_assign.add_kills_from_flow_exits(cfg);
         dfcx_needs_drop.add_kills_from_flow_exits(cfg);
+        dfcx_ignore_drop.add_kills_from_flow_exits(cfg);
 
         dfcx_moves.propagate(cfg, body);
         dfcx_assign.propagate(cfg, body);
         dfcx_needs_drop.propagate(cfg, body);
+        dfcx_ignore_drop.propagate(cfg, body);
 
         FlowedMoveData {
             move_data: move_data,
             dfcx_moves: dfcx_moves,
             dfcx_assign: dfcx_assign,
             dfcx_needs_drop: dfcx_needs_drop,
+            dfcx_ignore_drop: dfcx_ignore_drop,
         }
     }
 
@@ -1521,3 +1578,24 @@ impl DataFlowOperator for NeedsDropDataFlowOperator {
         false
     }
 }
+
+impl BitwiseOperator for IgnoreDropDataFlowOperator {
+    #[inline]
+    fn join(&self, succ: uint, pred: uint) -> uint {
+        // You can only ignore a drop if both incoming paths agree that you can do so
+        succ & pred
+    }
+}
+
+impl DataFlowOperator for IgnoreDropDataFlowOperator {
+    #[inline]
+    fn initial_value(&self) -> bool {
+        // For non-entry nodes, assume you can ignore a drop until proven otherwise.
+        true
+    }
+
+    #[inline]
+    fn entry_initial_value(&self) -> bool {
+        false
+    }
+}

commit bcddda924472a5aee531911d73b7924e44fbedfa
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Mon Aug 4 13:39:06 2014 +0200

    rust-needsdrop: address handling of `Box<T>`.
    
    Assinging to a `*boxed_ptr` can introduce a drop obligation even
    though `*borrowed_ptr` will not.
---
 src/librustc/middle/borrowck/mod.rs       | 21 +++++++++++++++++----
 src/librustc/middle/borrowck/move_data.rs |  9 +--------
 2 files changed, 18 insertions(+), 12 deletions(-)

diff --git a/src/librustc/middle/borrowck/mod.rs b/src/librustc/middle/borrowck/mod.rs
index b73ba9a..539e1a6 100644
--- a/src/librustc/middle/borrowck/mod.rs
+++ b/src/librustc/middle/borrowck/mod.rs
@@ -384,28 +384,41 @@ impl LoanPath {
 
     fn needs_drop(&self, tcx: &ty::ctxt) -> bool {
         //! Returns true if this loan path needs drop glue.  I.e.,
-        //! does introducing this loan path as a binding introduce a
-        //! new drop obligation.
+        //! does assigning to this loan path introduce a new drop
+        //! obligation.
 
         debug!("needs_drop(tcx) self={}", self.repr(tcx));
 
         match *self {
             LpVar(_) | LpUpvar(..) =>
                 // Variables are the easiest case: just use their
-                // types to determine wwhether they introduce a drop
+                // types to determine whether they introduce a drop
                 // obligation when assigned.  (FSK well, at the
                 // *moment* they are easy; we may put in
                 // flow-sensitivity in some form.  Or maybe not, we
                 // will see.)
                 self.to_type(tcx).needs_drop_call(tcx),
 
-            LpExtend(_, _, LpDeref(_)) =>
+            LpExtend(_, _, LpDeref(mc::BorrowedPtr(..))) |
+            LpExtend(_, _, LpDeref(mc::Implicit(..)))    =>
                 // A path through a `&` or `&mut` reference cannot
                 // introduce a drop obligation; e.g. the assignment
                 // `*p = box 3u` installs a pointer elsewhere that is
                 // the responsibility of someone else (e.g. a caller).
                 false,
 
+            LpExtend(_, _, LpDeref(mc::OwnedPtr)) =>
+                // However, an assignment to a deref of a Box<T> is
+                // conceptually owned by the parent and thus does
+                // introduce a drop obligation.
+                true,
+
+            LpExtend(_, _, LpDeref(mc::GcPtr))     |
+            LpExtend(_, _, LpDeref(mc::UnsafePtr(_))) =>
+                // An assignment through a GcPtr or UnsafePtr cannot
+                // affect the local drop obligation state.
+                false,
+
             LpExtend(ref base_lp, _cat, LpInterior(_)) =>
                 // 1. Ensure base_lp does not nullify the drop
                 //    obligation (e.g. if it is through a LpDeref,
diff --git a/src/librustc/middle/borrowck/move_data.rs b/src/librustc/middle/borrowck/move_data.rs
index 6c4838e..b58b071 100644
--- a/src/librustc/middle/borrowck/move_data.rs
+++ b/src/librustc/middle/borrowck/move_data.rs
@@ -316,14 +316,13 @@ impl MoveData {
     /// variant), or it is a struct whose fields are never accessed in
     /// the function being compiled.
     fn path_is_leaf(&self, index: MovePathIndex, _tcx: &ty::ctxt) -> bool {
-
         let first_child = self.path_first_child(index);
         if first_child == InvalidMovePathIndex {
             true
         } else {
             match *self.path_loan_path(first_child) {
                 LpDowncast(..) => true,
-                LpExtend(..) => false, // FIXME
+                LpExtend(..) => false,
                 LpVar(..) | LpUpvar(..) => false,
             }
         }
@@ -599,12 +598,6 @@ impl MoveData {
             // *LV for OwnedPtr consumes the contents of the box (at
             // least when it is non-copy...), so propagate inward.
             LpExtend(ref loan_parent, _, LpDeref(mc::OwnedPtr)) => {
-                let msg =
-                    format!("add_fragment_siblings encountered \
-                            LpExtend(.., OwnedPtr): {}; recursing down.",
-                            lp.repr(tcx));
-                tcx.sess.opt_span_warn(tcx.map.opt_span(origin_id),
-                                       msg.as_slice());
                 self.add_fragment_siblings(tcx, loan_parent.clone(), origin_id);
             }
 

commit b1748ac8e5af831b5cc52f657a54bba9daee554d
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Mon Aug 4 11:52:08 2014 +0200

    Track aliases introduced in match arms like `(a, 1) | (a, 2) => ...`.
    
    The goal: have a single NodeId that represents the set of multiple
    occurrences of an identifier like `a` in the arm above.
    
    To accomplish this, I:
    
      * Extended `middle::def::DefBinding` with `BindingAliasMode` to
        distinguish between the first occurrence of `a` (the
        representative) and the aliases that occur in the other disjuncts.
        Updated most clients to ignore the extra field.
    
      * Changed `middle::resolve` to track the representative for each
        binding's name and fill in the `BindingAliasMode` accordingly.
    
      * Changed `middle::mem_categorization` to use the representative of
        a binding when creating a `cmt` entry.
    
    That small extra step was I think all that I needed to get `foo30.rs`
    in the root testsuite working.
---
 src/librustc/lint/builtin.rs                 |  2 +-
 src/librustc/middle/astencode.rs             |  5 ++++-
 src/librustc/middle/def.rs                   |  9 +++++++--
 src/librustc/middle/liveness.rs              |  2 +-
 src/librustc/middle/mem_categorization.rs    |  3 ++-
 src/librustc/middle/resolve.rs               | 42 +++++++++++++++++++++++++++++++++---------
 src/librustc/middle/save/mod.rs              | 24 ++++++++++++------------
 src/librustc/middle/trans/expr.rs            |  2 +-
 src/librustc/middle/typeck/check/mod.rs      |  2 +-
 src/librustc/middle/typeck/check/regionck.rs |  2 +-
 10 files changed, 63 insertions(+), 30 deletions(-)

diff --git a/src/librustc/lint/builtin.rs b/src/librustc/lint/builtin.rs
index c3c4cf5..5e3ab0f 100644
--- a/src/librustc/lint/builtin.rs
+++ b/src/librustc/lint/builtin.rs
@@ -954,7 +954,7 @@ impl LintPass for NonSnakeCase {
         match &p.node {
             &ast::PatIdent(_, ref path1, _) => {
                 match cx.tcx.def_map.borrow().find(&p.id) {
-                    Some(&def::DefLocal(_, _)) | Some(&def::DefBinding(_, _)) |
+                    Some(&def::DefLocal(_, _)) | Some(&def::DefBinding(_, _, _)) |
                             Some(&def::DefArg(_, _)) => {
                         self.check_snake_case(cx, "variable", path1.node, p.span);
                     }
diff --git a/src/librustc/middle/astencode.rs b/src/librustc/middle/astencode.rs
index 0e64be3..fea4a12 100644
--- a/src/librustc/middle/astencode.rs
+++ b/src/librustc/middle/astencode.rs
@@ -476,7 +476,10 @@ impl tr for def::Def {
           def::DefTy(did) => def::DefTy(did.tr(xcx)),
           def::DefPrimTy(p) => def::DefPrimTy(p),
           def::DefTyParam(s, did, v) => def::DefTyParam(s, did.tr(xcx), v),
-          def::DefBinding(nid, bm) => def::DefBinding(xcx.tr_id(nid), bm),
+          def::DefBinding(nid, bm, def::Original) => def::DefBinding(xcx.tr_id(nid), bm, def::Original),
+          def::DefBinding(nid, bm, def::Aliasing(oid)) => {
+            def::DefBinding(xcx.tr_id(nid), bm, def::Aliasing(xcx.tr_id(oid)))
+          },
           def::DefUse(did) => def::DefUse(did.tr(xcx)),
           def::DefUpvar(nid1, def, nid2, nid3) => {
             def::DefUpvar(xcx.tr_id(nid1),
diff --git a/src/librustc/middle/def.rs b/src/librustc/middle/def.rs
index 914cf45..ab35f75 100644
--- a/src/librustc/middle/def.rs
+++ b/src/librustc/middle/def.rs
@@ -15,6 +15,11 @@ use syntax::ast_util::local_def;
 use std::gc::Gc;
 
 #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]
+pub enum BindingAliasMode {
+    Aliasing(ast::NodeId),
+    Original,
+}
+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]
 pub enum Def {
     DefFn(ast::DefId, ast::FnStyle),
     DefStaticMethod(/* method */ ast::DefId, MethodProvenance, ast::FnStyle),
@@ -29,7 +34,7 @@ pub enum Def {
     DefTrait(ast::DefId),
     DefPrimTy(ast::PrimTy),
     DefTyParam(ParamSpace, ast::DefId, uint),
-    DefBinding(ast::NodeId, ast::BindingMode),
+    DefBinding(ast::NodeId, ast::BindingMode, BindingAliasMode),
     DefUse(ast::DefId),
     DefUpvar(ast::NodeId,  // id of closed over var
              Gc<Def>,     // closed over def
@@ -70,7 +75,7 @@ impl Def {
             DefLocal(id, _) |
             DefSelfTy(id) |
             DefUpvar(id, _, _, _) |
-            DefBinding(id, _) |
+            DefBinding(id, _, _) |
             DefRegion(id) |
             DefTyParamBinder(id) |
             DefLabel(id) => {
diff --git a/src/librustc/middle/liveness.rs b/src/librustc/middle/liveness.rs
index 26aa51b..f03f0cb 100644
--- a/src/librustc/middle/liveness.rs
+++ b/src/librustc/middle/liveness.rs
@@ -440,7 +440,7 @@ fn visit_arm(ir: &mut IrMaps, arm: &Arm) {
 
 fn moved_variable_node_id_from_def(def: Def) -> Option<NodeId> {
     match def {
-        DefBinding(nid, _) |
+        DefBinding(nid, _, _) |
         DefArg(nid, _) |
         DefLocal(nid, _) => Some(nid),
 
diff --git a/src/librustc/middle/mem_categorization.rs b/src/librustc/middle/mem_categorization.rs
index 9c0d364..4b33e6a 100644
--- a/src/librustc/middle/mem_categorization.rs
+++ b/src/librustc/middle/mem_categorization.rs
@@ -627,7 +627,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {
           }
 
           def::DefLocal(vid, _) |
-          def::DefBinding(vid, _) => {
+          def::DefBinding(vid, _, def::Original) |
+          def::DefBinding(_, _, def::Aliasing(vid)) => {
             // by-value/by-ref bindings are local variables
             Ok(Rc::new(cmt_ {
                 id: id,
diff --git a/src/librustc/middle/resolve.rs b/src/librustc/middle/resolve.rs
index 0c8697d..f04bf2a 100644
--- a/src/librustc/middle/resolve.rs
+++ b/src/librustc/middle/resolve.rs
@@ -126,13 +126,24 @@ impl LastPrivate {
     }
 }
 
-#[deriving(PartialEq)]
-enum PatternBindingMode {
-    RefutableMode,
+enum PatternBindingMode<'a> {
+    /// Payload maps idents to node ID of first occurrence of ident in
+    /// the first pattern in a match disjunction `p_1 | p_2 | ...`
+    RefutableMode(&'a mut HashMap<Name,NodeId>),
     LocalIrrefutableMode,
     ArgumentIrrefutableMode,
 }
 
+impl<'a> PatternBindingMode<'a> {
+    fn is_refutable(&self) -> bool {
+        match *self {
+            RefutableMode(_) => true,
+            LocalIrrefutableMode => false,
+            ArgumentIrrefutableMode => false,
+        }
+    }
+}
+
 #[deriving(PartialEq, Eq, Hash)]
 enum Namespace {
     TypeNS,
@@ -4582,8 +4593,11 @@ impl<'a> Resolver<'a> {
         self.value_ribs.borrow_mut().push(Rib::new(NormalRibKind));
 
         let mut bindings_list = HashMap::new();
+        let mut normalized_list = HashMap::new();
         for pattern in arm.pats.iter() {
-            self.resolve_pattern(&**pattern, RefutableMode, &mut bindings_list);
+            self.resolve_pattern(&**pattern,
+                                 RefutableMode(&mut normalized_list),
+                                 &mut bindings_list);
         }
 
         // This has to happen *after* we determine which
@@ -4723,6 +4737,7 @@ impl<'a> Resolver<'a> {
                        // pattern that binds them
                        bindings_list: &mut HashMap<Name,NodeId>) {
         let pat_id = pattern.id;
+        let mut mode = mode;
         walk_pat(pattern, |pattern| {
             match pattern.node {
                 PatIdent(binding_mode, ref path1, _) => {
@@ -4741,7 +4756,7 @@ impl<'a> Resolver<'a> {
 
                     match self.resolve_bare_identifier_pattern(ident, pattern.span) {
                         FoundStructOrEnumVariant(def, lp)
-                                if mode == RefutableMode => {
+                                if mode.is_refutable() => {
                             debug!("(resolving pattern) resolving `{}` to \
                                     struct or enum variant",
                                    token::get_name(renamed));
@@ -4760,7 +4775,7 @@ impl<'a> Resolver<'a> {
                                          scope",
                                         token::get_name(renamed)).as_slice());
                         }
-                        FoundConst(def, lp) if mode == RefutableMode => {
+                        FoundConst(def, lp) if mode.is_refutable() => {
                             debug!("(resolving pattern) resolving `{}` to \
                                     constant",
                                    token::get_name(renamed));
@@ -4781,11 +4796,20 @@ impl<'a> Resolver<'a> {
                                    token::get_name(renamed));
 
                             let def = match mode {
-                                RefutableMode => {
+                                RefutableMode(ref mut normalization) => {
+                                    let opt_first_id = normalization.find(&renamed).map(|&x|x);
+                                    let aliasing_mode = match opt_first_id {
+                                        Some(first_id) => Aliasing(first_id),
+                                        None => {
+                                            // this is the first id; insert it.
+                                            normalization.insert(renamed, pattern.id);
+                                            Original
+                                        }
+                                    };
+
                                     // For pattern arms, we must use
                                     // `def_binding` definitions.
-
-                                    DefBinding(pattern.id, binding_mode)
+                                    DefBinding(pattern.id, binding_mode, aliasing_mode)
                                 }
                                 LocalIrrefutableMode => {
                                     // But for locals, we use `def_local`.
diff --git a/src/librustc/middle/save/mod.rs b/src/librustc/middle/save/mod.rs
index 7c7960e..82abd2c 100644
--- a/src/librustc/middle/save/mod.rs
+++ b/src/librustc/middle/save/mod.rs
@@ -220,7 +220,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {
             def::DefTy(_) |
             def::DefTrait(_) => Some(recorder::TypeRef),
             def::DefStatic(_, _) |
-            def::DefBinding(_, _) |
+            def::DefBinding(_, _, _) |
             def::DefArg(_, _) |
             def::DefLocal(_, _) |
             def::DefVariant(_, _, _) |
@@ -740,11 +740,11 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {
             def::DefLocal(id, _) |
             def::DefArg(id, _) |
             def::DefUpvar(id, _, _, _) |
-            def::DefBinding(id, _) => self.fmt.ref_str(recorder::VarRef,
-                                                       ex.span,
-                                                       sub_span,
-                                                       ast_util::local_def(id),
-                                                       e.cur_scope),
+            def::DefBinding(id, _, _) => self.fmt.ref_str(recorder::VarRef,
+                                                          ex.span,
+                                                          sub_span,
+                                                          ast_util::local_def(id),
+                                                          e.cur_scope),
             def::DefStatic(def_id,_) |
             def::DefVariant(_, def_id, _) => self.fmt.ref_str(recorder::VarRef,
                                                               ex.span,
@@ -1373,12 +1373,12 @@ impl<'l, 'tcx> Visitor<DxrVisitorEnv> for DxrVisitor<'l, 'tcx> {
             }
             let def = def_map.get(&id);
             match *def {
-                def::DefBinding(id, _)  => self.fmt.variable_str(p.span,
-                                                                 sub_span,
-                                                                 id,
-                                                                 path_to_string(p).as_slice(),
-                                                                 value.as_slice(),
-                                                                 ""),
+                def::DefBinding(id, _, _)  => self.fmt.variable_str(p.span,
+                                                                    sub_span,
+                                                                    id,
+                                                                    path_to_string(p).as_slice(),
+                                                                    value.as_slice(),
+                                                                    ""),
                 def::DefVariant(_,id,_) => self.fmt.ref_str(ref_kind,
                                                             p.span,
                                                             sub_span,
diff --git a/src/librustc/middle/trans/expr.rs b/src/librustc/middle/trans/expr.rs
index f16c6c9..9ca3935 100644
--- a/src/librustc/middle/trans/expr.rs
+++ b/src/librustc/middle/trans/expr.rs
@@ -1195,7 +1195,7 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,
         def::DefArg(nid, _) => {
             take_local(bcx, &*bcx.fcx.llargs.borrow(), nid)
         }
-        def::DefLocal(nid, _) | def::DefBinding(nid, _) => {
+        def::DefLocal(nid, _) | def::DefBinding(nid, _, _) => {
             take_local(bcx, &*bcx.fcx.lllocals.borrow(), nid)
         }
         _ => {
diff --git a/src/librustc/middle/typeck/check/mod.rs b/src/librustc/middle/typeck/check/mod.rs
index 98127cb..58a972a 100644
--- a/src/librustc/middle/typeck/check/mod.rs
+++ b/src/librustc/middle/typeck/check/mod.rs
@@ -4717,7 +4717,7 @@ pub fn polytype_for_def(fcx: &FnCtxt,
                         -> Polytype {
     match defn {
       def::DefArg(nid, _) | def::DefLocal(nid, _) |
-      def::DefBinding(nid, _) => {
+      def::DefBinding(nid, _, _) => {
           let typ = fcx.local_ty(sp, nid);
           return no_params(typ);
       }
diff --git a/src/librustc/middle/typeck/check/regionck.rs b/src/librustc/middle/typeck/check/regionck.rs
index d3449c7..0adaa43 100644
--- a/src/librustc/middle/typeck/check/regionck.rs
+++ b/src/librustc/middle/typeck/check/regionck.rs
@@ -234,7 +234,7 @@ fn region_of_def(fcx: &FnCtxt, def: def::Def) -> ty::Region {
     let tcx = fcx.tcx();
     match def {
         DefLocal(node_id, _) | DefArg(node_id, _) |
-        DefBinding(node_id, _) => {
+        DefBinding(node_id, _, _) => {
             tcx.region_maps.var_region(node_id)
         }
         DefUpvar(_, subdef, closure_id, body_id) => {

commit ec18de0dca65b16acf23a38e567af99908961d86
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Fri Aug 1 19:40:53 2014 +0200

    rust-needsdrop: placeholder code for improving handling of Box.
    
    Note that foo28.rs is still broken; changes in this area are expected
    to fix it.
---
 src/librustc/middle/borrowck/move_data.rs | 13 +++++++------
 1 file changed, 7 insertions(+), 6 deletions(-)

diff --git a/src/librustc/middle/borrowck/move_data.rs b/src/librustc/middle/borrowck/move_data.rs
index 2fdce65..6c4838e 100644
--- a/src/librustc/middle/borrowck/move_data.rs
+++ b/src/librustc/middle/borrowck/move_data.rs
@@ -323,7 +323,8 @@ impl MoveData {
         } else {
             match *self.path_loan_path(first_child) {
                 LpDowncast(..) => true,
-                LpVar(..) | LpUpvar(..) | LpExtend(..) => false,
+                LpExtend(..) => false, // FIXME
+                LpVar(..) | LpUpvar(..) => false,
             }
         }
     }
@@ -595,16 +596,16 @@ impl MoveData {
 
             LpDowncast(..) => {} // an enum variant (on its own) has no siblings.
 
-            // *LV for OwnedPtr itself has no siblings, but we might need
-            // to propagate inward.  Not sure.
-            LpExtend(_, _, LpDeref(mc::OwnedPtr)) => {
+            // *LV for OwnedPtr consumes the contents of the box (at
+            // least when it is non-copy...), so propagate inward.
+            LpExtend(ref loan_parent, _, LpDeref(mc::OwnedPtr)) => {
                 let msg =
                     format!("add_fragment_siblings encountered \
-                             LpExtend(.., OwnedPtr): {}; \
-                             Assuming it has no siblings (for now).",
+                            LpExtend(.., OwnedPtr): {}; recursing down.",
                             lp.repr(tcx));
                 tcx.sess.opt_span_warn(tcx.map.opt_span(origin_id),
                                        msg.as_slice());
+                self.add_fragment_siblings(tcx, loan_parent.clone(), origin_id);
             }
 
             // *LV has no siblings

commit 5f085422714935e6017d15eed230a7f68353510d
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Fri Aug 1 19:39:29 2014 +0200

    rust-needsdrop: quick hack, print out a count of how many distinct warnings we have emitted.
---
 src/librustc/middle/borrowck/check_drops.rs | 10 ++++++++--
 1 file changed, 8 insertions(+), 2 deletions(-)

diff --git a/src/librustc/middle/borrowck/check_drops.rs b/src/librustc/middle/borrowck/check_drops.rs
index eb9412c..1d7fc2a 100644
--- a/src/librustc/middle/borrowck/check_drops.rs
+++ b/src/librustc/middle/borrowck/check_drops.rs
@@ -22,8 +22,11 @@ use middle::ty;
 use middle::ty::TypeContents;
 use std::rc::Rc;
 use std::collections::hashmap::HashMap;
+use std::sync::atomics;
 use syntax::{ast,ast_map};
 
+static mut warning_count: atomics::AtomicUint = atomics::INIT_ATOMIC_UINT;
+
 pub fn check_drops(bccx: &BorrowckCtxt,
                    flowed_move_data: &move_data::FlowedMoveData,
                    cfg: &cfg::CFG,
@@ -167,6 +170,9 @@ pub fn check_drops(bccx: &BorrowckCtxt,
                     }
 
                     // At this point, we are committed to reporting a warning to the user
+                    let count = unsafe {
+                        warning_count.fetch_add(1, atomics::Relaxed) + 1
+                    };
 
                     let loan_path_str = bccx.loan_path_to_string(lp.deref());
 
@@ -180,8 +186,8 @@ pub fn check_drops(bccx: &BorrowckCtxt,
                     let msg = format!("Storage at `{:s}` is left initialized here{:s}, \
                                        but uninitialized on other control flow paths. \
                                        (Consider either calling `drop()` on it here, \
-                                       or reinitializing it on the other paths)",
-                                      loan_path_str, where);
+                                       or reinitializing it on the other paths); count: {}",
+                                      loan_path_str, where, count);
 
                     match opt_source_span {
                         Some(span) => bccx.tcx.sess.span_warn(span, msg.as_slice()),

commit 5e244e56af75a7ac5348efcbf5cca655df1c610b
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Fri Aug 1 14:31:10 2014 +0200

    rust-needsdrop: for Gc<T>: TC pred is `moves_by_default`, not `needs_drop`.
---
 src/librustc/middle/borrowck/mod.rs | 22 +++++++++++++++++++---
 1 file changed, 19 insertions(+), 3 deletions(-)

diff --git a/src/librustc/middle/borrowck/mod.rs b/src/librustc/middle/borrowck/mod.rs
index 550257f..b73ba9a 100644
--- a/src/librustc/middle/borrowck/mod.rs
+++ b/src/librustc/middle/borrowck/mod.rs
@@ -397,7 +397,7 @@ impl LoanPath {
                 // *moment* they are easy; we may put in
                 // flow-sensitivity in some form.  Or maybe not, we
                 // will see.)
-                ty::type_needs_drop(tcx, self.to_type(tcx)),
+                self.to_type(tcx).needs_drop_call(tcx),
 
             LpExtend(_, _, LpDeref(_)) =>
                 // A path through a `&` or `&mut` reference cannot
@@ -419,7 +419,7 @@ impl LoanPath {
                 //    itself introduce a drop obligation, but the type
                 //    of `q` means that that particular field does not
                 //    affect dropping.
-                ty::type_needs_drop(tcx, self.to_type(tcx)),
+                self.to_type(tcx).needs_drop_call(tcx),
 
             LpDowncast(ref lp, def_id) => self.enum_variant_needs_drop(tcx, lp, def_id),
         }
@@ -447,13 +447,29 @@ impl LoanPath {
                                self.repr(tcx), arg_ty.repr(tcx), arg_ty_subst.repr(tcx));
                         ty::type_contents(tcx, arg_ty_subst)
                     });
-                type_contents.needs_drop(tcx)
+
+                type_contents.needs_drop_call(tcx)
             }
             _ => fail!("encountered LpDowncast on non-enum base type."),
         }
     }
 }
 
+trait NeedsDropCallArg {
+    fn needs_drop_call(&self, tcx: &ty::ctxt) -> bool;
+}
+impl NeedsDropCallArg for ty::TypeContents {
+    fn needs_drop_call(&self, tcx: &ty::ctxt) -> bool {
+        // self.needs_drop(tcx)
+        self.moves_by_default(tcx)
+    }
+}
+impl NeedsDropCallArg for ty::t {
+    fn needs_drop_call(&self, tcx: &ty::ctxt) -> bool {
+        ty::type_contents(tcx, *self).needs_drop_call(tcx)
+    }
+}
+
 #[deriving(PartialEq, Eq, Hash)]
 pub enum LoanPathElem {
     LpDeref(mc::PointerKind),    // `*LV` in doc.rs

commit 0788393a5888fbf7ef74b32102e4934f587d5f9f
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Fri Aug 1 11:47:52 2014 +0200

    rust-needsdrop: generalize scope-end fwd-scan for return statements.
    
    Also generally improve the code structure and instrumentation a bit.
---
 src/librustc/middle/borrowck/check_drops.rs | 27 ++++++++++++++++++++-------
 1 file changed, 20 insertions(+), 7 deletions(-)

diff --git a/src/librustc/middle/borrowck/check_drops.rs b/src/librustc/middle/borrowck/check_drops.rs
index 1285257..eb9412c 100644
--- a/src/librustc/middle/borrowck/check_drops.rs
+++ b/src/librustc/middle/borrowck/check_drops.rs
@@ -233,7 +233,7 @@ fn scan_forward_for_kill_id(bccx: &BorrowckCtxt,
                            start: cfg::CFGIndex,
                            kill_id: ast::NodeId) -> bool {
     //! returns true only if there is a unique effect-free successor
-    //! chain from `start` to `kill_id`
+    //! chain from `start` to `kill_id` or to `cfg.exit`
 
     let mut cursor = start;
     loop {
@@ -253,21 +253,27 @@ fn scan_forward_for_kill_id(bccx: &BorrowckCtxt,
         }
 
         cursor = cfg.graph.edge(successor.unwrap()).target();
+        if cursor == cfg.exit {
+            debug!("fwd-scan: success (hit exit), no need for warning");
+            return true;
+        }
+
         let successor_id = cfg.graph.node(cursor).data.id;
         if successor_id == ast::DUMMY_NODE_ID {
             debug!("fwd-scan: dummy node in flow graph; give up");
             return false;
         }
 
-        debug!("fwd-scan: successor_id={}", successor_id);
         if successor_id == kill_id {
-            debug!("fwd-scan: success, no need for warning");
+            debug!("fwd-scan: success (hit {}), no need for warning", kill_id);
             return true;
         }
 
         match bccx.tcx.map.get(successor_id) {
             ast_map::NodeBlock(_) | ast_map::NodeArm(_) => {
-                debug!("fwd-scan: node effect-free; continue looking");
+                debug!("fwd-scan: node {} effect-free; continue looking",
+                       successor_id);
+                continue;
             }
 
             ast_map::NodeExpr(e) => {
@@ -279,12 +285,18 @@ fn scan_forward_for_kill_id(bccx: &BorrowckCtxt,
                     ast::ExprMatch(..) |
                     ast::ExprBlock(..) |
                     ast::ExprParen(..) |
+                    ast::ExprRet(..)   |
                     ast::ExprIf(..) => {
-                        debug!("fwd-scan: expr effect-free; continue looking");
+                        debug!("fwd-scan: expr {} effect-free; \
+                                continue looking",
+                               successor_id);
+                        continue;
                     }
 
                     _ => {
-                        debug!("fwd-scan: expr potentially effectful; give up");
+                        debug!("fwd-scan: expr {} potentially effectful; \
+                                give up",
+                               successor_id);
                         return false;
                     }
 
@@ -294,7 +306,8 @@ fn scan_forward_for_kill_id(bccx: &BorrowckCtxt,
             ast_map::NodeStmt(_)       | ast_map::NodeArg(_) |
             ast_map::NodeLocal(_)      | ast_map::NodePat(_) |
             ast_map::NodeStructCtor(_) => {
-                debug!("fwd-scan: node potentially effectful; give up");
+                debug!("fwd-scan: node {} potentially effectful; give up",
+                       successor_id);
                 return false;
             }
 

commit 0e683c13fd03e28d9d9d692b27cbb6478008937f
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Fri Aug 1 10:00:56 2014 +0200

    rust-needsdrop: checkpoint scope-end fwd-scan semi-hack.
---
 src/librustc/middle/borrowck/check_drops.rs | 95 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 src/librustc/middle/borrowck/mod.rs         | 12 ++++++++++++
 src/librustc/middle/borrowck/move_data.rs   | 19 +++----------------
 3 files changed, 110 insertions(+), 16 deletions(-)

diff --git a/src/librustc/middle/borrowck/check_drops.rs b/src/librustc/middle/borrowck/check_drops.rs
index 2bb810f..1285257 100644
--- a/src/librustc/middle/borrowck/check_drops.rs
+++ b/src/librustc/middle/borrowck/check_drops.rs
@@ -138,6 +138,9 @@ pub fn check_drops(bccx: &BorrowckCtxt,
             let mut temp = needs_drop.bitset_for(dataflow::Exit, source);
 
             // see note above about "equivalence modulo merge-kills"
+            //
+            // But also, this hack can probably go away with new
+            // "scan-ahead-for-scope-end" rule
             needs_drop.apply_gen_kill(node_index, temp.as_mut_slice());
 
             if temp != intersection {
@@ -152,6 +155,19 @@ pub fn check_drops(bccx: &BorrowckCtxt,
                     let paths = move_data.paths.borrow();
                     let path = paths.get(bit_idx);
                     let lp = &path.loan_path;
+
+                    // Check if there is a single effect-free
+                    // successor chain that leads to the end of the
+                    // scope of the local variable at the base of `lp`
+                    // (and therefore we can safely auto-drop `lp`
+                    // without warning the user)
+                    let kill_id = lp.kill_id(bccx.tcx);
+                    if scan_forward_for_kill_id(bccx, cfg, node_index, kill_id) {
+                        return true;
+                    }
+
+                    // At this point, we are committed to reporting a warning to the user
+
                     let loan_path_str = bccx.loan_path_to_string(lp.deref());
 
                     let cfgidx_and_id = format!(" (cfgidx={}, id={})", source, source_id);
@@ -211,3 +227,82 @@ pub fn check_drops(bccx: &BorrowckCtxt,
         true
     });
 }
+
+fn scan_forward_for_kill_id(bccx: &BorrowckCtxt,
+                           cfg: &cfg::CFG,
+                           start: cfg::CFGIndex,
+                           kill_id: ast::NodeId) -> bool {
+    //! returns true only if there is a unique effect-free successor
+    //! chain from `start` to `kill_id`
+
+    let mut cursor = start;
+    loop {
+        debug!("fwd-scan for kill_id={} cursor={}", kill_id, cursor);
+        let mut count = 0u;
+        let mut successor = None;
+        cfg.graph.each_outgoing_edge(cursor, |edge_index, edge| {
+            debug!("fwd-scan cursor={} edge.target={}", cursor, edge.target());
+            successor = Some(edge_index);
+            count += 1;
+            count <= 1
+        });
+
+        if count != 1 {
+            debug!("fwd-scan: broken successor chain; give up");
+            return false;
+        }
+
+        cursor = cfg.graph.edge(successor.unwrap()).target();
+        let successor_id = cfg.graph.node(cursor).data.id;
+        if successor_id == ast::DUMMY_NODE_ID {
+            debug!("fwd-scan: dummy node in flow graph; give up");
+            return false;
+        }
+
+        debug!("fwd-scan: successor_id={}", successor_id);
+        if successor_id == kill_id {
+            debug!("fwd-scan: success, no need for warning");
+            return true;
+        }
+
+        match bccx.tcx.map.get(successor_id) {
+            ast_map::NodeBlock(_) | ast_map::NodeArm(_) => {
+                debug!("fwd-scan: node effect-free; continue looking");
+            }
+
+            ast_map::NodeExpr(e) => {
+                // Keep in mind when reading these cases that the
+                // NodeId associated with an expression node like
+                // ExprIf is at the *end* of the expression, where the
+                // two arms of the if join.
+                match e.node {
+                    ast::ExprMatch(..) |
+                    ast::ExprBlock(..) |
+                    ast::ExprParen(..) |
+                    ast::ExprIf(..) => {
+                        debug!("fwd-scan: expr effect-free; continue looking");
+                    }
+
+                    _ => {
+                        debug!("fwd-scan: expr potentially effectful; give up");
+                        return false;
+                    }
+
+                }
+            }
+
+            ast_map::NodeStmt(_)       | ast_map::NodeArg(_) |
+            ast_map::NodeLocal(_)      | ast_map::NodePat(_) |
+            ast_map::NodeStructCtor(_) => {
+                debug!("fwd-scan: node potentially effectful; give up");
+                return false;
+            }
+
+            ast_map::NodeItem(_)        | ast_map::NodeForeignItem(_) |
+            ast_map::NodeTraitMethod(_) | ast_map::NodeMethod(_)      |
+            ast_map::NodeVariant(_)     | ast_map::NodeLifetime(_) => {
+                bccx.tcx.sess.bug("unexpected node")
+            }
+        }
+    }
+}
diff --git a/src/librustc/middle/borrowck/mod.rs b/src/librustc/middle/borrowck/mod.rs
index 3bf68a8..550257f 100644
--- a/src/librustc/middle/borrowck/mod.rs
+++ b/src/librustc/middle/borrowck/mod.rs
@@ -290,6 +290,18 @@ pub enum LoanPath {
 }
 
 impl LoanPath {
+    fn kill_id(&self, tcx: &ty::ctxt) -> ast::NodeId {
+        //! Returns the lifetime of the local variable that forms the base of this path.
+        match *self {
+            LpVar(id) =>
+                tcx.region_maps.var_scope(id),
+            LpUpvar(ty::UpvarId { var_id: _, closure_expr_id }, _) => 
+                closure_to_block(closure_expr_id, tcx),
+            LpDowncast(ref base_lp, _) | LpExtend(ref base_lp, _, _) =>
+                base_lp.kill_id(tcx),
+        }
+    }
+
     fn to_type(&self, tcx: &ty::ctxt) -> ty::t {
         use Element = middle::mem_categorization::InteriorElement;
         use Field = middle::mem_categorization::InteriorField;
diff --git a/src/librustc/middle/borrowck/move_data.rs b/src/librustc/middle/borrowck/move_data.rs
index 50580eb..2fdce65 100644
--- a/src/librustc/middle/borrowck/move_data.rs
+++ b/src/librustc/middle/borrowck/move_data.rs
@@ -869,22 +869,9 @@ impl MoveData {
         }
 
         // Kill all assignments when the variable goes out of scope:
-        for (assignment_index, assignment) in
-                self.var_assignments.borrow().iter().enumerate() {
-            match *self.path_loan_path(assignment.path) {
-                LpVar(id) => {
-                    let kill_id = tcx.region_maps.var_scope(id);
-                    dfcx_assign.add_kill(kill_id, assignment_index);
-                }
-                LpUpvar(ty::UpvarId { var_id: _, closure_expr_id }, _) => {
-                    let kill_id = closure_to_block(closure_expr_id, tcx);
-                    dfcx_assign.add_kill(kill_id, assignment_index);
-                }
-                LpDowncast(..) |
-                LpExtend(..) => {
-                    tcx.sess.bug("var assignment for non var path");
-                }
-            }
+        for (assignment_index, assignment) in self.var_assignments.borrow().iter().enumerate() {
+            let kill_id = self.path_loan_path(assignment.path).kill_id(tcx);
+            dfcx_assign.add_kill(kill_id, assignment_index);
         }
     }
 

commit e52424206778af1d57e85067bb4db7318c758fbe
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Fri Aug 1 07:18:05 2014 +0200

    rust-needsdrop: simplify check_drops now dataflow itself computes intersection.
---
 src/librustc/middle/borrowck/check_drops.rs | 25 ++++++++-----------------
 1 file changed, 8 insertions(+), 17 deletions(-)

diff --git a/src/librustc/middle/borrowck/check_drops.rs b/src/librustc/middle/borrowck/check_drops.rs
index dab8ad4..2bb810f 100644
--- a/src/librustc/middle/borrowck/check_drops.rs
+++ b/src/librustc/middle/borrowck/check_drops.rs
@@ -83,23 +83,7 @@ pub fn check_drops(bccx: &BorrowckCtxt,
         let needs_drop = &flowed_move_data.dfcx_needs_drop;
         let path_count = move_data.paths.borrow().len();
 
-        let intersection = {
-            // (it doesn't matter which index we grab this from, we going
-            // to fill it with ones anyway.)
-            let mut temp = needs_drop.bitset_for(dataflow::Entry, node_index);
-            for u in temp.mut_iter() { *u = -1 as uint; }
-            cfg.graph.each_incoming_edge(node_index, |_edge_index, edge| {
-                let source = edge.source();
-                if cfg.is_reachable(source) {
-                    needs_drop.apply_op(dataflow::Exit,
-                                        source,
-                                        temp.as_mut_slice(),
-                                        dataflow::Intersect);
-                }
-                true
-            });
-            temp
-        };
+        let intersection = needs_drop.bitset_for(dataflow::Entry, node_index);
 
         // In theory, that should be all we need to do; i.e. at this
         // point we should be able to compare each incoming node's
@@ -137,6 +121,13 @@ pub fn check_drops(bccx: &BorrowckCtxt,
         // This should take care of match patterns that will be
         // automatically destroyed, while leaving paths with a broader
         // scope than the match preserved.
+        //
+        // UPDATE: There is actually a more general principle we can
+        // apply here, without worrying about match-arms: simply
+        // walking forward looking if the end-of-scope for the
+        // variable comes before any other side-effect.  If so, then
+        // we can safely auto-drop without warning the user, since the
+        // net effect is the same as if we still had a drop-flag.
 
         let mut intersection = intersection;
         needs_drop.apply_gen_kill(node_index, intersection.as_mut_slice());

commit e3d681f3689dccd7122641eb7aebb3c81e9a7edf
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Fri Aug 1 00:00:58 2014 +0200

    TrackMatchMode: arms are now treated as separate-but-equal (in end effect, that is).
    
    This is to handle a case like:
    
        match s {
            Err(_) => s,
            Ok(content) => x(content),
        }
    
    which moves on the `Ok` arm pattern but not on the `Err` arm pattern,
    and this is okay because it ends up moving the `s` on both *paths*
    (eventually).
---
 src/librustc/middle/expr_use_visitor.rs | 4 +---
 1 file changed, 1 insertion(+), 3 deletions(-)

diff --git a/src/librustc/middle/expr_use_visitor.rs b/src/librustc/middle/expr_use_visitor.rs
index e352753..6f14a01 100644
--- a/src/librustc/middle/expr_use_visitor.rs
+++ b/src/librustc/middle/expr_use_visitor.rs
@@ -422,11 +422,9 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {
                 // walking the arms:
                 self.walk_expr(&**discr);
                 let discr_cmt = return_if_err!(self.mc.cat_expr(&**discr));
-                let mut mode = Unknown;
                 for arm in arms.iter() {
+                    let mut mode = Unknown;
                     self.walk_arm_prepass(discr_cmt.clone(), &**arm, &mut mode);
-                }
-                for arm in arms.iter() {
                     self.walk_arm(discr_cmt.clone(), &**arm, &mode);
                 }
             }

commit 347b5ee7af5a37ccc372cf88d35e62369e276dfb
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Thu Jul 31 18:46:11 2014 +0200

    Add support for moving into wildcards when truly necessary.
    
    The tricky thing here is properly defining "truly necessary."
    For example, given:
    
    `fn foo<X>(t: &(i8, X)) -> i* { let &(a, _) = t; ... }`
    
    since the left-hand side is merely copied out of `t`, presumably the
    `_` should not be treated as a move of the `X` on the right-hand side
    of the tuple, so that this would be legal:
    
    `fn foo<X>(t: &(i8, X)) -> i* { let &(a, _) = t; let &(b, _) = t; a + b }`
    
    while in this case:
    
    `fn foo<X>(t: &(X, X)) -> i* { let &(a, _) = t; ... }`
    
    since the left-hand side is now established via a move, it seems most
    sensible to just say that all of `t` is moved, and thus the pattern
    `_` will be a move of `t` into `_`.
    
    Then again, this might conflict with some of Niko's ideas about what
    the rules should be; I need to review some of his earlier notes and
    our dialogues to check about this.
---
 src/librustc/middle/borrowck/gather_loans/gather_moves.rs |  3 +++
 src/librustc/middle/expr_use_visitor.rs                   | 39 ++++++++++++++++++++++++++-------------
 2 files changed, 29 insertions(+), 13 deletions(-)

diff --git a/src/librustc/middle/borrowck/gather_loans/gather_moves.rs b/src/librustc/middle/borrowck/gather_loans/gather_moves.rs
index 72c69e4..69fecf6 100644
--- a/src/librustc/middle/borrowck/gather_loans/gather_moves.rs
+++ b/src/librustc/middle/borrowck/gather_loans/gather_moves.rs
@@ -98,6 +98,9 @@ pub fn gather_move_from_pat(bccx: &BorrowckCtxt,
             Some(MoveTargetIdent(MoveSpanAndIdent{span: move_pat.span,
                                                   ident: path1.node}))
         },
+        ast::PatWild(k) => {
+            Some(MoveTargetWildcard(move_pat.span, move_pat.id, k))
+        },
         _ => None,
     };
     let move_info = GatherMoveInfo {
diff --git a/src/librustc/middle/expr_use_visitor.rs b/src/librustc/middle/expr_use_visitor.rs
index 1e450c7..e352753 100644
--- a/src/librustc/middle/expr_use_visitor.rs
+++ b/src/librustc/middle/expr_use_visitor.rs
@@ -931,29 +931,32 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {
         let delegate = &mut self.delegate;
 
         return_if_err!(mc.cat_pattern(cmt_discr.clone(), &*pat, |mc, cmt_pat, pat| {
-            if pat_util::pat_is_binding(def_map, pat) {
+            if pat_util::pat_is_binding_or_wild(def_map, pat) {
                 let tcx = typer.tcx();
 
-                debug!("binding cmt_pat={} pat={}",
+                debug!("binding cmt_pat={} pat={} match_mode={}",
                        cmt_pat.repr(tcx),
-                       pat.repr(tcx));
+                       pat.repr(tcx),
+                       match_mode);
 
                 // pat_ty: the type of the binding being produced.
                 let pat_ty = return_if_err!(typer.node_ty(pat.id));
 
-                // Each match binding is effectively an assignment to the
-                // binding being produced.
-                let def = def_map.borrow().get_copy(&pat.id);
-                match mc.cat_def(pat.id, pat.span, pat_ty, def) {
-                    Ok(binding_cmt) => {
-                        delegate.mutate(pat.id, pat.span, binding_cmt, Init);
+                if pat_util::pat_is_binding(def_map, pat) {
+                    // Each match binding is effectively an assignment to the
+                    // binding being produced.
+                    let def = def_map.borrow().get_copy(&pat.id);
+                    match mc.cat_def(pat.id, pat.span, pat_ty, def) {
+                        Ok(binding_cmt) => {
+                            delegate.mutate(pat.id, pat.span, binding_cmt, Init);
+                        }
+                        Err(_) => { }
                     }
-                    Err(_) => { }
                 }
 
                 // It is also a borrow or copy/move of the value being matched.
-                match pat.node {
-                    ast::PatIdent(ast::BindByRef(m), _, _) => {
+                match (&pat.node, match_mode) {
+                    (&ast::PatIdent(ast::BindByRef(m), _, _), _) => {
                         let (r, bk) = {
                             (ty::ty_region(tcx, pat.span, pat_ty),
                              ty::BorrowKind::from_mutbl(m))
@@ -961,11 +964,21 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {
                         delegate.borrow(pat.id, pat.span, cmt_pat,
                                              r, bk, RefBinding);
                     }
-                    ast::PatIdent(ast::BindByValue(_), _, _) => {
+
+                    (&ast::PatIdent(ast::BindByValue(_), _, _), _) |
+                    (&ast::PatWild(_), ConsumingMatch(Move(_))) => {
+                        // FIXME: I may need to distinguish these two
+                        // cases, since the PatWild case will probably
+                        // imply auto-drop without warning at the end
+                        // of the scope (FSK).
                         let mode = copy_or_move(typer.tcx(), cmt_pat.ty, PatBindingMove);
                         debug!("walk_pat binding consuming pat");
                         delegate.consume_pat(pat, cmt_pat, mode);
                     }
+
+                    (&ast::PatWild(_), ConsumingMatch(Copy)) |
+                    (&ast::PatWild(_), BorrowingMatch) => {}
+
                     _ => {
                         typer.tcx().sess.span_bug(
                             pat.span,

commit 16c9a709fae2ffec523ebc0975b8539b1e1bee49
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Thu Jul 31 16:35:37 2014 +0200

    rust-needsdrop: Generalize gather_moves to be able to represent moves into wildcard patterns.
---
 src/librustc/middle/borrowck/gather_loans/gather_moves.rs |  9 +++++----
 src/librustc/middle/borrowck/gather_loans/move_error.rs   | 42 +++++++++++++++++++++++++++++++++---------
 2 files changed, 38 insertions(+), 13 deletions(-)

diff --git a/src/librustc/middle/borrowck/gather_loans/gather_moves.rs b/src/librustc/middle/borrowck/gather_loans/gather_moves.rs
index 5bcf0a2..72c69e4 100644
--- a/src/librustc/middle/borrowck/gather_loans/gather_moves.rs
+++ b/src/librustc/middle/borrowck/gather_loans/gather_moves.rs
@@ -13,8 +13,9 @@
  */
 
 use middle::borrowck::*;
-use middle::borrowck::gather_loans::move_error::MoveSpanAndPath;
 use middle::borrowck::gather_loans::move_error::{MoveError, MoveErrorCollector};
+use middle::borrowck::gather_loans::move_error::{MoveSpanAndIdent, MoveTarget};
+use middle::borrowck::gather_loans::move_error::{MoveTargetIdent, MoveTargetWildcard};
 use middle::borrowck::move_data::*;
 use middle::expr_use_visitor as euv;
 use middle::mem_categorization as mc;
@@ -29,7 +30,7 @@ struct GatherMoveInfo {
     id: ast::NodeId,
     kind: MoveKind,
     cmt: mc::cmt,
-    span_path_opt: Option<MoveSpanAndPath>
+    span_path_opt: Option<MoveTarget>
 }
 
 pub fn gather_decl(bccx: &BorrowckCtxt,
@@ -94,8 +95,8 @@ pub fn gather_move_from_pat(bccx: &BorrowckCtxt,
                             cmt: mc::cmt) {
     let pat_span_path_opt = match move_pat.node {
         ast::PatIdent(_, ref path1, _) => {
-            Some(MoveSpanAndPath{span: move_pat.span,
-                                 ident: path1.node})
+            Some(MoveTargetIdent(MoveSpanAndIdent{span: move_pat.span,
+                                                  ident: path1.node}))
         },
         _ => None,
     };
diff --git a/src/librustc/middle/borrowck/gather_loans/move_error.rs b/src/librustc/middle/borrowck/gather_loans/move_error.rs
index c4b9b33..ae59e72 100644
--- a/src/librustc/middle/borrowck/gather_loans/move_error.rs
+++ b/src/librustc/middle/borrowck/gather_loans/move_error.rs
@@ -40,12 +40,12 @@ impl MoveErrorCollector {
 
 pub struct MoveError {
     move_from: mc::cmt,
-    move_to: Option<MoveSpanAndPath>
+    move_to: Option<MoveTarget>
 }
 
 impl MoveError {
     pub fn with_move_info(move_from: mc::cmt,
-                          move_to: Option<MoveSpanAndPath>)
+                          move_to: Option<MoveTarget>)
                           -> MoveError {
         MoveError {
             move_from: move_from,
@@ -55,14 +55,39 @@ impl MoveError {
 }
 
 #[deriving(Clone)]
-pub struct MoveSpanAndPath {
+pub enum MoveTarget {
+    MoveTargetIdent(MoveSpanAndIdent),
+    MoveTargetWildcard(codemap::Span, ast::NodeId, ast::PatWildKind),
+}
+
+impl MoveTarget {
+    fn span(&self) -> codemap::Span {
+        match *self {
+            MoveTargetIdent(span_and_ident) => span_and_ident.span,
+            MoveTargetWildcard(span, _, _) => span,
+        }
+    }
+    fn name(&self) -> String {
+        match *self {
+            MoveTargetIdent(span_and_ident) =>
+                pprust::ident_to_string(&span_and_ident.ident),
+            MoveTargetWildcard(_, _, ast::PatWildSingle) =>
+                "_".to_string(),
+            MoveTargetWildcard(_, _, ast::PatWildMulti) =>
+                "..".to_string(),
+        }
+    }
+}
+
+#[deriving(Clone)]
+pub struct MoveSpanAndIdent {
     pub span: codemap::Span,
     pub ident: ast::Ident
 }
 
 pub struct GroupedMoveErrors {
     move_from: mc::cmt,
-    move_to_places: Vec<MoveSpanAndPath>
+    move_to_places: Vec<MoveTarget>
 }
 
 fn report_move_errors(bccx: &BorrowckCtxt, errors: &Vec<MoveError>) {
@@ -71,8 +96,7 @@ fn report_move_errors(bccx: &BorrowckCtxt, errors: &Vec<MoveError>) {
         report_cannot_move_out_of(bccx, error.move_from.clone());
         let mut is_first_note = true;
         for move_to in error.move_to_places.iter() {
-            note_move_destination(bccx, move_to.span,
-                                  &move_to.ident, is_first_note);
+            note_move_destination(bccx, move_to, is_first_note);
             is_first_note = false;
         }
     }
@@ -143,10 +167,10 @@ fn report_cannot_move_out_of(bccx: &BorrowckCtxt, move_from: mc::cmt) {
 }
 
 fn note_move_destination(bccx: &BorrowckCtxt,
-                         move_to_span: codemap::Span,
-                         pat_ident: &ast::Ident,
+                         move_to: &MoveTarget,
                          is_first_note: bool) {
-    let pat_name = pprust::ident_to_string(pat_ident);
+    let move_to_span = move_to.span();
+    let pat_name = move_to.name();
     if is_first_note {
         bccx.span_note(
             move_to_span,

commit 78b424037c1f8efdab92962bcc0240a34d05fb4e
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Thu Jul 31 16:29:56 2014 +0200

    Add id to ast::Arm: fix omission in libregex_macros for bootstrapping.
---
 src/libregex_macros/lib.rs | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/libregex_macros/lib.rs b/src/libregex_macros/lib.rs
index 8aa9a2f..05bba09 100644
--- a/src/libregex_macros/lib.rs
+++ b/src/libregex_macros/lib.rs
@@ -590,6 +590,7 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,
     // Creates a wild-card match arm with the expression `body`.
     fn wild_arm_expr(&self, body: Gc<ast::Expr>) -> ast::Arm {
         ast::Arm {
+            id: ast::DUMMY_NODE_ID,
             attrs: vec!(),
             pats: vec!(box(GC) ast::Pat{
                 id: ast::DUMMY_NODE_ID,

commit 9b79f040ec6e7c8bde7efc415ce5b1f08b5ce870
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Thu Jul 31 14:41:13 2014 +0200

    rust-needsdrop: Use intersection, not union, for merge at join points.
    
    The motivation is explained in an extensive comment in
    `impl BitwiseOperator for NeedsDropDataFlowOperator`.
---
 src/librustc/middle/borrowck/move_data.rs | 135 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-------------------
 1 file changed, 113 insertions(+), 22 deletions(-)

diff --git a/src/librustc/middle/borrowck/move_data.rs b/src/librustc/middle/borrowck/move_data.rs
index 2f4753c..50580eb 100644
--- a/src/librustc/middle/borrowck/move_data.rs
+++ b/src/librustc/middle/borrowck/move_data.rs
@@ -1414,38 +1414,129 @@ impl BitwiseOperator for NeedsDropDataFlowOperator {
         // In principle, for correct code, the fixed-point solution
         // to the dataflow equations will have succ == pred here.
         //
-        // But since we need to deal with states before we hit the
-        // fixed point, we use logical-or here, to properly handle cases
-        // like a while loop:
+        // But of course need to deal with states before we hit the
+        // fixed point.  Consider the following while-loop:
+        //
         //   `{ let a = box 3; while <cond> { <body> } <rest> }`
         // where <cond> and <body> do not move or drop `a`:
         //
-        //         [let a = box 3;]
-        //           |
-        //           v 1
-        //       [loopback] <--+ 5
-        //           |         |
-        //           v 2       |
-        //   +-----[cond]      |
-        //   |       |         |
-        //   |       v 4       |
-        //   |     [body] -----+
-        //   v 3
-        // [rest]
+        //                    [let a = box 3;]
+        //                      |
+        //                      v 1
+        //                  [loopback] <--+ 5
+        //                      |         |
+        //                      v 2       |
+        //              +-----[cond]      |
+        //              |       |         |
+        //              |       v 4       |
+        //              |     [body] -----+
+        //              v 3
+        //            [rest]
         //
         // we need to ensure that the fixed-point solution registers
-        // that `a` is needs-drop on all of the above edges.
-        // Logical-or will accomplish that here (while logical-and
-        // would cause the fixed point solution to falsely claim that
-        // `a` is only needs-drop on edge 1.
-
-        succ | pred
+        // that `a` is needs-drop on all of the above edges.  (Note
+        // that choosing logical-and and a false initial value would
+        // cause the fixed point solution to falsely claim that `a` is
+        // only needs-drop on edge 1, because edge 5 would start as
+        // false and then the merge between edge 1 and edge 5 would be
+        // logically anded to false on edge 2, and so on.)
+        //
+        // We could use logical-or here (and a false initial value)
+        // like the other analyses.  Or, we can (and do) use
+        // logical-and and a true initial value.  For correct code,
+        // they will both end with the same fixed point.
+        //
+        // The reason to use logical-and instead of logical-or is
+        // error reporting.  In particular, we start with an
+        // assumption.
+        //
+        // ASSUMPTION: When there is a discrepancy between the set of
+        // drop-obligations for two paths at a merge point, we assume
+        // for the purposes of error reporting that the error was that
+        // the user forgot to include a drop of the resource, *not*
+        // that the user intended to re-establish the resource on the
+        // path where it had been dropped.
+        //
+        // Consider the following example:
+        //
+        //                       [let a = box 3;]             
+        //                             +                      
+        //                             |                      
+        //                             v                      
+        //                    +---+[cond 1]+--+               
+        //    (a needs drop)  |               | (a needs drop)
+        //                    v               |               
+        //             +-+[cond 2]+-+         |               
+        //             |            |         |               
+        //             v            v         v               
+        //     [no use of a]   [consume a]   [consume a]      
+        //                +         +         |               
+        // (a needs drop) |         |  ()     | ()            
+        //                v         v         |               
+        //              [merge point 1]       |               
+        //                    +               |               
+        //                (*) |               |               
+        //                    +---------+     |               
+        //                              |     |               
+        //                              v     v               
+        //                          [merge point 2]           
+        //
+        // At `[merge point 1]`, we obviously report a discrepancy
+        // between the two incoming paths.  The question: What do we
+        // want the set of drop obligations to be at the exit of
+        // `[merge point 1]`, where the `(*)` is marked.  There are
+        // two possible choices for `(*)`: `()`, and `(a needs drop)`.
+        //
+        // Choosing `(a needs drop)` corresponds to an assumption that
+        // on the path where `a` was dropped, the programmer probably
+        // meant to re-establish `a`.  To get this choice, one would
+        // use logical-or here.
+        //
+        // Choosing `()` corresponds to an assumption that on the path
+        // where `a` was not dropped, the programmer probably meant to
+        // drop it.  To get this choice, we use logical-and here.
+        //
+        // Each choice for `(*)` also has implications for when
+        // check_drops considers `[merge point 2]`: Choosing `()`
+        // means that nothing is reported for `[merge point 2]`, since
+        // the two incoming paths have the same set of drop
+        // obligations.  Choosing `(a needs drop)` means that we get a
+        // similar error report to the one for `[merge point 1]`,
+        // which may be frustrating to the programmer who already
+        // probably saw that they would need to add the drop of `a` on
+        // the far left path.
+        //
+        // (One could argue that the above example is artificial,
+        // since a small alteration of the graph above has a path on
+        // the far right-hand side that does not consume `a`, and in
+        // that situation, choosing `(a needs drop)` for `(*)` will
+        // produce fewer error messages.  However, we are *not*
+        // selecting logical-and over logical-or solely based on some
+        // expectation of the number of error messages encountered.
+        // Instead, it is based on our starting assumption: if in
+        // example above the far right path is missing a drop of a,
+        // then by our assumption, we *should* issue two error
+        // reports, since there are *two* places where the programmer
+        // needs to add calls to drop: the far left-hand path, and the
+        // far right-hand path.)
+
+        succ & pred
     }
 }
 
 impl DataFlowOperator for NeedsDropDataFlowOperator {
     #[inline]
     fn initial_value(&self) -> bool {
-        false // paths uninitialized by default and thus do not need dropping
+        // For non-entry nodes, assume paths need dropping until
+        // proven otherwise.
+        //
+        // See extensive discussion in impl BitwiseOperator for
+        // NeedsDropDataFlowOperator.
+        true
+    }
+
+    #[inline]
+    fn entry_initial_value(&self) -> bool {
+        false
     }
 }

commit f70718d35d8b427a12f66e6fa6f73d000c650bf2
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Thu Jul 31 14:39:44 2014 +0200

    dataflow: differentiate between entry/non-entry for initial bitsets.
    
    The API remains backwards compatible through (overly?) clever use of
    trait default methods.
---
 src/librustc/middle/dataflow.rs | 34 +++++++++++++++++++++++++++++++---
 1 file changed, 31 insertions(+), 3 deletions(-)

diff --git a/src/librustc/middle/dataflow.rs b/src/librustc/middle/dataflow.rs
index 90dda6f..1f7b33c 100644
--- a/src/librustc/middle/dataflow.rs
+++ b/src/librustc/middle/dataflow.rs
@@ -77,7 +77,20 @@ pub trait BitwiseOperator {
 /// Parameterization for the precise form of data flow that is used.
 pub trait DataFlowOperator : BitwiseOperator {
     /// Specifies the initial value for each bit in the `on_entry` set
+    /// for every node (except `cfg.entry`) in the flowgraph `cfg`
+    /// that is being analyzed.
+    ///
+    /// See also `entry_initial_value`.
     fn initial_value(&self) -> bool;
+
+    /// Specifies the initial value for each bit in the `on_entry` set
+    /// for `cfg.entry` in the flowgraph `cfg` that is being analyzed.
+    ///
+    /// Defaults to `self.initial_value()`, since many dataflow
+    /// analyses use the same setting in both contexts.
+    fn entry_initial_value(&self) -> bool {
+        self.initial_value()
+    }
 }
 
 struct PropagationContext<'a, 'b: 'a, 'tcx: 'b, O: 'a> {
@@ -201,15 +214,15 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {
                analysis_name, id_range, bits_per_id, words_per_id,
                num_nodes);
 
-        let entry = if oper.initial_value() { uint::MAX } else {0};
+        let init_most = if oper.initial_value() { uint::MAX } else {0};
 
         let gens = Vec::from_elem(num_nodes * words_per_id, 0);
         let kills = Vec::from_elem(num_nodes * words_per_id, 0);
-        let on_entry = Vec::from_elem(num_nodes * words_per_id, entry);
+        let on_entry = Vec::from_elem(num_nodes * words_per_id, init_most);
 
         let nodeid_to_index = build_nodeid_to_index(decl, cfg);
 
-        DataFlowContext {
+        let mut dfcx = DataFlowContext {
             tcx: tcx,
             analysis_name: analysis_name,
             words_per_id: words_per_id,
@@ -219,7 +232,22 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {
             gens: gens,
             kills: kills,
             on_entry: on_entry
+        };
+
+        if dfcx.words_per_id == 0 {
+            return dfcx;
         }
+
+        let init_first = if dfcx.oper.entry_initial_value() { uint::MAX } else {0};
+        if init_first != init_most {
+            let (start, end) = dfcx.compute_id_range(cfg.entry);
+            let on_entry_to_entry = dfcx.on_entry.mut_slice(start, end);
+            for elem in on_entry_to_entry.mut_iter() {
+                *elem = init_first;
+            }
+        }
+
+        dfcx
     }
 
     pub fn add_gen(&mut self, id: ast::NodeId, bit: uint) {

commit daef5c01cc00ff9d4786846abc8b1646c39c109b
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Wed Jul 30 18:24:31 2014 +0200

    rust-needsdrop: *proper* fix for long-standing bug with proc handling.
    
    When doing `LoanPath::to_type`, `LpUpvar` is either an implicit
    reference (when the upvar is captured by reference) or a value (when
    captured by value and thus moved into the closure).
    
    So I propagated this information into the `LoanPath` so that I can easily
    compute the right thing in `LoanPath::to_type`.
---
 src/librustc/middle/borrowck/check_loans.rs               |  4 ++--
 src/librustc/middle/borrowck/gather_loans/mod.rs          |  2 +-
 src/librustc/middle/borrowck/gather_loans/restrictions.rs |  2 +-
 src/librustc/middle/borrowck/mod.rs                       | 54 +++++++++++++++++++++++++++++++++---------------------
 src/librustc/middle/borrowck/move_data.rs                 |  8 ++++----
 5 files changed, 41 insertions(+), 29 deletions(-)

diff --git a/src/librustc/middle/borrowck/check_loans.rs b/src/librustc/middle/borrowck/check_loans.rs
index f09c350..c68d661 100644
--- a/src/librustc/middle/borrowck/check_loans.rs
+++ b/src/librustc/middle/borrowck/check_loans.rs
@@ -300,7 +300,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {
         let mut loan_path = loan_path;
         loop {
             match *loan_path {
-                LpVar(_) | LpUpvar(_) => {
+                LpVar(_) | LpUpvar(..) => {
                     break;
                 }
                 LpDowncast(ref lp_base, _) => {
@@ -697,7 +697,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {
          */
 
         match **lp {
-            LpVar(_) | LpUpvar(_) => {
+            LpVar(_) | LpUpvar(..) => {
                 // assigning to `x` does not require that `x` is initialized
             }
             LpDowncast(ref lp_base, _) => {
diff --git a/src/librustc/middle/borrowck/gather_loans/mod.rs b/src/librustc/middle/borrowck/gather_loans/mod.rs
index 908de88..7dab3e3 100644
--- a/src/librustc/middle/borrowck/gather_loans/mod.rs
+++ b/src/librustc/middle/borrowck/gather_loans/mod.rs
@@ -423,7 +423,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {
 
         match *loan_path {
             LpVar(local_id) |
-            LpUpvar(ty::UpvarId{ var_id: local_id, closure_expr_id: _ }) => {
+            LpUpvar(ty::UpvarId{ var_id: local_id, closure_expr_id: _ }, _) => {
                 self.tcx().used_mut_nodes.borrow_mut().insert(local_id);
             }
             LpDowncast(ref base, _) => {
diff --git a/src/librustc/middle/borrowck/gather_loans/restrictions.rs b/src/librustc/middle/borrowck/gather_loans/restrictions.rs
index b2ad930..7487f19 100644
--- a/src/librustc/middle/borrowck/gather_loans/restrictions.rs
+++ b/src/librustc/middle/borrowck/gather_loans/restrictions.rs
@@ -75,7 +75,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {
 
             mc::cat_upvar(upvar_id, _) => {
                 // R-Variable, captured into closure
-                let lp = Rc::new(LpUpvar(upvar_id));
+                let lp = Rc::new(LpUpvar(upvar_id, CaptureByRef));
                 SafeIf(lp.clone(), vec![lp])
             }
 
diff --git a/src/librustc/middle/borrowck/mod.rs b/src/librustc/middle/borrowck/mod.rs
index 893a10a..3bf68a8 100644
--- a/src/librustc/middle/borrowck/mod.rs
+++ b/src/librustc/middle/borrowck/mod.rs
@@ -279,9 +279,12 @@ impl Loan {
 }
 
 #[deriving(PartialEq, Eq, Hash)]
+pub enum CaptureKind { CaptureByVal, CaptureByRef }
+
+#[deriving(PartialEq, Eq, Hash)]
 pub enum LoanPath {
     LpVar(ast::NodeId),                   // `x` in doc.rs
-    LpUpvar(ty::UpvarId),                 // `x` captured by-value into closure
+    LpUpvar(ty::UpvarId, CaptureKind),    // `x` captured by-value into closure
     LpDowncast(Rc<LoanPath>, ast::DefId), // `x` downcast to particular enum variant
     LpExtend(Rc<LoanPath>, mc::MutabilityCategory, LoanPathElem),
 }
@@ -293,13 +296,17 @@ impl LoanPath {
 
         debug!("lp.to_type() for lp={:s}", self.repr(tcx));
         let opt_ty = match *self {
-            LpUpvar(ty::UpvarId { var_id: id, closure_expr_id: _ }) =>
+            LpUpvar(ty::UpvarId { var_id: id, closure_expr_id: _ }, capture) =>
                 ty::node_id_to_type_opt(tcx, id).map(|t| {
-                    ty::mk_ptr(tcx, ty::mt{ty: t,
-                                           // making up immut here.
-                                           // Hopefully won't matter.
-                                           mutbl: ast::MutImmutable})
-                }),
+                    match capture {
+                        CaptureByVal => t,
+                        CaptureByRef =>
+                            ty::mk_ptr(tcx, ty::mt{ty: t,
+                                                   // making up immut here.
+                                                   // Hopefully won't matter.
+                                                   mutbl: ast::MutImmutable}),
+                    }}),
+
             LpVar(id) => ty::node_id_to_type_opt(tcx, id),
 
             // treat the downcasted enum as having the enum's type;
@@ -340,10 +347,15 @@ impl LoanPath {
                     (&LpInterior(Element(_)), &ty::ty_vec(mt, _len)) =>
                         Some(ty::mk_ptr(tcx, mt)),
 
-                    (lp_elem, _) =>
-                        fail!("Unexpected combination of LpExtend with \
-                               LoanPathElem={:?} and base t = {}",
-                              lp_elem, t.repr(tcx)),
+                    (lp_elem, _) => {
+                        let id = self.kill_scope(tcx);
+                        let msg =
+                            format!("Unexpected combination of LpExtend \
+                                     with LoanPathElem={:?} and base t = {}",
+                                    lp_elem, t.repr(tcx));
+                        let opt_span = tcx.map.opt_span(id);
+                        tcx.sess.opt_span_bug(opt_span, msg.as_slice())
+                    }
                 }
             }
         };
@@ -351,10 +363,7 @@ impl LoanPath {
             let id = self.kill_scope(tcx);
             let msg = format!("no type found for lp={:s}", self.repr(tcx));
             let opt_span = tcx.map.opt_span(id);
-            match opt_span {
-                Some(s) => tcx.sess.span_bug(s, msg.as_slice()),
-                None => tcx.sess.bug(msg.as_slice()),
-            }
+            tcx.sess.opt_span_bug(opt_span, msg.as_slice());
         });
         debug!("lp.to_type() for lp={:s} returns t={:s}",
                self.repr(tcx), t.repr(tcx));
@@ -369,7 +378,7 @@ impl LoanPath {
         debug!("needs_drop(tcx) self={}", self.repr(tcx));
 
         match *self {
-            LpVar(_) | LpUpvar(_) =>
+            LpVar(_) | LpUpvar(..) =>
                 // Variables are the easiest case: just use their
                 // types to determine wwhether they introduce a drop
                 // obligation when assigned.  (FSK well, at the
@@ -463,7 +472,7 @@ impl LoanPath {
     pub fn kill_scope(&self, tcx: &ty::ctxt) -> ast::NodeId {
         match *self {
             LpVar(local_id) => tcx.region_maps.var_scope(local_id),
-            LpUpvar(upvar_id) =>
+            LpUpvar(upvar_id, _) =>
                 closure_to_block(upvar_id.closure_expr_id, tcx),
             LpDowncast(ref base, _) |
             LpExtend(ref base, _, _) => base.kill_scope(tcx),
@@ -492,12 +501,15 @@ pub fn opt_loan_path(cmt: &mc::cmt, tcx: &ty::ctxt) -> Option<Rc<LoanPath>> {
             Some(Rc::new(LpVar(id)))
         }
 
-        mc::cat_upvar(ty::UpvarId {var_id: id, closure_expr_id: proc_id}, _) |
+        mc::cat_upvar(ty::UpvarId {var_id: id, closure_expr_id: proc_id}, _) => {
+            let upvar_id = ty::UpvarId{ var_id: id, closure_expr_id: proc_id };
+            Some(Rc::new(LpUpvar(upvar_id, CaptureByRef)))
+        }
         mc::cat_copied_upvar(mc::CopiedUpvar { upvar_id: id,
                                                onceness: _,
                                                capturing_proc: proc_id }) => {
             let upvar_id = ty::UpvarId{ var_id: id, closure_expr_id: proc_id };
-            Some(Rc::new(LpUpvar(upvar_id)))
+            Some(Rc::new(LpUpvar(upvar_id, CaptureByVal)))
         }
 
         mc::cat_deref(ref cmt_base, _, pk) => {
@@ -952,7 +964,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {
                                    loan_path: &LoanPath,
                                    out: &mut String) {
         match *loan_path {
-            LpUpvar(ty::UpvarId{ var_id: id, closure_expr_id: _ }) |
+            LpUpvar(ty::UpvarId{ var_id: id, closure_expr_id: _ }, _) |
             LpVar(id) => {
                 out.push_str(ty::local_var_name_str(self.tcx, id).get());
             }
@@ -1072,7 +1084,7 @@ impl Repr for LoanPath {
                 format!("$({})", tcx.map.node_to_string(id))
             }
 
-            &LpUpvar(ty::UpvarId{ var_id, closure_expr_id }) => {
+            &LpUpvar(ty::UpvarId{ var_id, closure_expr_id }, _) => {
                 let s = tcx.map.node_to_string(var_id);
                 format!("$({} captured by id={})", s, closure_expr_id)
             }
diff --git a/src/librustc/middle/borrowck/move_data.rs b/src/librustc/middle/borrowck/move_data.rs
index 017ed48..2f4753c 100644
--- a/src/librustc/middle/borrowck/move_data.rs
+++ b/src/librustc/middle/borrowck/move_data.rs
@@ -196,7 +196,7 @@ pub type NeedsDropDataFlow<'a> = DataFlowContext<'a, NeedsDropDataFlowOperator>;
 
 fn loan_path_is_precise(loan_path: &LoanPath) -> bool {
     match *loan_path {
-        LpVar(_) | LpUpvar(_) => {
+        LpVar(_) | LpUpvar(..) => {
             true
         }
         LpExtend(_, _, LpInterior(mc::InteriorElement(_))) => {
@@ -591,7 +591,7 @@ impl MoveData {
                lp.repr(tcx), origin_id);
 
         match *lp {
-            LpVar(_) | LpUpvar(_) => {} // Local variables have no siblings.
+            LpVar(_) | LpUpvar(..) => {} // Local variables have no siblings.
 
             LpDowncast(..) => {} // an enum variant (on its own) has no siblings.
 
@@ -854,7 +854,7 @@ impl MoveData {
                     let rm = Removed { where: kill_id, what_path: move_path_index };
                     self.remove_drop_obligations(tcx, &rm, dfcx_needs_drop);
                 }
-                LpUpvar(ty::UpvarId { var_id: _, closure_expr_id }) => {
+                LpUpvar(ty::UpvarId { var_id: _, closure_expr_id }, _) => {
                     let kill_id = closure_to_block(closure_expr_id, tcx);
                     let move_path_index = *self.path_map.borrow().get(&path.loan_path);
                     self.kill_moves(move_path_index, kill_id, dfcx_moves);
@@ -876,7 +876,7 @@ impl MoveData {
                     let kill_id = tcx.region_maps.var_scope(id);
                     dfcx_assign.add_kill(kill_id, assignment_index);
                 }
-                LpUpvar(ty::UpvarId { var_id: _, closure_expr_id }) => {
+                LpUpvar(ty::UpvarId { var_id: _, closure_expr_id }, _) => {
                     let kill_id = closure_to_block(closure_expr_id, tcx);
                     dfcx_assign.add_kill(kill_id, assignment_index);
                 }

commit 65821c8e1415aa41c96cce177def6d8122be0fb8
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Wed Jul 30 16:18:39 2014 +0200

    Fix bug: `LpExtend(_, _, LpDeref(_))` needs different handling than others.
---
 src/librustc/middle/borrowck/mod.rs | 56 +++++++++++++++++++++++++++++++++++++++++++++++---------
 1 file changed, 47 insertions(+), 9 deletions(-)

diff --git a/src/librustc/middle/borrowck/mod.rs b/src/librustc/middle/borrowck/mod.rs
index fe3347f..893a10a 100644
--- a/src/librustc/middle/borrowck/mod.rs
+++ b/src/librustc/middle/borrowck/mod.rs
@@ -362,19 +362,57 @@ impl LoanPath {
     }
 
     fn needs_drop(&self, tcx: &ty::ctxt) -> bool {
-        //! Returns true if this loan path needs drop glue.  Usually
-        //! this just means that the type of the loan path needs drop
-        //! glue, but an enum can have some variants that need drop
-        //! glue and other variants that do not.
+        //! Returns true if this loan path needs drop glue.  I.e.,
+        //! does introducing this loan path as a binding introduce a
+        //! new drop obligation.
 
         debug!("needs_drop(tcx) self={}", self.repr(tcx));
 
-        let (lp, variant_def_id) = match *self {
-            LpDowncast(ref lp, def_id) => (lp, def_id),
-            _ => return ty::type_needs_drop(tcx, self.to_type(tcx)),
-        };
+        match *self {
+            LpVar(_) | LpUpvar(_) =>
+                // Variables are the easiest case: just use their
+                // types to determine wwhether they introduce a drop
+                // obligation when assigned.  (FSK well, at the
+                // *moment* they are easy; we may put in
+                // flow-sensitivity in some form.  Or maybe not, we
+                // will see.)
+                ty::type_needs_drop(tcx, self.to_type(tcx)),
+
+            LpExtend(_, _, LpDeref(_)) =>
+                // A path through a `&` or `&mut` reference cannot
+                // introduce a drop obligation; e.g. the assignment
+                // `*p = box 3u` installs a pointer elsewhere that is
+                // the responsibility of someone else (e.g. a caller).
+                false,
+
+            LpExtend(ref base_lp, _cat, LpInterior(_)) =>
+                // 1. Ensure base_lp does not nullify the drop
+                //    obligation (e.g. if it is through a LpDeref,
+                //    such as an example like `*x.p = box 3u` (which
+                //    in the source code may look like `x.p = box 3u`
+                //    due to autoderef).
+                base_lp.needs_drop(tcx) &&
+
+                // 2. Even if the base_lp needs drop, this particular
+                //    field might not.  E.g. for `x.q = 3u`, `x` may
+                //    itself introduce a drop obligation, but the type
+                //    of `q` means that that particular field does not
+                //    affect dropping.
+                ty::type_needs_drop(tcx, self.to_type(tcx)),
+
+            LpDowncast(ref lp, def_id) => self.enum_variant_needs_drop(tcx, lp, def_id),
+        }
+    }
 
-        // Code below is to handle one enum variant as a special case.
+    fn enum_variant_needs_drop(&self,
+                               tcx: &ty::ctxt,
+                               lp: &Rc<LoanPath>,
+                               variant_def_id: ast::DefId) -> bool {
+        //! Handle a particular enum variant as a special case, since
+        //! the type of an enum variant, like `None` has type
+        //! `Option<T>`, can indicate that it needs-drop, even though
+        //! that particular variant does not introduce a
+        //! drop-obligation.
 
         let lp_type = lp.to_type(tcx);
         match ty::get(lp_type).sty {

commit cadd3955d5c0d270b35c71b33e58543325e78951
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Wed Jul 30 16:18:00 2014 +0200

    rust-needsdrop: Remove with_var_parent, address warning when building librustc.
---
 src/librustc/middle/region.rs | 3 ---
 1 file changed, 3 deletions(-)

diff --git a/src/librustc/middle/region.rs b/src/librustc/middle/region.rs
index 278b648..2c62dab 100644
--- a/src/librustc/middle/region.rs
+++ b/src/librustc/middle/region.rs
@@ -106,9 +106,6 @@ impl Context {
             lifetime_parent: None,
         }
     }
-    fn with_var_parent(&self, id: ast::NodeId) -> Context {
-        Context { var_parent: Some(id), ..*self }
-    }
     fn with_lifetime_parent(&self, id: ast::NodeId) -> Context {
         Context { lifetime_parent: Some(id), ..*self }
     }

commit 6d7e8c3ade77bfa689a021efeedadf54158c43c9
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Wed Jul 30 11:42:21 2014 +0200

    rust-needsdrop bug fix: handle singleton enum not doing downcast in more places.
    
    This corner case is annoying.  I should look into whether it would be
    better to just get rid of it and use Downcast everywhere, since I do
    not think it is serving its former purpose anymore anyway.
---
 src/librustc/middle/borrowck/move_data.rs | 23 ++++++++++++++++++-----
 src/librustc/middle/ty.rs                 |  7 +++++++
 2 files changed, 25 insertions(+), 5 deletions(-)

diff --git a/src/librustc/middle/borrowck/move_data.rs b/src/librustc/middle/borrowck/move_data.rs
index c7d1485..017ed48 100644
--- a/src/librustc/middle/borrowck/move_data.rs
+++ b/src/librustc/middle/borrowck/move_data.rs
@@ -693,8 +693,21 @@ impl MoveData {
                 }
             }
 
-            (&ty::ty_enum(def_id, ref _substs), Some((variant_def_id, ref _lp2))) => {
-                let variant_info = ty::enum_variant_with_id(tcx, def_id, variant_def_id);
+            (&ty::ty_enum(enum_def_id, ref substs), ref enum_variant_info) => {
+                let variant_info = {
+                    let mut variants = ty::substd_enum_variants(tcx, enum_def_id, substs);
+                    match *enum_variant_info {
+                        Some((variant_def_id, ref _lp2)) =>
+                            variants.iter()
+                            .find(|variant| variant.id == variant_def_id)
+                            .expect("enum_variant_with_id(): no variant exists with that ID")
+                            .clone(),
+                        None => {
+                            assert!(variants.len() == 1);
+                            variants.pop().unwrap()
+                        }
+                    }
+                };
                 match *origin_field_name {
                     mc::NamedField(ast_name) => {
                         let variant_arg_names = variant_info.arg_names.as_ref().unwrap();
@@ -722,9 +735,9 @@ impl MoveData {
                 }
             }
 
-            ref sty => {
-                let msg = format!("type {} ({:?}) shouldn't have named fields",
-                                  parent_ty.repr(tcx), sty);
+            ref sty_and_variant_info => {
+                let msg = format!("type {} ({:?}) is not fragmentable",
+                                  parent_ty.repr(tcx), sty_and_variant_info);
                 tcx.sess.opt_span_bug(tcx.map.opt_span(origin_id),
                                       msg.as_slice())
             }
diff --git a/src/librustc/middle/ty.rs b/src/librustc/middle/ty.rs
index a018595..e79fec9 100644
--- a/src/librustc/middle/ty.rs
+++ b/src/librustc/middle/ty.rs
@@ -3116,6 +3116,13 @@ pub fn positional_element_ty(cx: &ctxt, t: t, i: uint, variant_id: Option<ast::D
             variant_info.args.as_slice().get(i).map(|t|t.subst(cx, substs))
         }
 
+        (&ty_enum(def_id, ref substs), None) => {
+            assert!(enum_is_univariant(cx, def_id));
+            let enum_variants = enum_variants(cx, def_id);
+            let variant_info = enum_variants.get(0);
+            variant_info.args.as_slice().get(i).map(|t|t.subst(cx, substs))
+        }
+
         _ => None
     }
 }

commit 70ba6b53b3100fead032aaddae886d0dba883f13
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Wed Jul 30 11:40:27 2014 +0200

    rust-needsdrop: fail a bit more eagerly to provide better debug feedback.
---
 src/librustc/middle/borrowck/mod.rs | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/src/librustc/middle/borrowck/mod.rs b/src/librustc/middle/borrowck/mod.rs
index 7694e72..fe3347f 100644
--- a/src/librustc/middle/borrowck/mod.rs
+++ b/src/librustc/middle/borrowck/mod.rs
@@ -340,7 +340,10 @@ impl LoanPath {
                     (&LpInterior(Element(_)), &ty::ty_vec(mt, _len)) =>
                         Some(ty::mk_ptr(tcx, mt)),
 
-                    _ => None,
+                    (lp_elem, _) =>
+                        fail!("Unexpected combination of LpExtend with \
+                               LoanPathElem={:?} and base t = {}",
+                              lp_elem, t.repr(tcx)),
                 }
             }
         };

commit dd2e28de642889e9c05bea62375d831b6db64ed5
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Tue Jul 29 18:13:11 2014 +0200

    rust-needsdrop: Various improvements to error reporting.
    
    that is, error reporting on internal rustc issues in my hacked code.
---
 src/librustc/middle/borrowck/move_data.rs | 13 +++++++++----
 1 file changed, 9 insertions(+), 4 deletions(-)

diff --git a/src/librustc/middle/borrowck/move_data.rs b/src/librustc/middle/borrowck/move_data.rs
index 32f294f..c7d1485 100644
--- a/src/librustc/middle/borrowck/move_data.rs
+++ b/src/librustc/middle/borrowck/move_data.rs
@@ -635,7 +635,7 @@ impl MoveData {
                                            mc: mc::MutabilityCategory,
                                            origin_field_name: &mc::FieldName,
                                            origin_lp: &Rc<LoanPath>,
-                                           _origin_id: ast::NodeId,
+                                           origin_id: ast::NodeId,
                                            enum_variant_info: Option<(ast::DefId, Rc<LoanPath>)>) {
         /*! We have determined that `origin_lp` destructures to
          * LpExtend(parent, original_field_name). Based on this,
@@ -653,7 +653,8 @@ impl MoveData {
                 let tuple_idx = match *origin_field_name {
                     mc::PositionalField(tuple_idx) => tuple_idx,
                     mc::NamedField(_) =>
-                        fail!("tuple type should not have named fields."),
+                        fail!("tuple type {} should not have named fields.",
+                              parent_ty.repr(tcx)),
                 };
                 let tuple_len = v.len();
                 for i in range(0, tuple_len) {
@@ -721,8 +722,12 @@ impl MoveData {
                 }
             }
 
-            ref sty => fail!("type {} ({:?}) shouldn't have named fields",
-                             parent_ty.repr(tcx), sty),
+            ref sty => {
+                let msg = format!("type {} ({:?}) shouldn't have named fields",
+                                  parent_ty.repr(tcx), sty);
+                tcx.sess.opt_span_bug(tcx.map.opt_span(origin_id),
+                                      msg.as_slice())
+            }
         }
     }
 

commit ee9f3a706f53c4b99320d5f5361259c374fffe4b
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Tue Jul 29 18:12:28 2014 +0200

    Once you are beyond stage0, Gc<T> does not auto-coerce to &T.
---
 src/libsyntax/ext/expand.rs | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/libsyntax/ext/expand.rs b/src/libsyntax/ext/expand.rs
index 5e6894c..e52f31b 100644
--- a/src/libsyntax/ext/expand.rs
+++ b/src/libsyntax/ext/expand.rs
@@ -951,7 +951,7 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {
     }
 
     fn fold_arm(&mut self, arm: Gc<ast::Arm>) -> Gc<ast::Arm> {
-        expand_arm(arm, self)
+        expand_arm(&*arm, self)
     }
 
     fn fold_method(&mut self, method: Gc<ast::Method>) -> SmallVector<Gc<ast::Method>> {

commit a2af002aa3afaeea9c0b931d078902691a5d067d
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Tue Jul 29 18:11:56 2014 +0200

    Add `opt_span_bug` to session, analogous to `opt_span_warn`.
---
 src/librustc/driver/session.rs | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/src/librustc/driver/session.rs b/src/librustc/driver/session.rs
index f2ea9ec..5b2ac9f 100644
--- a/src/librustc/driver/session.rs
+++ b/src/librustc/driver/session.rs
@@ -109,6 +109,12 @@ impl Session {
     pub fn note(&self, msg: &str) {
         self.diagnostic().handler().note(msg)
     }
+    pub fn opt_span_bug(&self, opt_sp: Option<Span>, msg: &str) -> ! {
+        match opt_sp {
+            Some(sp) => self.span_bug(sp, msg),
+            None => self.bug(msg),
+        }
+    }
     pub fn span_bug(&self, sp: Span, msg: &str) -> ! {
         self.diagnostic().span_bug(sp, msg)
     }

commit a1e329c53c195b3d52cad166abca02b0d41b1920
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Tue Jul 29 15:15:41 2014 +0200

    dataflow: Now apply_gen_kill is pub, defend against degenerate case.
---
 src/librustc/middle/dataflow.rs | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/src/librustc/middle/dataflow.rs b/src/librustc/middle/dataflow.rs
index dd6819b..90dda6f 100644
--- a/src/librustc/middle/dataflow.rs
+++ b/src/librustc/middle/dataflow.rs
@@ -252,7 +252,9 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {
         //! Applies the gen and kill sets for `cfgidx` to `bits`
         debug!("{:s} apply_gen_kill(cfgidx={}, bits={}) [before]",
                self.analysis_name, cfgidx, mut_bits_to_string(bits));
-        assert!(self.bits_per_id > 0);
+        if self.bits_per_id == 0 {
+            return;
+        }
 
         let (start, end) = self.compute_id_range(cfgidx);
         let gens = self.gens.slice(start, end);

commit 03b8eca219d810d8700d54a0151d2f4d5475ddd9
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Tue Jul 29 14:01:17 2014 +0200

    rust-needsdrop: Checkpoint of many changes to tease apart later.
    
    Checkpoint of many changes that should be teased apart or outright
    removed at some later point.  Lots of experimental stuff.
    Semi-working.
---
 src/librustc/driver/driver.rs                    |  4 ++++
 src/librustc/driver/session.rs                   |  6 ++++++
 src/librustc/middle/borrowck/check_drops.rs      | 47 ++++++++++++++++++++++++++++++++++++++++++++++-
 src/librustc/middle/borrowck/gather_loans/mod.rs | 10 +++++++---
 src/librustc/middle/borrowck/move_data.rs        | 10 +++++++++-
 src/librustc/middle/dataflow.rs                  |  3 ++-
 src/librustc/middle/region.rs                    | 66 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++----------
 src/librustc/middle/trans/_match.rs              |  2 --
 src/libsyntax/print/pprust.rs                    |  7 +++++--
 9 files changed, 135 insertions(+), 20 deletions(-)

diff --git a/src/librustc/driver/driver.rs b/src/librustc/driver/driver.rs
index b10bd84..8163fcf 100644
--- a/src/librustc/driver/driver.rs
+++ b/src/librustc/driver/driver.rs
@@ -910,6 +910,10 @@ impl pprust::PpAnn for IdentifiedAnnotation {
                 try!(pp::space(&mut s.s));
                 s.synth_comment(format!("arm {}", arm.id))
             }
+            pprust::NodeMethod(m) => {
+                try!(pp::space(&mut s.s));
+                s.synth_comment(format!("method {}", m.id))
+            }
         }
     }
 }
diff --git a/src/librustc/driver/session.rs b/src/librustc/driver/session.rs
index 135e21e..f2ea9ec 100644
--- a/src/librustc/driver/session.rs
+++ b/src/librustc/driver/session.rs
@@ -82,6 +82,12 @@ impl Session {
     pub fn abort_if_errors(&self) {
         self.diagnostic().handler().abort_if_errors()
     }
+    pub fn opt_span_warn(&self, opt_sp: Option<Span>, msg: &str) {
+        match opt_sp {
+            Some(sp) => self.span_warn(sp, msg),
+            None => self.warn(msg),
+        }
+    }
     pub fn span_warn(&self, sp: Span, msg: &str) {
         self.diagnostic().span_warn(sp, msg)
     }
diff --git a/src/librustc/middle/borrowck/check_drops.rs b/src/librustc/middle/borrowck/check_drops.rs
index 523ea68..dab8ad4 100644
--- a/src/librustc/middle/borrowck/check_drops.rs
+++ b/src/librustc/middle/borrowck/check_drops.rs
@@ -101,9 +101,54 @@ pub fn check_drops(bccx: &BorrowckCtxt,
             temp
         };
 
+        // In theory, that should be all we need to do; i.e. at this
+        // point we should be able to compare each incoming node's
+        // exit state with the computed intersection, and report any
+        // deviation we see.
+        //
+        // HOWEVER: match arms complicate things.  In principle the
+        // bindings introduced by the bindings on a match arm are
+        // scoped to the match arm, and so for code like this:
+        //
+        //    match s {
+        //        Ok(x)  => { Some(x) },
+        //        Err(s) => { None },
+        //    }
+        //
+        // you might expect that the `s` on the `Err(s)` branch is
+        // dropped at the end of that arm.
+        //
+        // That's not how things are represented in the compiler,
+        // unfortunately for us here; instead, the compiler see's the
+        // lifetime of `s` as being the entire match expression, with
+        // the drop of `s` tied to the flowgraph node for the match
+        // itself, not each arm.
+        //
+        // pnkfelix tried to hack in support for representing the
+        // narrower scope of each arm that fits his mental model, but
+        // encountered some problems.
+        //
+        // So instead, we take this approach: instead of comparing
+        // each incoming edge to the intersection above directly, now
+        // compare each incoming edge to the intersection *after*
+        // applying the kill bits for this merge point to both sides.
+        // pnkfelix calls this "equivalence modulo merge-kills"
+        //
+        // This should take care of match patterns that will be
+        // automatically destroyed, while leaving paths with a broader
+        // scope than the match preserved.
+
+        let mut intersection = intersection;
+        needs_drop.apply_gen_kill(node_index, intersection.as_mut_slice());
+        let intersection = intersection;
+
         cfg.graph.each_incoming_edge(node_index, |edge_index, edge| {
             let source = edge.source();
-            let temp = needs_drop.bitset_for(dataflow::Exit, source);
+            let mut temp = needs_drop.bitset_for(dataflow::Exit, source);
+
+            // see note above about "equivalence modulo merge-kills"
+            needs_drop.apply_gen_kill(node_index, temp.as_mut_slice());
+
             if temp != intersection {
                 let source_id = cfg.graph.node(source).data.id;
                 let opt_source_span = bccx.tcx.map.opt_span(source_id);
diff --git a/src/librustc/middle/borrowck/gather_loans/mod.rs b/src/librustc/middle/borrowck/gather_loans/mod.rs
index d6e4f2a..908de88 100644
--- a/src/librustc/middle/borrowck/gather_loans/mod.rs
+++ b/src/librustc/middle/borrowck/gather_loans/mod.rs
@@ -99,9 +99,13 @@ impl<'a, 'tcx> euv::Delegate for GatherLoanCtxt<'a, 'tcx> {
             euv::ConsumingMatch(euv::Move(_)) => {}
         }
 
-        gather_moves::gather_move_into_variant(
-            self.bccx, &self.move_data, &self.move_error_collector,
-            matched_pat, cmt);
+        match cmt.cat {
+            mc::cat_downcast(..) =>
+                gather_moves::gather_move_into_variant(
+                    self.bccx, &self.move_data, &self.move_error_collector,
+                    matched_pat, cmt),
+            _ => {}
+        }
     }
 
 
diff --git a/src/librustc/middle/borrowck/move_data.rs b/src/librustc/middle/borrowck/move_data.rs
index 8ce366a..32f294f 100644
--- a/src/librustc/middle/borrowck/move_data.rs
+++ b/src/librustc/middle/borrowck/move_data.rs
@@ -597,7 +597,15 @@ impl MoveData {
 
             // *LV for OwnedPtr itself has no siblings, but we might need
             // to propagate inward.  Not sure.
-            LpExtend(_, _, LpDeref(mc::OwnedPtr)) => unimplemented!(),
+            LpExtend(_, _, LpDeref(mc::OwnedPtr)) => {
+                let msg =
+                    format!("add_fragment_siblings encountered \
+                             LpExtend(.., OwnedPtr): {}; \
+                             Assuming it has no siblings (for now).",
+                            lp.repr(tcx));
+                tcx.sess.opt_span_warn(tcx.map.opt_span(origin_id),
+                                       msg.as_slice());
+            }
 
             // *LV has no siblings
             LpExtend(_, _, LpDeref(_)) => {}
diff --git a/src/librustc/middle/dataflow.rs b/src/librustc/middle/dataflow.rs
index 0e49925..dd6819b 100644
--- a/src/librustc/middle/dataflow.rs
+++ b/src/librustc/middle/dataflow.rs
@@ -109,6 +109,7 @@ impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O
             pprust::NodeBlock(blk) => blk.id,
             pprust::NodeItem(_) => 0,
             pprust::NodePat(pat) => pat.id,
+            pprust::NodeMethod(m) => m.id,
             pprust::NodeArm(arm) => arm.id, // TODO: double-check Arm on dataflow+cfg
         };
 
@@ -247,7 +248,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {
         set_bit(kills, bit);
     }
 
-    fn apply_gen_kill(&self, cfgidx: CFGIndex, bits: &mut [uint]) {
+    pub fn apply_gen_kill(&self, cfgidx: CFGIndex, bits: &mut [uint]) {
         //! Applies the gen and kill sets for `cfgidx` to `bits`
         debug!("{:s} apply_gen_kill(cfgidx={}, bits={}) [before]",
                self.analysis_name, cfgidx, mut_bits_to_string(bits));
diff --git a/src/librustc/middle/region.rs b/src/librustc/middle/region.rs
index 9fa4767..278b648 100644
--- a/src/librustc/middle/region.rs
+++ b/src/librustc/middle/region.rs
@@ -453,6 +453,41 @@ fn resolve_arm(visitor: &mut RegionResolutionVisitor,
         None => { }
     }
 
+    visit::walk_arm(visitor, arm, cx);
+
+    // Regarding the commented out code below: it is difficult to
+    // figure out what to do for arm = {pat, guard, body}.
+    // In particular, it seems that currently, the scopes are
+    // set up to indcate that the parent of all three components
+    // is the whole match expression, which implies that the
+    // drops of pattern bindings occur at the end of the whole match,
+    // rather than at the end of an individual arm.
+    //
+    // In terms of the actual control flow, there is no distinction
+    // between the whole match and an individual arm.  But in terms of
+    // the control-flow graph representation, these seems to be
+    // very different things.
+    //
+    // pnkfelix's initial take on how to fix this was to explicitly
+    // represent the "scope of the arm" separately, and treat that as
+    // the parent for the pat and the expression.  But what about the
+    // guard?  That is where thing's got tricky, in part because the
+    // arm is not really a scope, and so it was not easy to figure out
+    // how to hack that in.  (Perhaps future changes to the language
+    // will make this make more sense, eg.. the proposal to make
+    // guards take bindings by-ref even if they are going to move for
+    // the body if the guard succeeds.  Or perhaps another approach
+    // would be to more fully distinguish between by-ref and by-move
+    // match arms, since the latter cannot have guards and the former
+    // ... do not need cleanup?  Is that right?  Not sure.)
+    //
+    // Anyway, pnkfelix is now revisiting his approach.  I.e. perhaps
+    // the answer is not to try to introduce some new notion of a
+    // match arm's "scope", but rather, "just" revise the move_data
+    // code for check_drops to treat the merge point for match as a
+    // special case.  Not yet sure.
+
+/*
     // Deliberately not invoking `visit::walk_arm(visitor, arm, cx)`.
     // Instead, walk each component in turn below, using `cx`
     // (carrying the parent scope) for the pattern and optional guard,
@@ -460,24 +495,35 @@ fn resolve_arm(visitor: &mut RegionResolutionVisitor,
     // encoding the distinct lifetime that is established for the
     // expression body.
 
-    let &Arm { ref attrs, ref pats, guard, body, id } = arm;
+    let &Arm { ref attrs, ref pats, guard, body, id: arm_id } = arm;
 
     // (Slightly misleading hack: using body of an arm as its span.)
-    record_superlifetime(visitor, cx, id, body.span);
-
-    // The variable parent of everything inside (most importantly, the
-    // pattern) is the arm.
-    let subcx = Context::new(id);
+    record_superlifetime(visitor, cx, arm_id, body.span);
 
+    // Bindings introduced by the pattern should be treated as having
+    // lifetime bounded by the arm itself.
+    let pat_subcx = cx.with_var_parent(arm_id);
     for pattern in pats.iter() {
-        visitor.visit_pat(&**pattern, subcx);
+        visitor.visit_pat(&**pattern, pat_subcx);
     }
-    visit::walk_expr_opt(visitor, guard, subcx);
 
-    visitor.visit_expr(&*body, subcx);
+    // For the guard, treat its lifetime parent as the arm itself.
+    //
+    // FIXME: would be nice to use `arm_id` here as well, for
+    // uniformity, but making that work requires trans hacking (FSK).
+    let arm_cx = Context::new(arm_id);
+    visit::walk_expr_opt(visitor, guard, arm_cx);
+
+    // The parent of the body expression is the arm itself (so that
+    // expressions within the arm will properly report that their
+    // lifetimes are contained within arm's superlifetime).
+    let body_cx = Context::new(arm_id);
+    visitor.visit_expr(&*body, body_cx);
+
     for attr in attrs.iter() {
-        visitor.visit_attribute(attr, subcx);
+        visitor.visit_attribute(attr, cx);
     }
+*/
 }
 
 fn resolve_pat(visitor: &mut RegionResolutionVisitor,
diff --git a/src/librustc/middle/trans/_match.rs b/src/librustc/middle/trans/_match.rs
index 35e1acf..dd0668b 100644
--- a/src/librustc/middle/trans/_match.rs
+++ b/src/librustc/middle/trans/_match.rs
@@ -1376,12 +1376,10 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,
         let mut bcx = arm_data.bodycx;
 
         // insert bindings into the lllocals map and add cleanups
-        fcx.push_match_arm_cleanup_scope(arm_data.arm.id);
         let cs = fcx.push_custom_cleanup_scope();
         bcx = insert_lllocals(bcx, &arm_data.bindings_map, Some(cleanup::CustomScope(cs)));
         bcx = expr::trans_into(bcx, &*arm_data.arm.body, dest);
         bcx = fcx.pop_and_trans_custom_cleanup_scope(bcx, cs);
-        bcx = fcx.pop_and_trans_match_arm_cleanup_scope(bcx, arm_data.arm.id);
         arm_cxs.push(bcx);
     }
 
diff --git a/src/libsyntax/print/pprust.rs b/src/libsyntax/print/pprust.rs
index 76955c3..37912d9 100644
--- a/src/libsyntax/print/pprust.rs
+++ b/src/libsyntax/print/pprust.rs
@@ -40,6 +40,7 @@ pub enum AnnNode<'a> {
     NodeExpr(&'a ast::Expr),
     NodePat(&'a ast::Pat),
     NodeArm(&'a ast::Arm),
+    NodeMethod(&'a ast::Method),
 }
 
 pub trait PpAnn {
@@ -1096,6 +1097,7 @@ impl<'a> State<'a> {
         try!(self.hardbreak_if_not_bol());
         try!(self.maybe_print_comment(meth.span.lo));
         try!(self.print_outer_attributes(meth.attrs.as_slice()));
+        try!(self.ann.pre(self, NodeMethod(meth)));
         match meth.node {
             ast::MethDecl(ident,
                           ref generics,
@@ -1113,7 +1115,7 @@ impl<'a> State<'a> {
                                    Some(explicit_self.node),
                                    vis));
                 try!(word(&mut self.s, " "));
-                self.print_block_with_attrs(&*body, meth.attrs.as_slice())
+                try!(self.print_block_with_attrs(&*body, meth.attrs.as_slice()))
             },
             ast::MethMac(codemap::Spanned { node: ast::MacInvocTT(ref pth, ref tts, _),
                                             ..}) => {
@@ -1124,9 +1126,10 @@ impl<'a> State<'a> {
                 try!(self.popen());
                 try!(self.print_tts(tts.as_slice()));
                 try!(self.pclose());
-                self.end()
+                try!(self.end())
             }
         }
+        self.ann.post(self, NodeMethod(meth))
     }
 
     pub fn print_outer_attributes(&mut self,

commit 581e48f67e1eb2e4c3b0bc3cc5d63bc74f63db9c
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Mon Jul 28 19:08:12 2014 +0200

    Attempt to address issues with Upvars in LoanPath::to_type.
---
 src/librustc/middle/borrowck/mod.rs | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git a/src/librustc/middle/borrowck/mod.rs b/src/librustc/middle/borrowck/mod.rs
index 9fee126..7694e72 100644
--- a/src/librustc/middle/borrowck/mod.rs
+++ b/src/librustc/middle/borrowck/mod.rs
@@ -293,7 +293,13 @@ impl LoanPath {
 
         debug!("lp.to_type() for lp={:s}", self.repr(tcx));
         let opt_ty = match *self {
-            LpUpvar(ty::UpvarId { var_id: id, closure_expr_id: _ }) |
+            LpUpvar(ty::UpvarId { var_id: id, closure_expr_id: _ }) =>
+                ty::node_id_to_type_opt(tcx, id).map(|t| {
+                    ty::mk_ptr(tcx, ty::mt{ty: t,
+                                           // making up immut here.
+                                           // Hopefully won't matter.
+                                           mutbl: ast::MutImmutable})
+                }),
             LpVar(id) => ty::node_id_to_type_opt(tcx, id),
 
             // treat the downcasted enum as having the enum's type;

commit 678055de3b55db7c78bb6b88236e7c1446e183df
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Mon Jul 28 19:07:52 2014 +0200

    Various changes to region inference to try to address issues with Arms with NodeIds.
---
 src/librustc/middle/region.rs | 68 +++++++++++++++++++++++++++++++++++++++++---------------------------
 1 file changed, 41 insertions(+), 27 deletions(-)

diff --git a/src/librustc/middle/region.rs b/src/librustc/middle/region.rs
index 4b79416..9fa4767 100644
--- a/src/librustc/middle/region.rs
+++ b/src/librustc/middle/region.rs
@@ -90,7 +90,28 @@ pub struct Context {
     var_parent: Option<ast::NodeId>,
 
     // Innermost enclosing scope (e.g. expression, match arm)
-    parent: Option<ast::NodeId>,
+    lifetime_parent: Option<ast::NodeId>,
+}
+
+impl Context {
+    fn new(id: ast::NodeId) -> Context {
+        Context {
+            var_parent: Some(id),
+            lifetime_parent: Some(id),
+        }
+    }
+    fn fresh() -> Context {
+        Context {
+            var_parent: None,
+            lifetime_parent: None,
+        }
+    }
+    fn with_var_parent(&self, id: ast::NodeId) -> Context {
+        Context { var_parent: Some(id), ..*self }
+    }
+    fn with_lifetime_parent(&self, id: ast::NodeId) -> Context {
+        Context { lifetime_parent: Some(id), ..*self }
+    }
 }
 
 struct RegionResolutionVisitor<'a> {
@@ -232,6 +253,7 @@ impl RegionMaps {
 
         let mut s = subscope;
         while superscope != s {
+            debug!("is_subscope_of({}, {}) cursor s={}", subscope, superscope, s);
             match self.scope_map.borrow().find(&s) {
                 None => {
                     debug!("is_subscope_of({}, {}, s={})=false",
@@ -375,7 +397,7 @@ fn record_superlifetime(visitor: &mut RegionResolutionVisitor,
                         child_id: ast::NodeId,
                         _sp: Span) {
     debug!("record_superlifetime(child_id={})", child_id);
-    for &parent_id in cx.parent.iter() {
+    for &parent_id in cx.lifetime_parent.iter() {
         visitor.region_maps.record_encl_scope(child_id, parent_id);
     }
 }
@@ -414,7 +436,7 @@ fn resolve_block(visitor: &mut RegionResolutionVisitor,
     //   }
     //
 
-    let subcx = Context {var_parent: Some(blk.id), parent: Some(blk.id)};
+    let subcx = Context::new(blk.id);
     visit::walk_block(visitor, blk, subcx);
 }
 
@@ -440,20 +462,17 @@ fn resolve_arm(visitor: &mut RegionResolutionVisitor,
 
     let &Arm { ref attrs, ref pats, guard, body, id } = arm;
 
-    let mut new_cx = cx;
+    // (Slightly misleading hack: using body of an arm as its span.)
+    record_superlifetime(visitor, cx, id, body.span);
+
     // The variable parent of everything inside (most importantly, the
     // pattern) is the arm.
-    new_cx.var_parent = Some(body.id);
+    let subcx = Context::new(id);
 
     for pattern in pats.iter() {
-        visitor.visit_pat(&**pattern, new_cx);
+        visitor.visit_pat(&**pattern, subcx);
     }
-    visit::walk_expr_opt(visitor, guard, new_cx);
-
-    // (Slightly misleading hack: using body of an arm as its span.)
-    record_superlifetime(visitor, cx, id, body.span);
-
-    let subcx = Context { var_parent: Some(id), parent: Some(id), };
+    visit::walk_expr_opt(visitor, guard, subcx);
 
     visitor.visit_expr(&*body, subcx);
     for attr in attrs.iter() {
@@ -488,7 +507,7 @@ fn resolve_stmt(visitor: &mut RegionResolutionVisitor,
     visitor.region_maps.mark_as_terminating_scope(stmt_id);
     record_superlifetime(visitor, cx, stmt_id, stmt.span);
 
-    let subcx = Context {parent: Some(stmt_id), ..cx};
+    let subcx = cx.with_lifetime_parent(stmt_id);
     visit::walk_stmt(visitor, stmt, subcx);
 }
 
@@ -499,8 +518,7 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor,
 
     record_superlifetime(visitor, cx, expr.id, expr.span);
 
-    let mut new_cx = cx;
-    new_cx.parent = Some(expr.id);
+    let mut new_cx = cx.with_lifetime_parent(expr.id);
     match expr.node {
         // Conditional or repeating scopes are always terminating
         // scopes, meaning that temporaries cannot outlive them.
@@ -826,9 +844,9 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor,
 
 fn resolve_item(visitor: &mut RegionResolutionVisitor,
                 item: &ast::Item,
-                cx: Context) {
+                _cx: Context) {
     // Items create a new outer block scope as far as we're concerned.
-    let new_cx = Context {var_parent: None, parent: None, ..cx};
+    let new_cx = Context::fresh();
     visit::walk_item(visitor, item, new_cx);
 }
 
@@ -842,25 +860,22 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,
     debug!("region::resolve_fn(id={}, \
                                span={:?}, \
                                body.id={}, \
-                               cx.parent={})",
+                               cx.lifetime_parent={})",
            id,
            visitor.sess.codemap().span_to_string(sp),
            body.id,
-           cx.parent);
+           cx.lifetime_parent);
 
     visitor.region_maps.mark_as_terminating_scope(body.id);
 
     // The arguments and `self` are parented to the body of the fn.
-    let decl_cx = Context {parent: Some(body.id),
-                           var_parent: Some(body.id)};
+    let decl_cx = Context::new(body.id);
     visit::walk_fn_decl(visitor, decl, decl_cx);
 
     // The body of the fn itself is either a root scope (top-level fn)
     // or it continues with the inherited scope (closures).
     let body_cx = match *fk {
-        visit::FkItemFn(..) | visit::FkMethod(..) => {
-            Context {parent: None, var_parent: None, ..cx}
-        }
+        visit::FkItemFn(..) | visit::FkMethod(..) => Context::fresh(),
         visit::FkFnBlock(..) => {
             // FIXME(#3696) -- at present we are place the closure body
             // within the region hierarchy exactly where it appears lexically.
@@ -919,7 +934,7 @@ pub fn resolve_crate(sess: &Session, krate: &ast::Crate) -> RegionMaps {
             sess: sess,
             region_maps: &maps
         };
-        let cx = Context { parent: None, var_parent: None };
+        let cx = Context::fresh();
         visit::walk_crate(&mut visitor, krate, cx);
     }
     return maps;
@@ -928,8 +943,7 @@ pub fn resolve_crate(sess: &Session, krate: &ast::Crate) -> RegionMaps {
 pub fn resolve_inlined_item(sess: &Session,
                             region_maps: &RegionMaps,
                             item: &ast::InlinedItem) {
-    let cx = Context {parent: None,
-                      var_parent: None};
+    let cx = Context::fresh();
     let mut visitor = RegionResolutionVisitor {
         sess: sess,
         region_maps: region_maps,

commit 33f9e6d6e26efd174b5417e29874424cc1a8f7f0
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Mon Jul 28 16:15:33 2014 +0200

    Hack in span support for arm's (by identifying an arm with its body, for now).
---
 src/libsyntax/ast_map/mod.rs | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/libsyntax/ast_map/mod.rs b/src/libsyntax/ast_map/mod.rs
index ac7ca11..5a04014 100644
--- a/src/libsyntax/ast_map/mod.rs
+++ b/src/libsyntax/ast_map/mod.rs
@@ -465,6 +465,7 @@ impl Map {
             Some(NodeStmt(stmt)) => stmt.span,
             Some(NodeArg(pat)) | Some(NodeLocal(pat)) => pat.span,
             Some(NodePat(pat)) => pat.span,
+            Some(NodeArm(arm)) => arm.body.span,
             Some(NodeBlock(block)) => block.span,
             Some(NodeStructCtor(_)) => self.expect_item(self.get_parent(id)).span,
             _ => return None,

commit f6c2716330c6293dc5b8ae14e4eec36cd50ba3c8
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Mon Jul 28 16:00:40 2014 +0200

    Make `var_parent` of a match arm's pattern be the match arm body.
    
    This was inspired by how `ExprForLoop` is handled; I had assumed it
    "couldn't possibly work" when I had considered it before, but
    apparently it does.  Or at least, it might.
---
 src/librustc/middle/region.rs | 9 +++++++--
 1 file changed, 7 insertions(+), 2 deletions(-)

diff --git a/src/librustc/middle/region.rs b/src/librustc/middle/region.rs
index 7b8df88..4b79416 100644
--- a/src/librustc/middle/region.rs
+++ b/src/librustc/middle/region.rs
@@ -440,10 +440,15 @@ fn resolve_arm(visitor: &mut RegionResolutionVisitor,
 
     let &Arm { ref attrs, ref pats, guard, body, id } = arm;
 
+    let mut new_cx = cx;
+    // The variable parent of everything inside (most importantly, the
+    // pattern) is the arm.
+    new_cx.var_parent = Some(body.id);
+
     for pattern in pats.iter() {
-        visitor.visit_pat(&**pattern, cx);
+        visitor.visit_pat(&**pattern, new_cx);
     }
-    visit::walk_expr_opt(visitor, guard, cx);
+    visit::walk_expr_opt(visitor, guard, new_cx);
 
     // (Slightly misleading hack: using body of an arm as its span.)
     record_superlifetime(visitor, cx, id, body.span);

commit ef85f8a9f7cf426a00f604cde699dd3af6861808
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Mon Jul 28 15:41:47 2014 +0200

    Add NodeId to `ast::Arm`.
    
    The motivation for this is to delimit the scope of bindings introduced
    by patterns on a match arm to just the expression and guard associated
    with that arm.
    
    It is possible that we may want to not to it this way, since I have a
    vague impression that the rules are going to change so that when a
    value moves into an arm's expression, the arm's guard will bind
    by-reference, which may mean it will make more sense to just have
    distinct representations for the two kinds of bindings that are
    treated independenty by rustc's analyses.
    
    But this was the easiest way to get it done in the short term.
---
 src/librustc/driver/driver.rs                |  4 ++++
 src/librustc/driver/pretty.rs                |  4 ++++
 src/librustc/middle/cfg/construct.rs         | 13 +++++++++----
 src/librustc/middle/dataflow.rs              |  3 ++-
 src/librustc/middle/expr_use_visitor.rs      |  4 ++--
 src/librustc/middle/region.rs                | 37 ++++++++++++++++++++++++++++++++-----
 src/librustc/middle/trans/_match.rs          |  2 ++
 src/librustc/middle/trans/cleanup.rs         | 22 ++++++++++++++++++++++
 src/librustc/middle/trans/expr.rs            |  2 ++
 src/librustc/middle/trans/monomorphize.rs    |  1 +
 src/librustc/middle/typeck/check/mod.rs      |  2 ++
 src/librustc/middle/typeck/check/regionck.rs |  2 ++
 src/librustc/util/ppaux.rs                   |  5 ++++-
 src/libsyntax/ast.rs                         |  3 ++-
 src/libsyntax/ast_map/mod.rs                 | 21 +++++++++++++++++++--
 src/libsyntax/ext/build.rs                   |  5 +++--
 src/libsyntax/ext/deriving/primitive.rs      |  2 ++
 src/libsyntax/ext/expand.rs                  |  7 ++++---
 src/libsyntax/fold.rs                        | 36 +++++++++++++++++++++++++++++++++---
 src/libsyntax/parse/parser.rs                |  3 ++-
 src/libsyntax/print/pprust.rs                | 42 ++++++++++++++++++++++++++++++++++++++++++
 src/libsyntax/visit.rs                       |  2 +-
 22 files changed, 196 insertions(+), 26 deletions(-)

diff --git a/src/librustc/driver/driver.rs b/src/librustc/driver/driver.rs
index c4dc7f6..b10bd84 100644
--- a/src/librustc/driver/driver.rs
+++ b/src/librustc/driver/driver.rs
@@ -906,6 +906,10 @@ impl pprust::PpAnn for IdentifiedAnnotation {
                 try!(pp::space(&mut s.s));
                 s.synth_comment(format!("pat {}", pat.id))
             }
+            pprust::NodeArm(arm) => {
+                try!(pp::space(&mut s.s));
+                s.synth_comment(format!("arm {}", arm.id))
+            }
         }
     }
 }
diff --git a/src/librustc/driver/pretty.rs b/src/librustc/driver/pretty.rs
index 8400650..f346925 100644
--- a/src/librustc/driver/pretty.rs
+++ b/src/librustc/driver/pretty.rs
@@ -218,6 +218,10 @@ impl pprust::PpAnn for IdentifiedAnnotation {
                 try!(pp::space(&mut s.s));
                 s.synth_comment(format!("pat {}", pat.id))
             }
+            pprust::Nodearm(arm) => {
+                try!(pp::space(&mut s.s));
+                s.synth_comment(format!("arm {}", arm.id))
+            }
         }
     }
 }
diff --git a/src/librustc/middle/cfg/construct.rs b/src/librustc/middle/cfg/construct.rs
index 3e076c9..75c121f 100644
--- a/src/librustc/middle/cfg/construct.rs
+++ b/src/librustc/middle/cfg/construct.rs
@@ -369,12 +369,16 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {
                 //  [guard1]   |
                 //     |       |
                 //     |       |
-                //     v 5     v
-                //  [body1]  [cond2]
+                //     v 5     |
+                //  [body1]    |
+                //     |       |
+                //     | 6     |
+                //   [arm1]    v
+                //     |     [cond2]
                 //     |      /  \
                 //     |    ...  ...
                 //     |     |    |
-                //     v 6   v    v
+                //     v 7   v    v
                 //  [.....expr.....]
                 //
                 let discr_exit = self.expr(discr.clone(), pred);         // 1
@@ -389,7 +393,8 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {
                                                    pats_exit);           // 4
                     let body_exit = self.expr(arm.body.clone(),
                                               guard_exit);               // 5
-                    self.add_contained_edge(body_exit, expr_exit);       // 6
+                    let arm_exit = self.add_node(arm.id, [body_exit]);   // 6
+                    self.add_contained_edge(arm_exit, expr_exit);        // 7
                 }
                 expr_exit
             }
diff --git a/src/librustc/middle/dataflow.rs b/src/librustc/middle/dataflow.rs
index 835798d..0e49925 100644
--- a/src/librustc/middle/dataflow.rs
+++ b/src/librustc/middle/dataflow.rs
@@ -108,7 +108,8 @@ impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O
             pprust::NodeExpr(expr) => expr.id,
             pprust::NodeBlock(blk) => blk.id,
             pprust::NodeItem(_) => 0,
-            pprust::NodePat(pat) => pat.id
+            pprust::NodePat(pat) => pat.id,
+            pprust::NodeArm(arm) => arm.id, // TODO: double-check Arm on dataflow+cfg
         };
 
         if self.has_bitset_for_nodeid(id) {
diff --git a/src/librustc/middle/expr_use_visitor.rs b/src/librustc/middle/expr_use_visitor.rs
index 15b1d3a..1e450c7 100644
--- a/src/librustc/middle/expr_use_visitor.rs
+++ b/src/librustc/middle/expr_use_visitor.rs
@@ -424,10 +424,10 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {
                 let discr_cmt = return_if_err!(self.mc.cat_expr(&**discr));
                 let mut mode = Unknown;
                 for arm in arms.iter() {
-                    self.walk_arm_prepass(discr_cmt.clone(), arm, &mut mode);
+                    self.walk_arm_prepass(discr_cmt.clone(), &**arm, &mut mode);
                 }
                 for arm in arms.iter() {
-                    self.walk_arm(discr_cmt.clone(), arm, &mode);
+                    self.walk_arm(discr_cmt.clone(), &**arm, &mode);
                 }
             }
 
diff --git a/src/librustc/middle/region.rs b/src/librustc/middle/region.rs
index 21bfcfe..7b8df88 100644
--- a/src/librustc/middle/region.rs
+++ b/src/librustc/middle/region.rs
@@ -86,9 +86,10 @@ pub struct RegionMaps {
 
 #[deriving(Clone)]
 pub struct Context {
+    /// THIS NEEDS DOCUMENTATION
     var_parent: Option<ast::NodeId>,
 
-    // Innermost enclosing expression
+    // Innermost enclosing scope (e.g. expression, match arm)
     parent: Option<ast::NodeId>,
 }
 
@@ -123,13 +124,13 @@ impl RegionMaps {
     }
 
     pub fn record_var_scope(&self, var: ast::NodeId, lifetime: ast::NodeId) {
-        debug!("record_var_scope(sub={}, sup={})", var, lifetime);
+        debug!("record_var_scope(var={}, lifetime={})", var, lifetime);
         assert!(var != lifetime);
         self.var_map.borrow_mut().insert(var, lifetime);
     }
 
     pub fn record_rvalue_scope(&self, var: ast::NodeId, lifetime: ast::NodeId) {
-        debug!("record_rvalue_scope(sub={}, sup={})", var, lifetime);
+        debug!("record_rvalue_scope(var={}, lifetime={})", var, lifetime);
         assert!(var != lifetime);
         self.rvalue_scopes.borrow_mut().insert(var, lifetime);
     }
@@ -351,7 +352,7 @@ impl RegionMaps {
 
         fn ancestors_of(this: &RegionMaps, scope: ast::NodeId)
             -> Vec<ast::NodeId> {
-            // debug!("ancestors_of(scope={})", scope);
+            debug!("ancestors_of(scope={})", scope);
             let mut result = vec!(scope);
             let mut scope = scope;
             loop {
@@ -373,6 +374,7 @@ fn record_superlifetime(visitor: &mut RegionResolutionVisitor,
                         cx: Context,
                         child_id: ast::NodeId,
                         _sp: Span) {
+    debug!("record_superlifetime(child_id={})", child_id);
     for &parent_id in cx.parent.iter() {
         visitor.region_maps.record_encl_scope(child_id, parent_id);
     }
@@ -419,6 +421,7 @@ fn resolve_block(visitor: &mut RegionResolutionVisitor,
 fn resolve_arm(visitor: &mut RegionResolutionVisitor,
                arm: &ast::Arm,
                cx: Context) {
+    debug!("resolve_arm(arm.id={})", arm.id);
     visitor.region_maps.mark_as_terminating_scope(arm.body.id);
 
     match arm.guard {
@@ -428,12 +431,35 @@ fn resolve_arm(visitor: &mut RegionResolutionVisitor,
         None => { }
     }
 
-    visit::walk_arm(visitor, arm, cx);
+    // Deliberately not invoking `visit::walk_arm(visitor, arm, cx)`.
+    // Instead, walk each component in turn below, using `cx`
+    // (carrying the parent scope) for the pattern and optional guard,
+    // and a different context for the arm's expression body, thus
+    // encoding the distinct lifetime that is established for the
+    // expression body.
+
+    let &Arm { ref attrs, ref pats, guard, body, id } = arm;
+
+    for pattern in pats.iter() {
+        visitor.visit_pat(&**pattern, cx);
+    }
+    visit::walk_expr_opt(visitor, guard, cx);
+
+    // (Slightly misleading hack: using body of an arm as its span.)
+    record_superlifetime(visitor, cx, id, body.span);
+
+    let subcx = Context { var_parent: Some(id), parent: Some(id), };
+
+    visitor.visit_expr(&*body, subcx);
+    for attr in attrs.iter() {
+        visitor.visit_attribute(attr, subcx);
+    }
 }
 
 fn resolve_pat(visitor: &mut RegionResolutionVisitor,
                pat: &ast::Pat,
                cx: Context) {
+    debug!("resolve_pat(pat.id={})", pat.id);
     record_superlifetime(visitor, cx, pat.id, pat.span);
 
     // If this is a binding (or maybe a binding, I'm too lazy to check
@@ -510,6 +536,7 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor,
         }
 
         ast::ExprMatch(..) => {
+            // Might not be needed when Arm has its own scoped NodeId.
             new_cx.var_parent = Some(expr.id);
         }
 
diff --git a/src/librustc/middle/trans/_match.rs b/src/librustc/middle/trans/_match.rs
index dd0668b..35e1acf 100644
--- a/src/librustc/middle/trans/_match.rs
+++ b/src/librustc/middle/trans/_match.rs
@@ -1376,10 +1376,12 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,
         let mut bcx = arm_data.bodycx;
 
         // insert bindings into the lllocals map and add cleanups
+        fcx.push_match_arm_cleanup_scope(arm_data.arm.id);
         let cs = fcx.push_custom_cleanup_scope();
         bcx = insert_lllocals(bcx, &arm_data.bindings_map, Some(cleanup::CustomScope(cs)));
         bcx = expr::trans_into(bcx, &*arm_data.arm.body, dest);
         bcx = fcx.pop_and_trans_custom_cleanup_scope(bcx, cs);
+        bcx = fcx.pop_and_trans_match_arm_cleanup_scope(bcx, arm_data.arm.id);
         arm_cxs.push(bcx);
     }
 
diff --git a/src/librustc/middle/trans/cleanup.rs b/src/librustc/middle/trans/cleanup.rs
index 4d54308..6370c42 100644
--- a/src/librustc/middle/trans/cleanup.rs
+++ b/src/librustc/middle/trans/cleanup.rs
@@ -144,6 +144,27 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {
 
     }
 
+    fn pop_and_trans_match_arm_cleanup_scope(&self,
+                                             bcx: &'a Block<'a>,
+                                             cleanup_scope: ast::NodeId)
+                                             -> &'a Block<'a> {
+        /*!
+         * Removes the cleanup scope for match arm with id
+         * `cleanup_scope`, which must be at the top of the cleanup
+         * stack, and generates the code to do its cleanups for normal
+         * exit.
+         */
+
+        debug!("pop_and_trans_match_arm_cleanup_scope({})",
+               self.ccx.tcx.map.node_to_string(cleanup_scope));
+
+        assert!(self.top_scope(|s| s.kind.is_ast_with_id(cleanup_scope)));
+
+        let scope = self.pop_scope();
+        self.trans_scope_cleanups(bcx, &scope)
+
+    }
+
     fn pop_loop_cleanup_scope(&self,
                               cleanup_scope: ast::NodeId) {
         /*!
@@ -1032,6 +1053,7 @@ pub trait CleanupMethods<'blk, 'tcx> {
                                    id: ast::NodeId,
                                    exits: [Block<'blk, 'tcx>, ..EXIT_MAX]);
     fn push_custom_cleanup_scope(&self) -> CustomScopeIndex;
+    fn push_match_arm_cleanup_scope(&self, id: ast::NodeId);
     fn pop_and_trans_ast_cleanup_scope(&self,
                                               bcx: Block<'blk, 'tcx>,
                                               cleanup_scope: ast::NodeId)
diff --git a/src/librustc/middle/trans/expr.rs b/src/librustc/middle/trans/expr.rs
index 0421aef..f16c6c9 100644
--- a/src/librustc/middle/trans/expr.rs
+++ b/src/librustc/middle/trans/expr.rs
@@ -980,6 +980,8 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,
             controlflow::trans_if(bcx, expr.id, &**cond, thn.clone(), els, dest)
         }
         ast::ExprMatch(ref discr, ref arms) => {
+            let arms : Vec<ast::Arm> =
+                arms.as_slice().iter().map(|x|(**x).clone()).collect();
             _match::trans_match(bcx, expr, &**discr, arms.as_slice(), dest)
         }
         ast::ExprBlock(ref blk) => {
diff --git a/src/librustc/middle/trans/monomorphize.rs b/src/librustc/middle/trans/monomorphize.rs
index 1cf3e55..12c98e4 100644
--- a/src/librustc/middle/trans/monomorphize.rs
+++ b/src/librustc/middle/trans/monomorphize.rs
@@ -270,6 +270,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,
         ast_map::NodeForeignItem(..) |
         ast_map::NodeLifetime(..) |
         ast_map::NodeExpr(..) |
+        ast_map::NodeArm(..) |
         ast_map::NodeStmt(..) |
         ast_map::NodeArg(..) |
         ast_map::NodeBlock(..) |
diff --git a/src/librustc/middle/typeck/check/mod.rs b/src/librustc/middle/typeck/check/mod.rs
index 01b5fd6..98127cb 100644
--- a/src/librustc/middle/typeck/check/mod.rs
+++ b/src/librustc/middle/typeck/check/mod.rs
@@ -3801,6 +3801,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,
         }
       }
       ast::ExprMatch(ref discrim, ref arms) => {
+        let arms : Vec<ast::Arm> =
+            arms.as_slice().iter().map(|x|(**x).clone()).collect();
         _match::check_match(fcx, expr, &**discrim, arms.as_slice());
       }
       ast::ExprFnBlock(_, ref decl, ref body) => {
diff --git a/src/librustc/middle/typeck/check/regionck.rs b/src/librustc/middle/typeck/check/regionck.rs
index 33e4f87..d3449c7 100644
--- a/src/librustc/middle/typeck/check/regionck.rs
+++ b/src/librustc/middle/typeck/check/regionck.rs
@@ -732,6 +732,8 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {
         }
 
         ast::ExprMatch(ref discr, ref arms) => {
+            let arms : Vec<ast::Arm>
+                = arms.as_slice().iter().map(|x|(**x).clone()).collect();
             link_match(rcx, &**discr, arms.as_slice());
 
             visit::walk_expr(rcx, expr, ());
diff --git a/src/librustc/util/ppaux.rs b/src/librustc/util/ppaux.rs
index 11f16f1..3f8ec41 100644
--- a/src/librustc/util/ppaux.rs
+++ b/src/librustc/util/ppaux.rs
@@ -105,9 +105,12 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)
               let tag = item_scope_tag(&*it);
               explain_span(cx, tag, it.span)
           }
+          Some(ast_map::NodeArm(arm)) => {
+              explain_span(cx, "match arm", arm.body.span)
+          }
           Some(_) | None => {
             // this really should not happen
-            (format!("unknown scope: {}.  Please report a bug.", node_id), None)
+            fail!("unknown scope: {}.  Please report a bug.", node_id)
           }
         }
       }
diff --git a/src/libsyntax/ast.rs b/src/libsyntax/ast.rs
index 68a1c52..369a909 100644
--- a/src/libsyntax/ast.rs
+++ b/src/libsyntax/ast.rs
@@ -477,6 +477,7 @@ pub enum Decl_ {
 /// represents one arm of a 'match'
 #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]
 pub struct Arm {
+    pub id: NodeId,
     pub attrs: Vec<Attribute>,
     pub pats: Vec<Gc<Pat>>,
     pub guard: Option<Gc<Expr>>,
@@ -531,7 +532,7 @@ pub enum Expr_ {
     // Conditionless loop (can be exited with break, cont, or ret)
     // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.
     ExprLoop(P<Block>, Option<Ident>),
-    ExprMatch(Gc<Expr>, Vec<Arm>),
+    ExprMatch(Gc<Expr>, Vec<Gc<Arm>>),
     ExprFnBlock(CaptureClause, P<FnDecl>, P<Block>),
     ExprProc(P<FnDecl>, P<Block>),
     ExprUnboxedFn(CaptureClause, UnboxedClosureKind, P<FnDecl>, P<Block>),
diff --git a/src/libsyntax/ast_map/mod.rs b/src/libsyntax/ast_map/mod.rs
index d1f78c7..ac7ca11 100644
--- a/src/libsyntax/ast_map/mod.rs
+++ b/src/libsyntax/ast_map/mod.rs
@@ -108,6 +108,7 @@ pub enum Node {
     NodeLocal(Gc<Pat>),
     NodePat(Gc<Pat>),
     NodeBlock(P<Block>),
+    NodeArm(Gc<Arm>),
 
     /// NodeStructCtor represents a tuple struct.
     NodeStructCtor(Gc<StructDef>),
@@ -134,6 +135,7 @@ enum MapEntry {
     EntryLocal(NodeId, Gc<Pat>),
     EntryPat(NodeId, Gc<Pat>),
     EntryBlock(NodeId, P<Block>),
+    EntryArm(NodeId, Gc<Arm>),
     EntryStructCtor(NodeId, Gc<StructDef>),
     EntryLifetime(NodeId, Gc<Lifetime>),
 
@@ -161,10 +163,11 @@ impl MapEntry {
             EntryArg(id, _) => id,
             EntryLocal(id, _) => id,
             EntryPat(id, _) => id,
+            EntryArm(id, _) => id,
             EntryBlock(id, _) => id,
             EntryStructCtor(id, _) => id,
             EntryLifetime(id, _) => id,
-            _ => return None
+            NotPresent | RootCrate | RootInlinedParent(_) => return None,
         })
     }
 
@@ -181,9 +184,10 @@ impl MapEntry {
             EntryLocal(_, p) => NodeLocal(p),
             EntryPat(_, p) => NodePat(p),
             EntryBlock(_, p) => NodeBlock(p),
+            EntryArm(_, p) => NodeArm(p),
             EntryStructCtor(_, p) => NodeStructCtor(p),
             EntryLifetime(_, p) => NodeLifetime(p),
-            _ => return None
+            NotPresent | RootCrate | RootInlinedParent(_) => return None,
         })
     }
 }
@@ -620,6 +624,7 @@ pub struct Ctx<'a, F> {
 impl<'a, F> Ctx<'a, F> {
     fn insert(&self, id: NodeId, entry: MapEntry) {
         (*self.map.map.borrow_mut()).grow_set(id as uint, &NotPresent, entry);
+        debug!("ast_map::Ctx.insert({}, {:s})", id, node_id_to_string(self.map, id));
     }
 }
 
@@ -722,6 +727,14 @@ impl<'a, F: FoldOps> Folder for Ctx<'a, F> {
         expr
     }
 
+    fn fold_arm(&mut self, arm: Gc<Arm>) -> Gc<Arm> {
+        let arm = fold::noop_fold_arm(arm, self);
+
+        self.insert(arm.id, EntryArm(self.parent, arm));
+
+        arm
+    }
+
     fn fold_stmt(&mut self, stmt: &Stmt) -> SmallVector<Gc<Stmt>> {
         let stmt = fold::noop_fold_stmt(stmt, self).expect_one("expected one statement");
         self.insert(ast_util::stmt_id(&*stmt), EntryStmt(self.parent, stmt));
@@ -744,6 +757,7 @@ impl<'a, F: FoldOps> Folder for Ctx<'a, F> {
             "noop_fold_method must produce exactly one method");
         assert_eq!(self.parent, m.id);
         self.parent = parent;
+        self.insert(m.id, EntryMethod(self.parent, m));
         SmallVector::one(m)
     }
 
@@ -946,6 +960,9 @@ fn node_id_to_string(map: &Map, id: NodeId) -> String {
         Some(NodePat(ref pat)) => {
             format!("pat {} (id={})", pprust::pat_to_string(&**pat), id)
         }
+        Some(NodeArm(ref arm)) => {
+            format!("arm {} (id={})", pprust::arm_to_string(&**arm), id)
+        }
         Some(NodeBlock(ref block)) => {
             format!("block {} (id={})", pprust::block_to_string(&**block), id)
         }
diff --git a/src/libsyntax/ext/build.rs b/src/libsyntax/ext/build.rs
index 64ab0e5..0d679bb 100644
--- a/src/libsyntax/ext/build.rs
+++ b/src/libsyntax/ext/build.rs
@@ -852,7 +852,8 @@ impl<'a> AstBuilder for ExtCtxt<'a> {
             attrs: vec!(),
             pats: pats,
             guard: None,
-            body: expr
+            body: expr,
+            id: ast::DUMMY_NODE_ID,
         }
     }
 
@@ -862,7 +863,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {
 
     fn expr_match(&self, span: Span, arg: Gc<ast::Expr>,
                   arms: Vec<ast::Arm>) -> Gc<Expr> {
-        self.expr(span, ast::ExprMatch(arg, arms))
+        self.expr(span, ast::ExprMatch(arg, arms.move_iter().map(|x| box(GC)x).collect()))
     }
 
     fn expr_if(&self, span: Span,
diff --git a/src/libsyntax/ext/deriving/primitive.rs b/src/libsyntax/ext/deriving/primitive.rs
index 30dd8e9..20c5bdd 100644
--- a/src/libsyntax/ext/deriving/primitive.rs
+++ b/src/libsyntax/ext/deriving/primitive.rs
@@ -118,6 +118,7 @@ fn cs_from(name: &str, cx: &mut ExtCtxt, trait_span: Span,
                             pats: vec!(cx.pat_wild(span)),
                             guard: Some(guard),
                             body: body,
+                            id: ast::DUMMY_NODE_ID,
                         };
 
                         arms.push(arm);
@@ -138,6 +139,7 @@ fn cs_from(name: &str, cx: &mut ExtCtxt, trait_span: Span,
                 pats: vec!(cx.pat_wild(trait_span)),
                 guard: None,
                 body: cx.expr_none(trait_span),
+                id: ast::DUMMY_NODE_ID,
             };
             arms.push(arm);
 
diff --git a/src/libsyntax/ext/expand.rs b/src/libsyntax/ext/expand.rs
index d0f3cf6..5e6894c 100644
--- a/src/libsyntax/ext/expand.rs
+++ b/src/libsyntax/ext/expand.rs
@@ -614,7 +614,7 @@ fn expand_non_macro_stmt(s: &Stmt, fld: &mut MacroExpander)
 }
 
 // expand the arm of a 'match', renaming for macro hygiene
-fn expand_arm(arm: &ast::Arm, fld: &mut MacroExpander) -> ast::Arm {
+fn expand_arm(arm: &ast::Arm, fld: &mut MacroExpander) -> Gc<ast::Arm> {
     // expand pats... they might contain macro uses:
     let expanded_pats : Vec<Gc<ast::Pat>> = arm.pats.iter().map(|pat| fld.fold_pat(*pat)).collect();
     if expanded_pats.len() == 0 {
@@ -635,11 +635,12 @@ fn expand_arm(arm: &ast::Arm, fld: &mut MacroExpander) -> ast::Arm {
     let rewritten_guard =
         arm.guard.map(|g| fld.fold_expr(rename_fld.fold_expr(g)));
     let rewritten_body = fld.fold_expr(rename_fld.fold_expr(arm.body));
-    ast::Arm {
+    box(GC) ast::Arm {
         attrs: arm.attrs.iter().map(|x| fld.fold_attribute(*x)).collect(),
         pats: rewritten_pats,
         guard: rewritten_guard,
         body: rewritten_body,
+        id: arm.id,
     }
 }
 
@@ -949,7 +950,7 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {
         expand_block(&*block, self)
     }
 
-    fn fold_arm(&mut self, arm: &ast::Arm) -> ast::Arm {
+    fn fold_arm(&mut self, arm: Gc<ast::Arm>) -> Gc<ast::Arm> {
         expand_arm(arm, self)
     }
 
diff --git a/src/libsyntax/fold.rs b/src/libsyntax/fold.rs
index 7deabed..86d5c29 100644
--- a/src/libsyntax/fold.rs
+++ b/src/libsyntax/fold.rs
@@ -319,7 +319,9 @@ pub fn noop_fold_view_path<T: Folder>(view_path: Gc<ViewPath>, fld: &mut T) -> G
 }
 
 pub fn noop_fold_arm<T: Folder>(a: &Arm, fld: &mut T) -> Arm {
+    let id = fld.new_id(a.id);
     Arm {
+        id: id,
         attrs: a.attrs.iter().map(|x| fld.fold_attribute(*x)).collect(),
         pats: a.pats.iter().map(|x| fld.fold_pat(*x)).collect(),
         guard: a.guard.map(|x| fld.fold_expr(x)),
@@ -553,6 +555,7 @@ pub fn noop_fold_meta_item<T: Folder>(mi: &MetaItem, fld: &mut T) -> MetaItem {
 
 pub fn noop_fold_arg<T: Folder>(a: &Arg, fld: &mut T) -> Arg {
     let id = fld.new_id(a.id); // Needs to be first, for ast_map.
+    debug!("fold_arg_, id: {}", id);
     Arg {
         id: id,
         ty: fld.fold_ty(a.ty),
@@ -665,6 +668,7 @@ pub fn noop_fold_ty_param_bound<T: Folder>(tpb: &TyParamBound, fld: &mut T)
 
 pub fn noop_fold_ty_param<T: Folder>(tp: &TyParam, fld: &mut T) -> TyParam {
     let id = fld.new_id(tp.id);
+    debug!("fold_ty_param, id: {}", id);
     TyParam {
         ident: tp.ident,
         id: id,
@@ -682,6 +686,7 @@ pub fn noop_fold_ty_params<T: Folder>(tps: &[TyParam], fld: &mut T)
 
 pub fn noop_fold_lifetime<T: Folder>(l: &Lifetime, fld: &mut T) -> Lifetime {
     let id = fld.new_id(l.id);
+    debug!("noop_fold_lifetime, id: {}", id);
     Lifetime {
         id: id,
         span: fld.new_span(l.span),
@@ -760,6 +765,7 @@ pub fn noop_fold_struct_def<T: Folder>(struct_def: Gc<StructDef>,
 
 pub fn noop_fold_trait_ref<T: Folder>(p: &TraitRef, fld: &mut T) -> TraitRef {
     let id = fld.new_id(p.ref_id);
+    debug!("fold_trait_ref, id: {}", id);
     ast::TraitRef {
         path: fld.fold_path(&p.path),
         ref_id: id,
@@ -768,6 +774,7 @@ pub fn noop_fold_trait_ref<T: Folder>(p: &TraitRef, fld: &mut T) -> TraitRef {
 
 pub fn noop_fold_struct_field<T: Folder>(f: &StructField, fld: &mut T) -> StructField {
     let id = fld.new_id(f.node.id);
+    debug!("fold_struct_field, id: {}", id);
     Spanned {
         node: ast::StructField_ {
             kind: f.node.kind,
@@ -806,6 +813,7 @@ fn noop_fold_bounds<T: Folder>(bounds: &TyParamBounds, folder: &mut T)
 
 pub fn noop_fold_variant_arg<T: Folder>(va: &VariantArg, folder: &mut T) -> VariantArg {
     let id = folder.new_id(va.id);
+    debug!("fold_variant_arg_, id: {}", id);
     ast::VariantArg {
         ty: folder.fold_ty(va.ty),
         id: id,
@@ -834,6 +842,7 @@ pub fn noop_fold_view_item<T: Folder>(vi: &ViewItem, folder: &mut T)
 
 pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {
     let id = folder.new_id(b.id); // Needs to be first, for ast_map.
+    debug!("noop_fold_block, id: {}", id);
     let view_items = b.view_items.iter().map(|x| folder.fold_view_item(x)).collect();
     let stmts = b.stmts.iter().flat_map(|s| folder.fold_stmt(&**s).move_iter()).collect();
     P(Block {
@@ -926,6 +935,7 @@ pub fn noop_fold_item_underscore<T: Folder>(i: &Item_, folder: &mut T) -> Item_
 
 pub fn noop_fold_type_method<T: Folder>(m: &TypeMethod, fld: &mut T) -> TypeMethod {
     let id = fld.new_id(m.id); // Needs to be first, for ast_map.
+    debug!("noop_fold_type_method, id: {}", id);
     TypeMethod {
         id: id,
         ident: fld.fold_ident(m.ident),
@@ -970,6 +980,7 @@ pub fn noop_fold_item<T: Folder>(i: &Item,
 // fold one item into exactly one item
 pub fn noop_fold_item_simple<T: Folder>(i: &Item, folder: &mut T) -> Item {
     let id = folder.new_id(i.id); // Needs to be first, for ast_map.
+    debug!("noop_fold_item_, id: {}", id);
     let node = folder.fold_item_underscore(&i.node);
     let ident = match node {
         // The node may have changed, recompute the "pretty" impl name.
@@ -992,6 +1003,7 @@ pub fn noop_fold_item_simple<T: Folder>(i: &Item, folder: &mut T) -> Item {
 pub fn noop_fold_foreign_item<T: Folder>(ni: &ForeignItem,
                                          folder: &mut T) -> Gc<ForeignItem> {
     let id = folder.new_id(ni.id); // Needs to be first, for ast_map.
+    debug!("noop_fold_foreign_item, id: {}", id);
     box(GC) ForeignItem {
         id: id,
         ident: folder.fold_ident(ni.ident),
@@ -1018,6 +1030,7 @@ pub fn noop_fold_foreign_item<T: Folder>(ni: &ForeignItem,
 // Invariant: produces exactly one method.
 pub fn noop_fold_method<T: Folder>(m: &Method, folder: &mut T) -> SmallVector<Gc<Method>> {
     let id = folder.new_id(m.id); // Needs to be first, for ast_map.
+    debug!("noop_fold_method, id: {}", id);
     SmallVector::one(box(GC) Method {
         attrs: m.attrs.iter().map(|a| folder.fold_attribute(*a)).collect(),
         id: id,
@@ -1046,7 +1059,8 @@ pub fn noop_fold_method<T: Folder>(m: &Method, folder: &mut T) -> SmallVector<Gc
 }
 
 pub fn noop_fold_pat<T: Folder>(p: Gc<Pat>, folder: &mut T) -> Gc<Pat> {
-    let id = folder.new_id(p.id);
+    let id = folder.new_id(p.id); // Needs to be first, for ast_map.
+    debug!("noop_fold_pat, id: {}", id);
     let node = match p.node {
         PatWild(k) => PatWild(k),
         PatIdent(binding_mode, ref pth1, ref sub) => {
@@ -1092,7 +1106,8 @@ pub fn noop_fold_pat<T: Folder>(p: Gc<Pat>, folder: &mut T) -> Gc<Pat> {
 }
 
 pub fn noop_fold_expr<T: Folder>(e: Gc<Expr>, folder: &mut T) -> Gc<Expr> {
-    let id = folder.new_id(e.id);
+    let id = folder.new_id(e.id); // Needs to be first, for ast_map.
+    debug!("noop_fold_expr, id: {}", id);
     let node = match e.node {
         ExprBox(p, e) => {
             ExprBox(folder.fold_expr(p), folder.fold_expr(e))
@@ -1149,7 +1164,7 @@ pub fn noop_fold_expr<T: Folder>(e: Gc<Expr>, folder: &mut T) -> Gc<Expr> {
         }
         ExprMatch(expr, ref arms) => {
             ExprMatch(folder.fold_expr(expr),
-                      arms.iter().map(|x| folder.fold_arm(x)).collect())
+                      arms.iter().map(|&x| folder.fold_arm(x)).collect())
         }
         ExprFnBlock(capture_clause, ref decl, ref body) => {
             ExprFnBlock(capture_clause,
@@ -1221,16 +1236,19 @@ pub fn noop_fold_stmt<T: Folder>(s: &Stmt,
     let nodes = match s.node {
         StmtDecl(d, id) => {
             let id = folder.new_id(id);
+            debug!("noop_fold_stmt, id: {} StmtDecl", id);
             folder.fold_decl(d).move_iter()
                     .map(|d| StmtDecl(d, id))
                     .collect()
         }
         StmtExpr(e, id) => {
             let id = folder.new_id(id);
+            debug!("noop_fold_stmt, id: {} StmtExpr", id);
             SmallVector::one(StmtExpr(folder.fold_expr(e), id))
         }
         StmtSemi(e, id) => {
             let id = folder.new_id(id);
+            debug!("noop_fold_stmt, id: {} StmtSemi", id);
             SmallVector::one(StmtSemi(folder.fold_expr(e), id))
         }
         StmtMac(ref mac, semi) => SmallVector::one(StmtMac(folder.fold_mac(mac), semi))
@@ -1242,6 +1260,18 @@ pub fn noop_fold_stmt<T: Folder>(s: &Stmt,
     }).collect()
 }
 
+pub fn noop_fold_arm<T: Folder>(a: Gc<Arm>, folder: &mut T) -> Gc<Arm> {
+    let id = folder.new_id(a.id);
+    debug!("noop_fold_arm, id: {}", id);
+    box(GC) Arm {
+        attrs: a.attrs.iter().map(|x| folder.fold_attribute(*x)).collect(),
+        pats: a.pats.iter().map(|x| folder.fold_pat(*x)).collect(),
+        guard: a.guard.map(|x| folder.fold_expr(x)),
+        body: folder.fold_expr(a.body),
+        id: id,
+    }
+}
+
 #[cfg(test)]
 mod test {
     use std::io;
diff --git a/src/libsyntax/parse/parser.rs b/src/libsyntax/parse/parser.rs
index 936cabc..cba5ff2 100644
--- a/src/libsyntax/parse/parser.rs
+++ b/src/libsyntax/parse/parser.rs
@@ -2777,7 +2777,7 @@ impl<'a> Parser<'a> {
         let lo = self.last_span.lo;
         let discriminant = self.parse_expr_res(RESTRICT_NO_STRUCT_LITERAL);
         self.commit_expr_expecting(discriminant, token::LBRACE);
-        let mut arms: Vec<Arm> = Vec::new();
+        let mut arms: Vec<Gc<Arm>> = Vec::new();
         while self.token != token::RBRACE {
             arms.push(self.parse_arm());
         }
@@ -2811,6 +2811,7 @@ impl<'a> Parser<'a> {
             pats: pats,
             guard: guard,
             body: expr,
+            id: ast::DUMMY_NODE_ID,
         }
     }
 
diff --git a/src/libsyntax/print/pprust.rs b/src/libsyntax/print/pprust.rs
index d5bc1bf..76955c3 100644
--- a/src/libsyntax/print/pprust.rs
+++ b/src/libsyntax/print/pprust.rs
@@ -39,6 +39,7 @@ pub enum AnnNode<'a> {
     NodeItem(&'a ast::Item),
     NodeExpr(&'a ast::Expr),
     NodePat(&'a ast::Pat),
+    NodeArm(&'a ast::Arm),
 }
 
 pub trait PpAnn {
@@ -197,6 +198,10 @@ pub fn arm_to_string(arm: &ast::Arm) -> String {
     $to_string(|s| s.print_arm(arm))
 }
 
+pub fn arm_to_string(arm: &ast::Arm) -> String {
+    to_string(|s| s.print_arm(arm))
+}
+
 pub fn expr_to_string(e: &ast::Expr) -> String {
     $to_string(|s| s.print_expr(e))
 }
@@ -1817,6 +1822,43 @@ impl<'a> State<'a> {
         self.print_path_(path, false, bounds)
     }
 
+    pub fn print_arm(&mut self, arm: &ast::Arm) -> IoResult<()> {
+        try!(self.cbox(indent_unit));
+        try!(self.ibox(0u));
+        try!(self.print_outer_attributes(arm.attrs.as_slice()));
+        let mut first = true;
+        for p in arm.pats.iter() {
+            if first {
+                first = false;
+            } else {
+                try!(space(&mut self.s));
+                try!(self.word_space("|"));
+            }
+            try!(self.print_pat(&**p));
+        }
+        try!(space(&mut self.s));
+        match arm.guard {
+            Some(ref e) => {
+                try!(self.word_space("if"));
+                try!(self.print_expr(&**e));
+                try!(space(&mut self.s));
+            }
+            None => ()
+        }
+        try!(self.word_space("=>"));
+
+        match arm.body.node {
+            ast::ExprBlock(ref blk) => {
+                // the block will close the pattern's ibox
+                self.print_block_unclosed_indent(&**blk, indent_unit)
+            }
+            _ => {
+                try!(self.end()); // close the ibox for the pattern
+                self.print_expr(&*arm.body)
+            }
+        }
+    }
+
     pub fn print_pat(&mut self, pat: &ast::Pat) -> IoResult<()> {
         try!(self.maybe_print_comment(pat.span.lo));
         try!(self.ann.pre(self, NodePat(pat)));
diff --git a/src/libsyntax/visit.rs b/src/libsyntax/visit.rs
index 65e192e..c11eb98 100644
--- a/src/libsyntax/visit.rs
+++ b/src/libsyntax/visit.rs
@@ -788,7 +788,7 @@ pub fn walk_expr<E: Clone, V: Visitor<E>>(visitor: &mut V, expression: &Expr, en
         ExprMatch(ref subexpression, ref arms) => {
             visitor.visit_expr(&**subexpression, env.clone());
             for arm in arms.iter() {
-                visitor.visit_arm(arm, env.clone())
+                visitor.visit_arm(&**arm, env.clone())
             }
         }
         ExprFnBlock(_, ref function_declaration, ref body) => {

commit c5e48c48a3c697b0b9a2bbecce086e845c410300
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Mon Jul 28 14:41:15 2014 +0200

    root testsuite
    
    another test file in root.
    
    more tests in the local root.
    
    revised iter2 root example to fit mold of other root unit tests.
    
    root Makefile: Revised %.log target to cover trans-based codegen as well.
    
    Added another file to the root unit tests.
    
    root testsuite: More revisions to the root unit test suite.
    
    smaller test case derived from dlist example
    
    root unit tests: proc test case.
    
    Add some tests for how nesting of join-points is handled.
    
    root testsuite: Add comment since I no longer understand what I was
    testing/expecting in one case.
    
    ----
    
    add comments elaborating what I expect to happen.
    
    I know in particular that an earlier bug for this case led to the
    merge points not being equal, because the `self_.value = node`
    assignment was being treated as establishing a drop-obligation, even
    though that path has a `&mut`-reference in the middle, which means
    such assignments do not yield immediate drop obligations.
    
    ----
    
    Updates to the root testsuite.
    
    In particular I am trying to fine-tune how `_` wildcard is handled,
    which in my scheme will be context-dependent on the overall pattern,
    in terms of whether it can introduce an implicitly handled
    drop-obligation (from being in a match by-move context), or if it is
    just an "ignore" (from being in a match by-ref context).
    
    ----
    
    root testsuite: separate-but-equal treatment for match arms.
    
    root testsuite: better doc for what foo19.rs is doing.
    
    root testsuite: Update foo19 to reflect separate-but-equal arms.
    
    root testsuite: Address a number of warnings to ease reading output.
    
    root testsuite: Updated foo*.rs to be robust against new scope-end fwd-scan.
    
    root testsuite: Some generalization to make clear the distinction i am drawing
    between a return statement and the final expression.
    
    root testsuite: add the test for scope-end fwd-scan.
    
    Note that this test is somewhat thorough in that it covers `if`-expr,
    a `while`-loop and a `return` statement.  I should probably make tests
    for `loop`, `for`-loop and uses of `break` within loops.
    
    root testsuite: made some quick Gc<T> tests.
    
    These worked out of the box, which I guess is not surprising, except
    that I had thought that these were the cause of our many warnings when
    I had previously attempted to bootstrap libsyntax.
    
    root testsuite: add more cases for Box<T> and Gc<T>.
    
    Note: foo29.rs exposes the case that prompted my switch to
    `moves_by_default`.
    
    Note: foo28.rs shows a case that is currently mishanded by the
    fragment sibling code.  Still needs fixing.
    
    root testsuite: multiple match pats in one arm behave weird at moment.
    
    A new test: the two occurrences of `b` are treated as distinct
    variable bases for loan_paths, which is currently causing me some
    grief.
    
    (Is there some normalization function to unify them that I am
    overlooking?  How else does this represent references to `b` in the
    "common" body?)
    
    root testsuite: added resolve to the set of logging output.
    
    root testsuite: renamed files to reflect expectations about whether I should see warnings or not.
    
    root testsuite: fix `fine` and `warn` targets to force rebuilds.
    
    root testsuite: Add test case for fragmenting behind a boxed ptr.
    
    root testsuite: Took a stab at what I might have actually been thinking of for foo13.rs.
    
    root testsuite: add `foo32_fine.rs` to test suite.  It is an attempt
    to identify a case where I need the dont-care dataflow analysis.
    
    root testsuite: add test for Box<T> and interior array handling.
    
    root testsuite: added narrowed instances of struct-like enum variants.
    
    root testsuite: fix foo36/foo37 tests to use `foo` as function name.
---
 Makefile      | 46 ++++++++++++++++++++++++++++++++++++++++++----
 dlist01.rs    | 69 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 foo01_warn.rs | 21 +++++++++++++++++++++
 foo02_fine.rs | 23 +++++++++++++++++++++++
 foo03_warn.rs | 24 ++++++++++++++++++++++++
 foo04_warn.rs | 26 ++++++++++++++++++++++++++
 foo05_warn.rs | 24 ++++++++++++++++++++++++
 foo06_warn.rs | 26 ++++++++++++++++++++++++++
 foo07_warn.rs | 25 +++++++++++++++++++++++++
 foo08_warn.rs | 29 +++++++++++++++++++++++++++++
 foo09_warn.rs | 26 ++++++++++++++++++++++++++
 foo1.rs       | 18 ------------------
 foo10.rs      | 23 -----------------------
 foo10_warn.rs | 26 ++++++++++++++++++++++++++
 foo11.rs      | 24 ------------------------
 foo11_fine.rs | 27 +++++++++++++++++++++++++++
 foo12.rs      | 24 ------------------------
 foo12_fine.rs | 27 +++++++++++++++++++++++++++
 foo13.rs      | 29 -----------------------------
 foo13_fine.rs | 38 ++++++++++++++++++++++++++++++++++++++
 foo14_fine.rs | 22 ++++++++++++++++++++++
 foo15_fine.rs | 34 ++++++++++++++++++++++++++++++++++
 foo16.rs      | 46 ++++++++++++++++++++++++++++++++++++++++++++++
 foo17_warn.rs | 40 ++++++++++++++++++++++++++++++++++++++++
 foo18_warn.rs | 41 +++++++++++++++++++++++++++++++++++++++++
 foo19.rs      | 29 +++++++++++++++++++++++++++++
 foo2.rs       | 20 --------------------
 foo20.rs      | 12 ++++++++++++
 foo21.rs      | 19 +++++++++++++++++++
 foo22.rs      | 34 ++++++++++++++++++++++++++++++++++
 foo23_fine.rs | 35 +++++++++++++++++++++++++++++++++++
 foo24_fine.rs | 36 ++++++++++++++++++++++++++++++++++++
 foo25_warn.rs | 29 +++++++++++++++++++++++++++++
 foo26_warn.rs | 31 +++++++++++++++++++++++++++++++
 foo27_warn.rs | 31 +++++++++++++++++++++++++++++++
 foo28_warn.rs | 31 +++++++++++++++++++++++++++++++
 foo29_fine.rs | 40 ++++++++++++++++++++++++++++++++++++++++
 foo3.rs       | 21 ---------------------
 foo30_fine.rs | 26 ++++++++++++++++++++++++++
 foo31_warn.rs | 31 +++++++++++++++++++++++++++++++
 foo32_fine.rs | 21 +++++++++++++++++++++
 foo33_fine.rs | 41 +++++++++++++++++++++++++++++++++++++++++
 foo34_fine.rs | 41 +++++++++++++++++++++++++++++++++++++++++
 foo35_fine.rs | 47 +++++++++++++++++++++++++++++++++++++++++++++++
 foo36.rs      | 79 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 foo37.rs      | 88 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 foo4.rs       | 23 -----------------------
 foo5.rs       | 21 ---------------------
 foo6.rs       | 23 -----------------------
 foo7.rs       | 22 ----------------------
 foo8.rs       | 26 --------------------------
 iter2.rs      | 65 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 num01.rs      | 23 +++++++++++++++++++++++
 option01.rs   | 22 ++++++++++++++++++++++
 result01.rs   | 18 ++++++++++++++++++
 result02.rs   | 18 ++++++++++++++++++
 result03.rs   | 24 ++++++++++++++++++++++++
 str01.rs      | 55 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 str02.rs      | 61 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 59 files changed, 1623 insertions(+), 278 deletions(-)

diff --git a/Makefile b/Makefile
index 8c8a62c..f3c4d13 100644
--- a/Makefile
+++ b/Makefile
@@ -1,8 +1,39 @@
-FILES=foo1.rs foo2.rs foo3.rs foo4.rs foo5.rs foo6.rs foo7.rs foo8.rs \
-      foo11.rs foo12.rs \
-      iter1.rs
+FILES_WARN=foo01_warn.rs               foo03_warn.rs foo04_warn.rs foo05_warn.rs \
+           foo06_warn.rs foo07_warn.rs foo08_warn.rs foo09_warn.rs foo10_warn.rs \
+                         foo17_warn.rs foo18_warn.rs                             \
+                                                                   foo25_warn.rs \
+           foo26_warn.rs foo27_warn.rs foo28_warn.rs                             \
+           foo31_warn.rs
+
+FILES_FINE=              foo02_fine.rs                                           \
+           foo11_fine.rs foo12_fine.rs foo13_fine.rs foo14_fine.rs foo15_fine.rs \
+                                       foo23_fine.rs foo24_fine.rs               \
+                                                     foo29_fine.rs foo30_fine.rs \
+                         foo32_fine.rs foo33_fine.rs foo34_fine.rs
+
+FILES_UNCATEGORIZED=                                                             \
+           foo16.rs                                  foo19.rs      foo20.rs      \
+           foo21.rs      foo22.rs                                                \
+           dlist01.rs \
+           iter1.rs iter2.rs \
+           num01.rs \
+           option01.rs \
+           result01.rs result02.rs result03.rs \
+           str01.rs
+
+FILES=$(FILES_WARN) $(FILES_FINE) $(FILES_UNCATEGORIZED)
 
 all: $(patsubst %.rs,%.dot,$(FILES))
+.PHONY: touch_fine
+touch_fine:
+	touch *fine.rs
+.PHONY: touch_warn
+touch_warn:
+	touch *warn.rs
+.PHONY: fine
+fine: touch_fine $(patsubst %.rs,%.dot,$(FILES_FINE))
+.PHONY: warn
+warn: touch_warn $(patsubst %.rs,%.dot,$(FILES_WARN))
 
 RUSTC_LIB=$(RUSTC) --crate-type=lib
 
@@ -16,8 +47,15 @@ objdir-dbg/x86_64-apple-darwin/stage1/rustc: src/etc/rustc-wrapper.macosx.sh obj
 	cp $< $@
 	chmod +x $@
 
+RUST_LOG=rustc::middle::borrowck,rustc::middle::ty,rustc::middle::typeck,rustc::middle::expr_use_visitor,rustc::middle::region,rustc::middle::trans,rustc::middle::resolve,rustc::middle::mem_categorization
+
 %.dot: %.rs Makefile objdir-dbg/x86_64-apple-darwin/stage1/rustc
 	$(RUSTC_LIB) -Z flowgraph-print-all --pretty flowgraph=foo $< -o $@
 
+%.pp: %.rs Makefile objdir-dbg/x86_64-apple-darwin/stage1/rustc
+	$(RUSTC_LIB)                        --pretty expanded,identified $< -o $@
+
 %.log: %.rs Makefile objdir-dbg/x86_64-apple-darwin/stage1/rustc
-	RUST_LOG=rustc::middle::borrowck,rustc::middle::ty,rustc::middle::typeck,rustc::middle::expr_use_visitor  $(RUSTC_LIB) -Z flowgraph-print-all --pretty flowgraph=foo $< -o $@.dot 2> $@
+	RUST_LOG=$(RUST_LOG) RUST_BACKTRACE=1 $(RUSTC_LIB) $< 2> $@
+
+#	RUST_LOG=$(RUST_LOG) $(RUSTC_LIB) -Z flowgraph-print-all --pretty flowgraph=foo $< -o $@.dot 2> $@
diff --git a/dlist01.rs b/dlist01.rs
new file mode 100644
index 0000000..33ca286
--- /dev/null
+++ b/dlist01.rs
@@ -0,0 +1,69 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+#[lang = "owned_box"]
+#[unstable = "custom allocators will add an additional type parameter (with default)"]
+pub struct Box<T>(*mut T);
+
+mod mem {
+    pub fn replace<T>(_dest: &mut T, mut _src: T) -> T { loop { } }
+}
+
+pub fn drop<T>(_x: T) { }
+
+pub enum Option<T> { None, Some(T), }
+
+impl<T> Option<T> {
+    pub fn take(&mut self) -> Option<T> {
+        mem::replace(self, None)
+    }
+    pub fn map<U>(self, f: |T| -> U) -> Option<U> {
+        match self { Some(x) => Some(f(x)), None => None }
+    }
+}
+
+/// Set the .prev field on `next`, then return `Some(next)`
+fn link_with_prev<T>(mut next: Box<Node<T>>, prev: Rawlink<Node<T>>)
+                  -> Link<T> {
+    next.prev = prev;
+    Some(next)
+}
+
+/// A doubly-linked list.
+pub struct DList<T> {
+    length: uint,
+    list_head: Link<T>,
+    list_tail: Rawlink<Node<T>>,
+}
+
+type Link<T> = Option<Box<Node<T>>>;
+pub struct Rawlink<T>;
+
+pub struct Node<T> {
+    next: Link<T>,
+    prev: Rawlink<Node<T>>,
+}
+
+impl<T> Rawlink<T> {
+    fn none() -> Rawlink<T> {
+        Rawlink
+    }
+}
+
+impl<T> DList<T> {
+    /// Remove the first Node and return it, or None if the list is empty
+    pub fn foo(&mut self) -> Option<Box<Node<T>>> {
+        self.list_head.take().map(|mut front_node| {
+            self.length -= 1;
+            match front_node.next.take() {
+                Some(node) => self.list_head = link_with_prev(node, Rawlink::none()),
+                None => self.list_tail = Rawlink::none()
+            }
+            front_node
+        })
+    }
+}
diff --git a/foo01_warn.rs b/foo01_warn.rs
new file mode 100644
index 0000000..e65d1f6
--- /dev/null
+++ b/foo01_warn.rs
@@ -0,0 +1,21 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="sized"] pub trait Sized { }
+
+pub fn foo<T>(b: bool, c: || -> T, f: |T| -> int) -> int {
+    let x = c();
+    //                                                          // NEEDS_DROP={x}
+    let ret = if b {
+    //                                                          // NEEDS_DROP={x}
+        f(x) // Variable x moved in this branch ...
+    //                                                          // NEEDS_DROP={}
+    } else {
+    //                                                          // NEEDS_DROP={x}
+        3    // ... but not this one ...
+    //                                                          // NEEDS_DROP={x}
+    }; // ... thus expect notice at this join-point.
+    c();
+    ret
+}
diff --git a/foo02_fine.rs b/foo02_fine.rs
new file mode 100644
index 0000000..d96d5f0
--- /dev/null
+++ b/foo02_fine.rs
@@ -0,0 +1,23 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub fn foo<T:Copy>(b: bool, c: || -> T, f: |T| -> int) -> int {
+    let x = c();
+    //                                                          // NEEDS_DROP={}
+    let ret = if b {
+    //                                                          // NEEDS_DROP={}
+        f(x) // Variable x copied in this branch ...
+    //                                                          // NEEDS_DROP={}
+    } else {
+    //                                                          // NEEDS_DROP={}
+        3    // ... but not this one ...
+    //                                                          // NEEDS_DROP={}
+    }; // ... but since it is copy, needs-drop = {}.  (Copy and Drop are mutually exclusive)
+    //                                                          // NEEDS_DROP={}
+    c();
+    ret
+}
diff --git a/foo03_warn.rs b/foo03_warn.rs
new file mode 100644
index 0000000..28d0546
--- /dev/null
+++ b/foo03_warn.rs
@@ -0,0 +1,24 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub struct Foo<X,Y> { _x: X, _y: Y }
+
+pub fn foo<X,Y:Copy>(b: bool, c: || -> Foo<X,Y>, f: |X| -> int, _g: |Y| -> int) -> int {
+    let s = c();
+    //                                                          // NEEDS_DROP={s}
+    let ret = if b {
+    //                                                          // NEEDS_DROP={s}
+        f(s._x) // Path s._x moved in this branch ...
+    //                                                          // NEEDS_DROP={}
+    } else {
+    //                                                          // NEEDS_DROP={s}
+        3    // ... but not this one ...
+    //                                                          // NEEDS_DROP={s}
+    }; // ... thus expect notice at this join-point.
+    c();
+    ret
+}
diff --git a/foo04_warn.rs b/foo04_warn.rs
new file mode 100644
index 0000000..07e266a
--- /dev/null
+++ b/foo04_warn.rs
@@ -0,0 +1,26 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub struct Foo<X,Y> { _x: X, _y: Y, _z: X }
+
+pub fn foo<X,Y:Copy>(b: bool, c: || -> Foo<X,Y>, f: |X| -> int) -> int {
+    let mut s = c();
+    //                                                          // NEEDS_DROP={s}
+    s._x = s._z; // s._x assigned here (and s._z moved here).
+    //                                                          // NEEDS_DROP={s._x}
+    let ret = if b {
+        //                                                      // NEEDS_DROP={s._x}
+        f(s._x) // Path s._x moved in this branch ...
+        //                                                      // NEEDS_DROP={}
+    } else {
+        //                                                      // NEEDS_DROP={s._x}
+        3    // ... but not this one ...
+        //                                                      // NEEDS_DROP={s._x}
+    }; // ... thus expect notice at this join-point.
+    c();
+    ret
+}
diff --git a/foo05_warn.rs b/foo05_warn.rs
new file mode 100644
index 0000000..07aff72
--- /dev/null
+++ b/foo05_warn.rs
@@ -0,0 +1,24 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub struct Foo<X,Y> { _x: X, _y: Y, _z: X }
+
+pub fn foo<X,Y:Copy>(b: bool, c: || -> Foo<X,Y>, f: |X| -> int) -> int {
+    let s = c();
+    //                                                          // NEEDS_DROP={s}
+    let ret = if b {
+        //                                                      // NEEDS_DROP={s}
+        f(s._x) // Path s._x moved in this branch ...
+        //                                                      // NEEDS_DROP={s._z}
+    } else {
+        //                                                      // NEEDS_DROP={s}
+        3    // ... but not this one ...
+        //                                                      // NEEDS_DROP={s}
+    }; // ... thus expect notice at this join-point.
+    c();
+    ret
+}
diff --git a/foo06_warn.rs b/foo06_warn.rs
new file mode 100644
index 0000000..08b4623
--- /dev/null
+++ b/foo06_warn.rs
@@ -0,0 +1,26 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub struct Foo<X,Y> { _x: X, _y: Y, _z: X }
+
+pub fn foo<X,Y:Copy>(b: bool, c: || -> Foo<X,Y>, f: |X| -> int, x: X) -> int {
+    let mut s = c();
+    //                                                          // NEEDS_DROP={s, x}
+    s._x = x;
+    //                                                          // NEEDS_DROP={s}
+    let ret = if b {
+        //                                                      // NEEDS_DROP={s}
+        f(s._x) // Path s._x moved in this branch ...
+        //                                                      // NEEDS_DROP={s._z}
+    } else {
+        //                                                      // NEEDS_DROP={s}
+        3    // ... but not this one ...
+        //                                                      // NEEDS_DROP={s}
+    }; // ... thus expect notice at this join-point.
+    c();
+    ret
+}
diff --git a/foo07_warn.rs b/foo07_warn.rs
new file mode 100644
index 0000000..516cba2
--- /dev/null
+++ b/foo07_warn.rs
@@ -0,0 +1,25 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub struct Foo<X,Y> { _x: X, _y: Y, _z: X }
+
+pub fn foo<X,Y:Copy>(b: bool, c: || -> Foo<X,Y>, _f: |X| -> int, x: X) -> int {
+    let mut s = c();
+    //                                                          // NEEDS_DROP={s,x}
+    let ret = if b {
+        //                                                      // NEEDS_DROP={s,x}
+        s._x = x; // `x` moved in this branch
+        //                                                      // NEEDS_DROP={s}
+        4
+    } else {
+        //                                                      // NEEDS_DROP={s,x}
+        3    // ... but not this one ...
+        //                                                      // NEEDS_DROP={s,x}
+    }; // ... thus expect notice at this join-point.
+    c();
+    ret
+}
diff --git a/foo08_warn.rs b/foo08_warn.rs
new file mode 100644
index 0000000..d6b83c9
--- /dev/null
+++ b/foo08_warn.rs
@@ -0,0 +1,29 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub struct Foo<X,Y> { _x: X, _y: Y, _z: X }
+
+pub fn foo<X,Y:Copy>(b: bool, c: || -> Foo<X,Y>, _f: |X| -> int, _g: || -> X) -> int {
+    let mut s = c();
+    //                                                          // NEEDS_DROP={s}
+    _f(s._x);
+    //                                                          // NEEDS_DROP={s._z}
+    _f(s._z);
+    //                                                          // NEEDS_DROP={}
+    // all of `s` is moved away ...
+    let ret = if b {
+        //                                                      // NEEDS_DROP={}
+        s._x = _g(); // but `s._x` is re-established in this branch
+        //                                                      // NEEDS_DROP={s._x}
+        4
+    } else {
+        //                                                      // NEEDS_DROP={}
+        3 // ... but not this one ...
+    }; // ... thus expect notice at this join-point.
+    c();
+    ret
+}
diff --git a/foo09_warn.rs b/foo09_warn.rs
new file mode 100644
index 0000000..be1e7b6
--- /dev/null
+++ b/foo09_warn.rs
@@ -0,0 +1,26 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub struct Foo<X,Y> { _x: X, _y: Y, _z: X, _w: X }
+
+pub fn foo<X,Y:Copy>(b: bool, c: || -> Foo<X,Y>, f: |X| -> int) -> int {
+    let mut s = c();
+    //                                                          // NEEDS_DROP={s}
+    s._x = s._z; // s._x assigned here (and s._z moved here).
+    //                                                          // NEEDS_DROP={s._x}
+    let ret = if b {
+        //                                                      // NEEDS_DROP={s._x}
+        f(s._x) // Path s._x moved in this branch ...
+        //                                                      // NEEDS_DROP={}
+    } else {
+        //                                                      // NEEDS_DROP={s._x}
+        3    // ... but not this one ...
+        //                                                      // NEEDS_DROP={s._x}
+    }; // ... thus expect notice at this join-point.
+    c();
+    ret
+}
diff --git a/foo1.rs b/foo1.rs
deleted file mode 100644
index 5a4f3b0..0000000
--- a/foo1.rs
+++ /dev/null
@@ -1,18 +0,0 @@
-#![feature(lang_items)]
-#![no_std]
-#![crate_type="lib"]
-
-#[lang="sized"] pub trait Sized { }
-
-pub fn foo<T>(b: bool, x: T, f: |T| -> int) -> int {
-    //                                                          // NEEDS_DROP={x}
-    if b {
-    //                                                          // NEEDS_DROP={x}
-        f(x) // Variable x moved in this branch ...
-    //                                                          // NEEDS_DROP={}
-    } else {
-    //                                                          // NEEDS_DROP={x}
-        3    // ... but not this one ...
-    //                                                          // NEEDS_DROP={x}
-    } // ... thus expect notice at this join-point.
-}
diff --git a/foo10.rs b/foo10.rs
deleted file mode 100644
index eceaa45..0000000
--- a/foo10.rs
+++ /dev/null
@@ -1,23 +0,0 @@
-#![feature(lang_items)]
-#![no_std]
-#![crate_type="lib"]
-
-#[lang="copy"]  pub trait Copy { }
-#[lang="sized"] pub trait Sized { }
-
-pub struct Foo<X,Y> { _x: X, _y: Y, _z: X, _w: X }
-
-pub fn foo<X,Y:Copy>(b: bool, mut s: Foo<X,Y>, f: |X| -> int) -> int {
-    //                                                          // NEEDS_DROP={s}
-    s._x = s._z; // s._x assigned here (and s._z moved here).
-    //                                                          // NEEDS_DROP={s._x, s._w}
-    if b {
-        //                                                      // NEEDS_DROP={s._x, s._w}
-        f(s._x) // Path s._x moved in this branch ...
-        //                                                      // NEEDS_DROP={s._w}
-    } else {
-        //                                                      // NEEDS_DROP={s._x, s._w}
-        3    // ... but not this one ...
-        //                                                      // NEEDS_DROP={s._x, s._w}
-    } // ... thus expect notice at this join-point.
-}
diff --git a/foo10_warn.rs b/foo10_warn.rs
new file mode 100644
index 0000000..1e7d10c
--- /dev/null
+++ b/foo10_warn.rs
@@ -0,0 +1,26 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub struct Foo<X,Y> { _x: X, _y: Y, _z: X, _w: X }
+
+pub fn foo<X,Y:Copy>(b: bool, c: || -> Foo<X,Y>, f: |X| -> int) -> int {
+    let mut s = c();
+    //                                                          // NEEDS_DROP={s}
+    s._x = s._z; // s._x assigned here (and s._z moved here).
+    //                                                          // NEEDS_DROP={s._x, s._w}
+    let ret = if b {
+        //                                                      // NEEDS_DROP={s._x, s._w}
+        f(s._x) // Path s._x moved in this branch ...
+        //                                                      // NEEDS_DROP={s._w}
+    } else {
+        //                                                      // NEEDS_DROP={s._x, s._w}
+        3    // ... but not this one ...
+        //                                                      // NEEDS_DROP={s._x, s._w}
+    }; // ... thus expect notice at this join-point.
+    c();
+    ret
+}
diff --git a/foo11.rs b/foo11.rs
deleted file mode 100644
index b20accf..0000000
--- a/foo11.rs
+++ /dev/null
@@ -1,24 +0,0 @@
-#![feature(lang_items)]
-#![no_std]
-#![crate_type="lib"]
-
-#[lang="copy"]  pub trait Copy { }
-#[lang="sized"] pub trait Sized { }
-
-pub enum Foo<A,B> { Fx(A), Fy(B) }
-
-pub fn foo<X,Y>(s: Foo<X,Y>, f: |X| -> int, g: |Y| -> int) -> int {
-    //                                                          // NEEDS_DROP={s}
-    match s {
-        Fx(x) => {
-    //                                                          // NEEDS_DROP={x}
-            f(x)
-    //                                                          // NEEDS_DROP={}
-        }
-        Fy(y) => {
-    //                                                          // NEEDS_DROP={y}
-            g(y)
-    //                                                          // NEEDS_DROP={}
-        }
-    } // ... this should be fine.
-}
diff --git a/foo11_fine.rs b/foo11_fine.rs
new file mode 100644
index 0000000..ea3c3b1
--- /dev/null
+++ b/foo11_fine.rs
@@ -0,0 +1,27 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub enum Foo<A,B> { Fx(A), Fy(B) }
+
+pub fn foo<X,Y>(c: || -> Foo<X,Y>, f: |X| -> int, g: |Y| -> int) -> int {
+    let s = c();
+    //                                                          // NEEDS_DROP={s}
+    let ret = match s {
+        Fx(x) => {
+    //                                                          // NEEDS_DROP={x}
+            f(x)
+    //                                                          // NEEDS_DROP={}
+        }
+        Fy(y) => {
+    //                                                          // NEEDS_DROP={y}
+            g(y)
+    //                                                          // NEEDS_DROP={}
+        }
+    }; // ... this should be fine.
+    c();
+    ret
+}
diff --git a/foo12.rs b/foo12.rs
deleted file mode 100644
index 7ba2e6f..0000000
--- a/foo12.rs
+++ /dev/null
@@ -1,24 +0,0 @@
-#![feature(lang_items)]
-#![no_std]
-#![crate_type="lib"]
-
-#[lang="copy"]  pub trait Copy { }
-#[lang="sized"] pub trait Sized { }
-
-pub enum Foo<A,B> { Fx(A), Fy(B) }
-
-pub fn foo<X,Y:Copy>(s: Foo<X,Y>, f: |X| -> int, g: |Y| -> int) -> int {
-    //                                                          // NEEDS_DROP={s}
-    match s {
-        Fx(x) => {
-    //                                                          // NEEDS_DROP={x}
-            f(x)
-    //                                                          // NEEDS_DROP={}
-        }
-        Fy(y) => {
-    //                                                          // NEEDS_DROP={}
-            g(y)
-    //                                                          // NEEDS_DROP={}
-        }
-    } // ... this should be fine.
-}
diff --git a/foo12_fine.rs b/foo12_fine.rs
new file mode 100644
index 0000000..ceda294
--- /dev/null
+++ b/foo12_fine.rs
@@ -0,0 +1,27 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub enum Foo<A,B> { Fx(A), Fy(B) }
+
+pub fn foo<X,Y:Copy>(c: || -> Foo<X,Y>, f: |X| -> int, g: |Y| -> int) -> int {
+    let s = c();
+    //                                                          // NEEDS_DROP={s}
+    let ret = match s {
+        Fx(x) => {
+    //                                                          // NEEDS_DROP={x}
+            f(x)
+    //                                                          // NEEDS_DROP={}
+        }
+        Fy(y) => {
+    //                                                          // NEEDS_DROP={}
+            g(y)
+    //                                                          // NEEDS_DROP={}
+        }
+    }; // ... this should be fine.
+    c();
+    ret
+}
diff --git a/foo13.rs b/foo13.rs
deleted file mode 100644
index af13eb9..0000000
--- a/foo13.rs
+++ /dev/null
@@ -1,29 +0,0 @@
-#![feature(lang_items)]
-#![no_std]
-#![crate_type="lib"]
-
-#[lang="copy"]  pub trait Copy { }
-#[lang="sized"] pub trait Sized { }
-
-pub enum Foo<A,B> { Fx(A), Fy(B) }
-
-pub fn foo<X,Y:Copy>(s: Foo<X,Y>, f: |X| -> int, f2: |&X| -> int, g: |Y| -> int) -> int {
-    //                                                          // NEEDS_DROP={s}
-    match s {
-        Fx(ref x2) if true => {
-    //                                                          // NEEDS_DROP={s}
-            f2(x2)
-    //                                                          // NEEDS_DROP={s}
-        }
-        Fx(x) => {
-    //                                                          // NEEDS_DROP={x}
-            f(x)
-    //                                                          // NEEDS_DROP={}
-        }
-        Fy(y) => {
-    //                                                          // NEEDS_DROP={}
-            g(y)
-    //                                                          // NEEDS_DROP={}
-        }
-    } // ... this should be fine.
-}
diff --git a/foo13_fine.rs b/foo13_fine.rs
new file mode 100644
index 0000000..995b452
--- /dev/null
+++ b/foo13_fine.rs
@@ -0,0 +1,38 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub fn drop<T>(_x: T) { }
+
+pub enum Foo<A,B> { Fx(A), Fy(B) }
+
+pub fn foo<X,Y:Copy>(b: || -> bool,
+                     c: || -> Foo<X,Y>,
+                     f: |X| -> int,
+                     g: |Y| -> int) -> int {
+    let s = c();
+    //                                                          // NEEDS_DROP={s}
+    let ret = match s {
+        Fx(_) if b() => {
+    //                                                          // NEEDS_DROP={s}
+            drop(s);
+    //                                                          // NEEDS_DROP={}
+            3
+        }
+        Fx(x) => {
+    //                                                          // NEEDS_DROP={x}
+            f(x)
+    //                                                          // NEEDS_DROP={}
+        }
+        Fy(y) => {
+    //                                                          // NEEDS_DROP={}
+            g(y)
+    //                                                          // NEEDS_DROP={}
+        }
+    }; // ... this should be fine"
+    c();
+    ret
+}
diff --git a/foo14_fine.rs b/foo14_fine.rs
new file mode 100644
index 0000000..beb3569
--- /dev/null
+++ b/foo14_fine.rs
@@ -0,0 +1,22 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub enum Foo<A> { Fx(A) }
+
+pub fn foo<X>(c: || -> Foo<X>, f: |X| -> int) -> int {
+    let s = c();
+    //                                                          // NEEDS_DROP={s}
+    let ret = match s {
+        Fx(x) => {
+    //                                                          // NEEDS_DROP={x}
+            f(x)
+    //                                                          // NEEDS_DROP={}
+        }
+    }; // ... this should be fine.
+    c();
+    ret
+}
diff --git a/foo15_fine.rs b/foo15_fine.rs
new file mode 100644
index 0000000..d55bef2
--- /dev/null
+++ b/foo15_fine.rs
@@ -0,0 +1,34 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub fn drop<T>(_x: T) { }
+
+pub enum Option<T> { None, Some(T), }
+
+pub struct Cell<T> {
+    value: T,
+}
+
+/// Remove the first Node and return it, or None if the list is empty
+pub fn foo<T>(self_: &mut Cell<T>,
+              taken: Option<T>) {
+    let f = |front_node: Option<T>| {
+    //                                                          // NEEDS_DROP={front_node}
+        match front_node { // by-move match consumes front_node ...
+            Some(node) => {
+    //                                                          // NEEDS_DROP={node}
+                self_.value = node
+    //                                                          // NEEDS_DROP={}
+            }
+            None => {
+    //                                                          // NEEDS_DROP={}
+            }
+        } // ... this should be fine
+    };
+
+    f(taken)
+}
diff --git a/foo16.rs b/foo16.rs
new file mode 100644
index 0000000..2d59796
--- /dev/null
+++ b/foo16.rs
@@ -0,0 +1,46 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+#[lang="send"]  pub trait Send { }
+
+
+/// A type that represents a uniquely-owned value.
+#[lang = "owned_box"]
+#[unstable = "custom allocators will add an additional type parameter (with default)"]
+pub struct Box<T>(*mut T);
+
+pub trait Writer { }
+
+pub fn drop<T>(_x: T) { }
+
+pub enum Option<T> { None, Some(T), }
+
+pub fn set_stderr(_stderr: Box<Writer + Send>) -> Option<Box<Writer + Send>> {
+    loop { }
+}
+
+/// Remove the first Node and return it, or None if the list is empty
+pub fn foo<T>() {
+    // a snippet taken from rustdoc::test::runtest
+
+    struct ChanWriter;
+    impl Writer for ChanWriter {}
+    let w1 = ChanWriter;
+    let old = set_stderr(box w1);
+
+    let my_proc = proc() {
+        match old {
+            Some(old) => {
+                // Chop off the `Send` bound.
+                let old : Box<Writer> = old;
+                old
+            }
+            None => loop { }
+        };
+        loop { }
+    };
+    my_proc()
+}
diff --git a/foo17_warn.rs b/foo17_warn.rs
new file mode 100644
index 0000000..208cd19
--- /dev/null
+++ b/foo17_warn.rs
@@ -0,0 +1,40 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub struct Foo<X,Y> { _x: X, _y: Y, _z: X, _w: X }
+
+pub fn foo<X,Y>(b: || -> bool, c: || -> Foo<X,Y>, f: |Foo<X,Y>| -> i8) -> i8 {
+    //                                                       // NEEDS_DROP={}
+    let s = c();
+    //                                                       // NEEDS_DROP={s}
+    let ret = if !b() {
+        //                                                   // NEEDS_DROP={s}
+        f(s) // s moved in this branch ...
+            //                                               // NEEDS_DROP={}
+    } else {
+        //                                                   // NEEDS_DROP={s}
+        if b() {
+            //                                               // NEEDS_DROP={s}
+            f(s) // s moved in this branch ...
+            //                                               // NEEDS_DROP={}
+        } else {
+            //                                               // NEEDS_DROP={s}
+            3    // ... but not this one ...
+        } // ... thus expect notice at this join-point ...
+        // ... but what about the outer merge point ...
+        //                                                   // NEEDS_DROP=merge({}, {s})
+        // ... we need to choose some value for NEEDS_DROP ...
+        // ... we could use union (A | B) ...
+        // ... but instead we choose intersection ...
+        //                                                   //      ...  = {} & {s}
+        // ... (see extensive discussion of why in impl
+        // BitwiseOperator for NeedsDropDataFlowOperator) ...
+        //                                                   //      ...  = {}
+    }; // ... thus do *not* expect notice at this joint point.
+    c();
+    ret
+}
diff --git a/foo18_warn.rs b/foo18_warn.rs
new file mode 100644
index 0000000..4d45829
--- /dev/null
+++ b/foo18_warn.rs
@@ -0,0 +1,41 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub struct Foo<X,Y> { _x: X, _y: Y, _z: X, _w: X }
+
+pub fn foo<X,Y>(b: || -> bool, c: || -> Foo<X,Y>, f: |Foo<X,Y>| -> i8) -> i8 {
+    //                                                       // NEEDS_DROP={}
+    let s = c();
+    //                                                       // NEEDS_DROP={s}
+    let ret = if !b() {
+        //                                                   // NEEDS_DROP={s}
+        2 // s not moved in this branch ...
+            //                                               // NEEDS_DROP={s}
+    } else {
+        //                                                   // NEEDS_DROP={s}
+        if b() {
+            //                                               // NEEDS_DROP={s}
+            f(s) // s moved in this branch ...
+            //                                               // NEEDS_DROP={}
+        } else {
+            //                                               // NEEDS_DROP={s}
+            3    // ... but not this one ...
+        } // ... thus expect notice at this join-point ...
+
+        // ... but what about the outer join-point ...
+        //                                                   // NEEDS_DROP=merge({}, {s})
+        // ... we need to choose some value for NEEDS_DROP ...
+        // ... we could use union (A | B) ...
+        // ... but instead we choose intersection ...
+        //                                                   //      ...  = {} & {s}
+        // ... (see extensive discussion of why in impl
+        // BitwiseOperator for NeedsDropDataFlowOperator) ...
+        //                                                   //      ...  = {}
+    }; // ... thus expect 2nd notice at this join-point.
+    c();
+    ret
+}
diff --git a/foo19.rs b/foo19.rs
new file mode 100644
index 0000000..2575ffd
--- /dev/null
+++ b/foo19.rs
@@ -0,0 +1,29 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub enum Pairy<X,Y,Z> { Two(X,Y), One(Z), None }
+
+pub fn foo<A,B:Copy>(c: || -> Pairy<(A,A),bool,B>,
+                     dA: |A| -> i8,
+                     dB: |B| -> i8) -> i8 {
+    let s = c();
+    let ret = match s {
+        Two((a1,a2), true) => dA(a1) + dA(a2),
+
+        Two((_,a2), false) => dA(a2),
+                            // this is an example of `_` being an
+                            // "autodrop", since user could not write
+                            // the drop themselves except by binding
+                            // it to name, which would be a misfeature
+                            // in the language.
+
+        One(b) => dB(b),
+        None => 5,
+    };
+    c();
+    ret
+}
diff --git a/foo2.rs b/foo2.rs
deleted file mode 100644
index cadd513..0000000
--- a/foo2.rs
+++ /dev/null
@@ -1,20 +0,0 @@
-#![feature(lang_items)]
-#![no_std]
-#![crate_type="lib"]
-
-#[lang="copy"]  pub trait Copy { }
-#[lang="sized"] pub trait Sized { }
-
-pub fn foo<T:Copy>(b: bool, x: T, f: |T| -> int) -> int {
-    //                                                          // NEEDS_DROP={}
-    if b {
-    //                                                          // NEEDS_DROP={}
-        f(x) // Variable x copied in this branch ...
-    //                                                          // NEEDS_DROP={}
-    } else {
-    //                                                          // NEEDS_DROP={}
-        3    // ... but not this one ...
-    //                                                          // NEEDS_DROP={}
-    } // ... but since it is copy, needs-drop = {}.  (Copy and Drop are mutually exclusive)
-    //                                                          // NEEDS_DROP={}
-}
diff --git a/foo20.rs b/foo20.rs
new file mode 100644
index 0000000..9c50bd2
--- /dev/null
+++ b/foo20.rs
@@ -0,0 +1,12 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub fn foo<X>(t: &(i8, X)) -> i8 {
+    let &(a, _) = t;
+    let &(b, _) = t;
+    a + b
+}
diff --git a/foo21.rs b/foo21.rs
new file mode 100644
index 0000000..3510c1d
--- /dev/null
+++ b/foo21.rs
@@ -0,0 +1,19 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub enum Result<T,E> { Ok(T), Err(E) }
+
+pub fn foo<X,Y>(c: || -> Result<X,Y>,
+                x: |X| -> Result<X,Y>) -> Result<X,Y> {
+    let s = c();
+    let ret = match s {
+        Err(_) => s,
+        Ok(content) => x(content),
+    };
+    c();
+    ret
+}
diff --git a/foo22.rs b/foo22.rs
new file mode 100644
index 0000000..c417d84
--- /dev/null
+++ b/foo22.rs
@@ -0,0 +1,34 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub fn foo<X>(b: || -> bool,
+              c: || -> X,
+              d: |X| -> i8) -> i8 {
+    let mut count = d(c());
+    while count > 0 {
+        count -= 1;
+        let s_loop = c();
+        if b() {
+            d(s_loop);
+        }
+    }
+
+    let s_return = c();
+    if b() {
+        if b() {
+            d(s_return)
+        } else {
+            3
+        }
+    } else {
+        return if b() { // TODO: Stlll not handling this right
+            d(s_return)
+        } else {
+            3
+        };
+    }
+}
diff --git a/foo23_fine.rs b/foo23_fine.rs
new file mode 100644
index 0000000..8ec2fba
--- /dev/null
+++ b/foo23_fine.rs
@@ -0,0 +1,35 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+mod marker {
+    #[lang="no_send_bound"]
+    pub struct NoSend;
+}
+
+#[lang="gc"]
+pub struct Gc<T> {
+    _ptr: *mut T,
+    marker: marker::NoSend,
+}
+
+pub fn foo<T:Copy>(b: bool, c: || -> Gc<T>, f: |Gc<T>| -> int) -> int {
+    let x = c();
+    //                                                          // NEEDS_DROP={}
+    let ret = if b {
+    //                                                          // NEEDS_DROP={}
+        f(x) // Variable x copied in this branch ...
+    //                                                          // NEEDS_DROP={}
+    } else {
+    //                                                          // NEEDS_DROP={}
+        3    // ... but not this one ...
+    //                                                          // NEEDS_DROP={}
+    }; // ... but since it is Gc<T>, needs-drop = {}.
+    //        (Gc should not impose drop obligation)
+    //                                                          // NEEDS_DROP={}
+    c();
+    ret
+}
diff --git a/foo24_fine.rs b/foo24_fine.rs
new file mode 100644
index 0000000..f8d5484
--- /dev/null
+++ b/foo24_fine.rs
@@ -0,0 +1,36 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+mod marker {
+    #[lang="no_send_bound"]
+    pub struct NoSend;
+}
+
+#[lang="gc"]
+pub struct Gc<T> {
+    _ptr: *mut T,
+    marker: marker::NoSend,
+}
+
+pub fn foo<T>(b: bool, c: || -> Gc<T>, f: |Gc<T>| -> int) -> int {
+    let x = c();
+    //                                                          // NEEDS_DROP={}
+    let ret = if b {
+    //                                                          // NEEDS_DROP={}
+        f(x) // Variable x copied in this branch ...
+    //                                                          // NEEDS_DROP={}
+    } else {
+    //                                                          // NEEDS_DROP={}
+        3    // ... but not this one ...
+    //                                                          // NEEDS_DROP={}
+    }; // ... but since it is Gc<T>, needs-drop = {}.
+    //        (Gc should not impose drop obligation, even
+    //         when T itself may need drop-glue.)
+    //                                                          // NEEDS_DROP={}
+    c();
+    ret
+}
diff --git a/foo25_warn.rs b/foo25_warn.rs
new file mode 100644
index 0000000..ab1984f
--- /dev/null
+++ b/foo25_warn.rs
@@ -0,0 +1,29 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+#[lang="send"]  pub trait Send { }
+
+
+/// A type that represents a uniquely-owned value.
+#[lang = "owned_box"]
+pub struct Box<T>(*mut T);
+
+pub fn foo<T>(b: bool, c: || -> Box<T>, f: |Box<T>| -> int) -> int {
+    let x = c();
+    //                                                          // NEEDS_DROP={x}
+    let ret = if b {
+    //                                                          // NEEDS_DROP={x}
+        f(x) // Variable x copied in this branch ...
+    //                                                          // NEEDS_DROP={}
+    } else {
+    //                                                          // NEEDS_DROP={x}
+        3    // ... but not this one ...
+    //                                                          // NEEDS_DROP={x}
+    }; // ... thus expect notice at this join-point.
+    //                                                          // NEEDS_DROP={}
+    c();
+    ret
+}
diff --git a/foo26_warn.rs b/foo26_warn.rs
new file mode 100644
index 0000000..fb738a4
--- /dev/null
+++ b/foo26_warn.rs
@@ -0,0 +1,31 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+#[lang="send"]  pub trait Send { }
+
+
+/// A type that represents a uniquely-owned value.
+#[lang = "owned_box"]
+pub struct Box<T>(*mut T);
+
+pub struct Foo<X,Y> { _x: X, _y: Y }
+
+pub fn foo<T>(b: bool, c: || -> Foo<Box<T>,T>, f: |Box<T>| -> int) -> int {
+    let s = c();
+    //                                                          // NEEDS_DROP={s}
+    let ret = if b {
+    //                                                          // NEEDS_DROP={s}
+        f(s._x) // Path s._x moved in this branch ...
+    //                                                          // NEEDS_DROP={s._y}
+    } else {
+    //                                                          // NEEDS_DROP={s}
+        3    // ... but not this one ...
+    //                                                          // NEEDS_DROP={s}
+    }; // ... thus expect notice at this join-point.
+    //                                                          // NEEDS_DROP={}
+    c();
+    ret
+}
diff --git a/foo27_warn.rs b/foo27_warn.rs
new file mode 100644
index 0000000..7c13054
--- /dev/null
+++ b/foo27_warn.rs
@@ -0,0 +1,31 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+#[lang="send"]  pub trait Send { }
+
+
+/// A type that represents a uniquely-owned value.
+#[lang = "owned_box"]
+pub struct Box<T>(*mut T);
+
+pub struct Foo<X,Y> { _x: X, _y: Y }
+
+pub fn foo<T>(b: bool, c: || -> Foo<Box<T>,T>, f: |T| -> int) -> int {
+    let s = c();
+    //                                                          // NEEDS_DROP={s}
+    let ret = if b {
+    //                                                          // NEEDS_DROP={s}
+        f(s._y) // Path s._y moved in this branch ...
+    //                                                          // NEEDS_DROP={s._x}
+    } else {
+    //                                                          // NEEDS_DROP={s}
+        3    // ... but not this one ...
+    //                                                          // NEEDS_DROP={s}
+    }; // ... thus expect notice at this join-point.
+    //                                                          // NEEDS_DROP={}
+    c();
+    ret
+}
diff --git a/foo28_warn.rs b/foo28_warn.rs
new file mode 100644
index 0000000..e975d1b
--- /dev/null
+++ b/foo28_warn.rs
@@ -0,0 +1,31 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+#[lang="send"]  pub trait Send { }
+
+
+/// A type that represents a uniquely-owned value.
+#[lang = "owned_box"]
+pub struct Box<T>(*mut T);
+
+pub struct Foo<X,Y> { _x: X, _y: Y }
+
+pub fn foo<T>(b: bool, c: || -> Foo<Box<T>,T>, f: |T| -> int) -> int {
+    let s = c();
+    //                                                          // NEEDS_DROP={s}
+    let ret = if b {
+    //                                                          // NEEDS_DROP={s}
+        f(*s._x) // Path s._x consumed in this branch ...
+    //                                                          // NEEDS_DROP={s._y}
+    } else {
+    //                                                          // NEEDS_DROP={s}
+        3    // ... but not this one ...
+    //                                                          // NEEDS_DROP={s}
+    }; // ... thus expect notice at this join-point.
+    //                                                          // NEEDS_DROP={}
+    c();
+    ret
+}
diff --git a/foo29_fine.rs b/foo29_fine.rs
new file mode 100644
index 0000000..8b3a1c2
--- /dev/null
+++ b/foo29_fine.rs
@@ -0,0 +1,40 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub enum Option<T> { None, Some(T), }
+
+mod marker {
+    #[lang="no_send_bound"]
+    pub struct NoSend;
+}
+
+#[lang="gc"]
+pub struct Gc<T> {
+    _ptr: *mut T,
+    marker: marker::NoSend,
+}
+
+pub fn foo<T>(c: || -> Option<Gc<T>>, f: |Gc<T>| -> int) -> int {
+    let s = c();
+    //                                                          // NEEDS_DROP={}
+    let ret = match s {
+        //                                                      // NEEDS_DROP={}
+        Some(x) => {  // Variable s moved in this branch ...
+            f(x)
+                //                                              // NEEDS_DROP={}
+        }
+        None => {     // ... but not this one ...
+            3
+                //                                              // NEEDS_DROP={}
+        }
+    }; // ... but since it is Gc<T>, needs-drop = {}.
+    //        (Gc should not impose drop obligation, even
+    //         when T itself may need drop-glue.)
+    //                                                          // NEEDS_DROP={}
+    c();
+    ret
+}
diff --git a/foo3.rs b/foo3.rs
deleted file mode 100644
index ae08e42..0000000
--- a/foo3.rs
+++ /dev/null
@@ -1,21 +0,0 @@
-#![feature(lang_items)]
-#![no_std]
-#![crate_type="lib"]
-
-#[lang="copy"]  pub trait Copy { }
-#[lang="sized"] pub trait Sized { }
-
-pub struct Foo<X,Y> { _x: X, _y: Y }
-
-pub fn foo<X,Y:Copy>(b: bool, s: Foo<X,Y>, f: |X| -> int, _g: |Y| -> int) -> int {
-    //                                                          // NEEDS_DROP={s}
-    if b {
-    //                                                          // NEEDS_DROP={s}
-        f(s._x) // Path s._x moved in this branch ...
-    //                                                          // NEEDS_DROP={}
-    } else {
-    //                                                          // NEEDS_DROP={s}
-        3    // ... but not this one ...
-    //                                                          // NEEDS_DROP={s}
-    } // ... thus expect notice at this join-point.
-}
diff --git a/foo30_fine.rs b/foo30_fine.rs
new file mode 100644
index 0000000..25c012a
--- /dev/null
+++ b/foo30_fine.rs
@@ -0,0 +1,26 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub fn foo<X>(c: || -> (X,u8), f: |X| -> i8) -> i8 {
+    let s = c();
+    //                                                          // NEEDS_DROP={s}
+    let ret = match s {
+        (b, 0) |
+        (b, 1) => {
+            //                                                  // NEEDS_DROP={b}
+            f(b) + 2
+                //                                              // NEEDS_DROP={}
+        }
+        (b, _) => {
+            //                                                  // NEEDS_DROP={b}
+            f(b) + 3
+            //                                                  // NEEDS_DROP={}
+        }
+    }; // ... this should be fine.
+    c();
+    ret
+}
diff --git a/foo31_warn.rs b/foo31_warn.rs
new file mode 100644
index 0000000..ead87b6
--- /dev/null
+++ b/foo31_warn.rs
@@ -0,0 +1,31 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+#[lang="send"]  pub trait Send { }
+
+
+/// A type that represents a uniquely-owned value.
+#[lang = "owned_box"]
+pub struct Box<T>(*mut T);
+
+pub struct Foo<X,Y> { _x: X, _y: Y }
+
+pub fn foo<T>(b: bool, c: || -> Foo<Box<Foo<T,T>>,T>, f: |T| -> int) -> int {
+    let s = c();
+    //                                                          // NEEDS_DROP={s}
+    let ret = if b {
+    //                                                          // NEEDS_DROP={s}
+        f(s._x._y) // Path s._x._y consumed in this branch ...
+    //                                                          // NEEDS_DROP={s._y, s._x._x}
+    } else {
+    //                                                          // NEEDS_DROP={s}
+        f(s._y)    // ... but not this one ...
+    //                                                          // NEEDS_DROP={s._x}
+    }; // ... thus expect notice at this join-point.
+    //                                                          // NEEDS_DROP={}
+    c();
+    ret
+}
diff --git a/foo32_fine.rs b/foo32_fine.rs
new file mode 100644
index 0000000..e8c1db7
--- /dev/null
+++ b/foo32_fine.rs
@@ -0,0 +1,21 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub enum Pairy<X,Y,Z> { Two(X,Y), One(Z), None }
+
+pub fn foo<A,B:Copy>(c: || -> Pairy<(A,A),bool,B>,
+                     dA: |A| -> i8,
+                     dB: |B| -> i8) -> i8 {
+    let s = c();
+    let ret = match s {
+        Two((a1,a2), _) => dA(a1) + dA(a2),
+        One(b) => dB(b),
+        None => 5,
+    };
+    c();
+    ret
+}
diff --git a/foo33_fine.rs b/foo33_fine.rs
new file mode 100644
index 0000000..912b612
--- /dev/null
+++ b/foo33_fine.rs
@@ -0,0 +1,41 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="sized"] pub trait Sized { }
+
+#[lang = "owned_box"]
+pub struct Box<T>(*mut T);
+pub enum Option<T> { None, Some(T), }
+
+pub static SIZE: uint = 2;
+
+
+pub struct TrieNode<T> {
+    _count: uint,
+    children: [Child<T>, ..SIZE],
+}
+
+pub enum Child<T> {
+    Internal(Box<TrieNode<T>>),
+    External(uint, T),
+    Nothing
+}
+
+pub fn foo<'a, T>(node_orig: &'a TrieNode<T>, idx: uint) -> Option<&'a T> {
+    let mut idx = idx;
+    let mut node = node_orig;
+    loop {
+        match node.children[idx] {
+            Internal(ref x) => node = &**x,
+            External(stored, ref value) =>
+                if stored == idx {
+                    return Some(value)
+                } else {
+                    return None
+                },
+            Nothing => return None,
+        }
+        idx += 1;
+    }
+}
diff --git a/foo34_fine.rs b/foo34_fine.rs
new file mode 100644
index 0000000..66254e2
--- /dev/null
+++ b/foo34_fine.rs
@@ -0,0 +1,41 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="sized"] pub trait Sized { }
+
+#[lang = "owned_box"]
+pub struct Box<T>(*mut T);
+pub enum Option<T> { None, Some(T), }
+
+pub static SIZE: uint = 2;
+
+
+pub struct TrieNode<'a,T> {
+    _count: uint,
+    children: &'a [Child<'a,T>],
+}
+
+pub enum Child<'a,T> {
+    Internal(Box<TrieNode<'a,T>>),
+    External(uint, T),
+    Nothing
+}
+
+pub fn foo<'a, T>(node_orig: &'a TrieNode<'a,T>, idx: uint) -> Option<&'a T> {
+    let mut idx = idx;
+    let mut node = node_orig;
+    loop {
+        match node.children[idx] {
+            Internal(ref x) => node = &**x,
+            External(stored, ref value) =>
+                if stored == idx {
+                    return Some(value)
+                } else {
+                    return None
+                },
+            Nothing => return None,
+        }
+        idx += 1;
+    }
+}
diff --git a/foo35_fine.rs b/foo35_fine.rs
new file mode 100644
index 0000000..6e764f8
--- /dev/null
+++ b/foo35_fine.rs
@@ -0,0 +1,47 @@
+#![feature(intrinsics)]
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="sized"] pub trait Sized { }
+
+#[lang = "owned_box"]
+pub struct Box<T>(*mut T);
+pub enum Option<T> { None, Some(T), }
+
+pub static SIZE: uint = 2;
+
+
+pub struct TrieNode<'a,T> {
+    _count: uint,
+    children: &'a [Child<'a,T>],
+}
+
+pub enum Child<'a,T> {
+    Internal(Box<TrieNode<'a,T>>),
+    External(uint, T),
+    Nothing
+}
+
+extern "rust-intrinsic" {
+    pub fn transmute<T,U>(e: T) -> U;
+}
+
+// This was an attempt to capture another ICE from trie.rs back when
+// the LpInterior(Element(_)) cases in `LoanPath::to_type` did not
+// fall through to the second case properly. But I am not sure I ever
+// actually saw the problem manifest itself on this narrowed test case
+// (As in, do not stress about trying to incorporate this test as is.)
+pub fn foo<'a, T>(node_orig: *mut TrieNode<T>, idx: uint) -> Option<&'a T> {
+    let mut idx = idx;
+    let mut node = node_orig;
+    loop {
+        let children = unsafe { &mut (*node).children };
+        match children[idx] {
+            Internal(ref x) => node = unsafe { transmute(&**x) },
+            External(_stored, _) => return None,
+            Nothing => return None,
+        }
+        idx += 1;
+    }
+}
diff --git a/foo36.rs b/foo36.rs
new file mode 100644
index 0000000..ac20f3f
--- /dev/null
+++ b/foo36.rs
@@ -0,0 +1,79 @@
+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT
+// file at the top-level directory of this distribution and at
+// http://rust-lang.org/COPYRIGHT.
+//
+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
+// option. This file may not be copied, modified, or distributed
+// except according to those terms.
+
+#![feature(struct_variant)]
+#![feature(lang_items)]
+
+#![no_std]
+#![crate_type="lib"]
+
+#![allow(unused_variable)]
+#![allow(non_camel_case_types)]
+
+#[lang = "owned_box"]
+pub struct Box<T>(*mut T);
+
+#[lang="exchange_free"]
+unsafe fn exchange_free(ptr: *mut u8, size: uint, align: uint) {
+    loop { }
+}
+
+mod marker {
+    #[lang="no_copy_bound"]
+    pub struct NoCopy;
+}
+
+struct Foo {
+    x: uint,
+    b: bool,
+    marker: marker::NoCopy
+}
+
+fn field_read(f: Foo) -> uint {
+    f.x * f.x
+}
+
+enum XYZ {
+    X,
+    Y {
+        b: i64,
+        c: Box<char>,
+    },
+    Z
+}
+
+fn field_match_in_patterns(b: XYZ) -> Box<char> {
+    match b {
+        Y { c: c, .. } => c,
+        _ => box 'c'
+    }
+}
+
+struct Bar {
+    x: uint,
+    b: bool,
+}
+
+#[repr(C)]
+struct Baz {
+    x: u32,
+}
+
+fn field_match_in_let(f: Bar) -> bool {
+    let Bar { b, .. } = f;
+    b
+}
+
+pub fn foo() {
+    field_read(Foo { x: 1, b: false, marker: marker::NoCopy });
+    field_match_in_patterns(X);
+    field_match_in_let(Bar { x: 42u, b: true });
+    let _ = Baz { x: 0 };
+}
diff --git a/foo37.rs b/foo37.rs
new file mode 100644
index 0000000..3d84ce7
--- /dev/null
+++ b/foo37.rs
@@ -0,0 +1,88 @@
+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT
+// file at the top-level directory of this distribution and at
+// http://rust-lang.org/COPYRIGHT.
+//
+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
+// option. This file may not be copied, modified, or distributed
+// except according to those terms.
+
+#![feature(struct_variant)]
+#![feature(lang_items)]
+
+#![no_std]
+#![crate_type="lib"]
+
+#![allow(unused_variable)]
+#![allow(non_camel_case_types)]
+
+#[lang = "owned_box"]
+pub struct Box<T>(*mut T);
+
+#[lang="exchange_malloc"]
+#[inline]
+unsafe fn exchange_malloc(size: uint, align: uint) -> *mut u8 {
+    loop { }
+}
+
+#[lang="exchange_free"]
+unsafe fn exchange_free(ptr: *mut u8, size: uint, align: uint) {
+    loop { }
+}
+
+mod marker {
+    #[lang="no_copy_bound"]
+    pub struct NoCopy;
+}
+
+struct Foo {
+    x: uint,
+    b: bool,
+    marker: marker::NoCopy
+}
+
+fn field_read(f: Foo) -> uint {
+    f.x * f.x
+}
+
+enum XYZ {
+    X,
+    Y {
+        b: i64,
+        c: Box<char>,
+    },
+    Z {
+        b: i32,
+        c: Box<char>,
+    },
+}
+
+fn field_match_in_patterns(b: XYZ) -> Box<char> {
+    match b {
+        Y { c: c, .. } => c,
+        _ => box 'c'
+    }
+}
+
+struct Bar {
+    x: uint,
+    b: bool,
+}
+
+#[repr(C)]
+struct Baz {
+    x: u32,
+}
+
+fn field_match_in_let(f: Bar) -> bool {
+    let Bar { b, .. } = f;
+    b
+}
+
+pub fn foo() {
+    field_read(Foo { x: 1, b: false, marker: marker::NoCopy });
+    field_match_in_patterns(X);
+    field_match_in_let(Bar { x: 42u, b: true });
+    let _ = Baz { x: 0 };
+}
diff --git a/foo4.rs b/foo4.rs
deleted file mode 100644
index 3848582..0000000
--- a/foo4.rs
+++ /dev/null
@@ -1,23 +0,0 @@
-#![feature(lang_items)]
-#![no_std]
-#![crate_type="lib"]
-
-#[lang="copy"]  pub trait Copy { }
-#[lang="sized"] pub trait Sized { }
-
-pub struct Foo<X,Y> { _x: X, _y: Y, _z: X }
-
-pub fn foo<X,Y:Copy>(b: bool, mut s: Foo<X,Y>, f: |X| -> int) -> int {
-    //                                                          // NEEDS_DROP={s}
-    s._x = s._z; // s._x assigned here (and s._z moved here).
-    //                                                          // NEEDS_DROP={s._x}
-    if b {
-        //                                                      // NEEDS_DROP={s._x}
-        f(s._x) // Path s._x moved in this branch ...
-        //                                                      // NEEDS_DROP={}
-    } else {
-        //                                                      // NEEDS_DROP={s._x}
-        3    // ... but not this one ...
-        //                                                      // NEEDS_DROP={s._x}
-    } // ... thus expect notice at this join-point.
-}
diff --git a/foo5.rs b/foo5.rs
deleted file mode 100644
index a998055..0000000
--- a/foo5.rs
+++ /dev/null
@@ -1,21 +0,0 @@
-#![feature(lang_items)]
-#![no_std]
-#![crate_type="lib"]
-
-#[lang="copy"]  pub trait Copy { }
-#[lang="sized"] pub trait Sized { }
-
-pub struct Foo<X,Y> { _x: X, _y: Y, _z: X }
-
-pub fn foo<X,Y:Copy>(b: bool, s: Foo<X,Y>, f: |X| -> int) -> int {
-    //                                                          // NEEDS_DROP={s}
-    if b {
-        //                                                      // NEEDS_DROP={s}
-        f(s._x) // Path s._x moved in this branch ...
-        //                                                      // NEEDS_DROP={s._z}
-    } else {
-        //                                                      // NEEDS_DROP={s}
-        3    // ... but not this one ...
-        //                                                      // NEEDS_DROP={s}
-    } // ... thus expect notice at this join-point.
-}
diff --git a/foo6.rs b/foo6.rs
deleted file mode 100644
index fdc8d2b..0000000
--- a/foo6.rs
+++ /dev/null
@@ -1,23 +0,0 @@
-#![feature(lang_items)]
-#![no_std]
-#![crate_type="lib"]
-
-#[lang="copy"]  pub trait Copy { }
-#[lang="sized"] pub trait Sized { }
-
-pub struct Foo<X,Y> { _x: X, _y: Y, _z: X }
-
-pub fn foo<X,Y:Copy>(b: bool, mut s: Foo<X,Y>, f: |X| -> int, x: X) -> int {
-    //                                                          // NEEDS_DROP={s, x}
-    s._x = x;
-    //                                                          // NEEDS_DROP={s}
-    if b {
-        //                                                      // NEEDS_DROP={s}
-        f(s._x) // Path s._x moved in this branch ...
-        //                                                      // NEEDS_DROP={s._z}
-    } else {
-        //                                                      // NEEDS_DROP={s}
-        3    // ... but not this one ...
-        //                                                      // NEEDS_DROP={s}
-    } // ... thus expect notice at this join-point.
-}
diff --git a/foo7.rs b/foo7.rs
deleted file mode 100644
index 3cdd48e..0000000
--- a/foo7.rs
+++ /dev/null
@@ -1,22 +0,0 @@
-#![feature(lang_items)]
-#![no_std]
-#![crate_type="lib"]
-
-#[lang="copy"]  pub trait Copy { }
-#[lang="sized"] pub trait Sized { }
-
-pub struct Foo<X,Y> { _x: X, _y: Y, _z: X }
-
-pub fn foo<X,Y:Copy>(b: bool, mut s: Foo<X,Y>, _f: |X| -> int, x: X) -> int {
-    //                                                          // NEEDS_DROP={s,x}
-    if b {
-        //                                                      // NEEDS_DROP={s,x}
-        s._x = x; // `x` moved in this branch
-        //                                                      // NEEDS_DROP={s}
-        4
-    } else {
-        //                                                      // NEEDS_DROP={s,x}
-        3    // ... but not this one ...
-        //                                                      // NEEDS_DROP={s,x}
-    } // ... thus expect notice at this join-point.
-}
diff --git a/foo8.rs b/foo8.rs
deleted file mode 100644
index 52a8a1a..0000000
--- a/foo8.rs
+++ /dev/null
@@ -1,26 +0,0 @@
-#![feature(lang_items)]
-#![no_std]
-#![crate_type="lib"]
-
-#[lang="copy"]  pub trait Copy { }
-#[lang="sized"] pub trait Sized { }
-
-pub struct Foo<X,Y> { _x: X, _y: Y, _z: X }
-
-pub fn foo<X,Y:Copy>(b: bool, mut s: Foo<X,Y>, _f: |X| -> int, _g: || -> X) -> int {
-    //                                                          // NEEDS_DROP={s}
-    _f(s._x);
-    //                                                          // NEEDS_DROP={s._z}
-    _f(s._z);
-    //                                                          // NEEDS_DROP={}
-    // all of `s` is moved away ...
-    if b {
-        //                                                      // NEEDS_DROP={}
-        s._x = _g(); // but `s._x` is re-established in this branch
-        //                                                      // NEEDS_DROP={s._x}
-        4
-    } else {
-        //                                                      // NEEDS_DROP={}
-        3 // ... but not this one ...
-    } // ... thus expect notice at this join-point.
-}
diff --git a/iter2.rs b/iter2.rs
new file mode 100644
index 0000000..916d092
--- /dev/null
+++ b/iter2.rs
@@ -0,0 +1,65 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub fn drop<T>(_x: T) { }
+
+pub enum Option<T> { None, Some(T), }
+
+pub struct Range<A> {
+    state: A,
+    stop: A,
+}
+
+impl<T> Option<T> {
+    fn map<A>(self, _f: |T| -> A) -> Option<A> { loop { } }
+}
+
+trait ToNums {
+    fn to_i64(&self) -> Option<i64> { loop { } }
+    fn to_u64(&self) -> Option<u64> { loop { } }
+    fn to_uint(&self) -> Option<uint> { loop { } }
+}
+
+trait CheckedSub {
+    fn checked_sub(&self, _y: &Self) -> Option<Self> { loop { } }
+}
+impl CheckedSub for i64 {}
+impl CheckedSub for u64 {}
+impl ToNums for i64 {}
+impl ToNums for u64 {}
+
+#[inline]
+pub fn foo<A:ToNums>(_self: &Range<A>) -> (uint, Option<uint>) {
+    // This first checks if the elements are representable as i64. If they aren't, try u64 (to
+    // handle cases like range(huge, huger)). We don't use uint/int because the difference of
+    // the i64/u64 might lie within their range.
+    let bound = match _self.state.to_i64() {
+        Some(a) => {
+            let sz = _self.stop.to_i64().map(|b| b.checked_sub(&a));
+            match sz {
+                Some(Some(bound)) => bound.to_uint(),
+                _ => None,
+            }
+        },
+        None => match _self.state.to_u64() {
+            Some(a) => {
+                let sz = _self.stop.to_u64().map(|b| b.checked_sub(&a));
+                match sz {
+                    Some(Some(bound)) => bound.to_uint(),
+                    _ => None
+                }
+            },
+            None => None
+        }
+    };
+
+    match bound {
+        Some(b) => (b, Some(b)),
+        // Standard fallback for unbounded/unrepresentable bounds
+        None => (0, None)
+    }
+}
diff --git a/num01.rs b/num01.rs
new file mode 100644
index 0000000..d4e09a1
--- /dev/null
+++ b/num01.rs
@@ -0,0 +1,23 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub fn drop<T>(_x: T) { }
+
+pub enum Ordering { Less = -1i, Equal = 0i, Greater = 1i, }
+
+pub trait Ord {
+    fn cmp(&self, _other: &Self) -> bool { loop { } }
+}
+impl Ord for int { }
+
+pub fn foo(x: &int) -> int {
+    match *x {
+        n if n.cmp(&0) => 1,
+        0 => 0,
+        _ => -1,
+    }
+}
diff --git a/option01.rs b/option01.rs
new file mode 100644
index 0000000..0192802
--- /dev/null
+++ b/option01.rs
@@ -0,0 +1,22 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub fn drop<T>(_x: T) { }
+
+pub enum Option<T> { None, Some(T), }
+
+pub fn foo<T>(x: Option<T>, optb: Option<T>) -> Option<T> {
+    match x {
+        // The use of `_` here means that this is a borrowing match of `x`...
+        Some(_) => { drop(optb); x }
+
+        // ... which means that `x` has not been dropped on this path
+        // (*even though* we know that `x` is `None` and thus is not
+        // needs-drop on this path) :(
+        None => optb
+    }
+}
diff --git a/result01.rs b/result01.rs
new file mode 100644
index 0000000..89fb53d
--- /dev/null
+++ b/result01.rs
@@ -0,0 +1,18 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub fn drop<T>(_x: T) { }
+
+pub enum Option<T> { None, Some(T), }
+pub enum Result<T, E> { Ok(T), Err(E), }
+
+pub fn foo<T,E>(s: Result<T, E>) -> Option<T> {
+    match s {
+        Ok(x)  => { Some(x) },
+        Err(_s) => { None },
+    }
+}
diff --git a/result02.rs b/result02.rs
new file mode 100644
index 0000000..2f32a3a
--- /dev/null
+++ b/result02.rs
@@ -0,0 +1,18 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub fn drop<T>(_x: T) { }
+
+pub enum Result<T, E> { Ok(T), Err(E), }
+
+// originally `Result::or`
+pub fn foo<T,E>(s: Result<T, E>, res: Result<T,E>) -> Result<T,E> {
+    match s {
+        Err(_) => { drop(s); res }
+        Ok(_) => { drop(res); s }
+    }
+}
diff --git a/result03.rs b/result03.rs
new file mode 100644
index 0000000..faf6107
--- /dev/null
+++ b/result03.rs
@@ -0,0 +1,24 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub fn drop<T>(_x: T) { }
+
+pub enum Result<T, E> { Ok(T), Err(E), }
+
+// originally `Result::or`
+pub fn foo<T,E>(s: Result<T, E>, res: Result<T,E>) -> Result<T,E> {
+    match s {
+        Err(_) => {
+            drop(s);
+            res
+        }
+        Ok(_) => {
+            drop(res);
+            s
+        }
+    }
+}
diff --git a/str01.rs b/str01.rs
new file mode 100644
index 0000000..9e1410d
--- /dev/null
+++ b/str01.rs
@@ -0,0 +1,55 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub fn drop<T>(_x: T) { }
+
+pub enum Option<T> { None, Some(T), }
+
+impl<T> Option<T> {
+    fn map<A>(self, _f: |T| -> A) -> Option<A> { loop { } }
+}
+
+mod marker {
+    #[lang="contravariant_lifetime"]
+    pub struct ContravariantLifetime<'a>;
+}
+
+pub struct Chars<'a> {
+    marker: marker::ContravariantLifetime<'a>
+}
+
+pub struct Utf16CodeUnits<'a> {
+    chars: Chars<'a>,
+    extra: u16
+}
+
+impl<'a> Chars<'a> {
+    fn next(&mut self) -> Option<char> { loop { } }
+}
+
+trait EncodeUtf16 {
+    fn encode_utf16(&self, _buf: &mut [u16]) -> uint { loop { } }
+}
+
+impl EncodeUtf16 for char { }
+
+impl<'a> Utf16CodeUnits<'a> {
+    pub fn foo(&mut self) -> Option<u16> {
+        if self.extra != 0 {
+            let tmp = self.extra;
+            self.extra = 0;
+            return Some(tmp);
+        }
+
+        let mut buf = [0u16, ..2];
+        self.chars.next().map(|ch| {
+            let n = ch.encode_utf16(buf /* as mut slice! */);
+            if n == 2 { self.extra = buf[1]; }
+            buf[0]
+        })
+    }
+}
diff --git a/str02.rs b/str02.rs
new file mode 100644
index 0000000..96b7634
--- /dev/null
+++ b/str02.rs
@@ -0,0 +1,61 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub fn drop<T>(_x: T) { }
+
+pub enum Option<T> { None, Some(T), }
+
+impl<T> Option<T> {
+    fn map<A>(self, f: |T| -> A) -> Option<A> { loop { } }
+}
+
+mod slice {
+    mod marker {
+        #[lang="contravariant_lifetime"]
+        pub struct ContravariantLifetime<'a>;
+    }
+
+    pub struct Items<'a, T> {
+        ptr: *const T,
+        end: *const T,
+        marker: marker::ContravariantLifetime<'a>
+    }
+}
+
+pub struct Chars<'a> {
+    iter: slice::Items<'a, u8>
+}
+
+pub struct Utf16CodeUnits<'a> {
+    chars: Chars<'a>,
+    extra: u16
+}
+
+impl<'a> Chars<'a> {
+    fn next(&mut self) -> Option<char> { loop { } }
+}
+
+trait EncodeUtf16 {
+    fn encode_utf16(&self, buf: &mut [u16]) -> uint { loop { } }
+}
+
+impl EncodeUtf16 for char { }
+
+fn foo<'a>(c: &mut Utf16CodeUnits<'a>) -> Option<u16> {
+    if c.extra != 0 {
+        let tmp = c.extra;
+        c.extra = 0;
+        return Some(tmp);
+    }
+
+    let mut buf = [0u16, ..2];
+    c.chars.next().map(|ch| {
+        let n = ch.encode_utf16(buf /* as mut slice! */);
+        if n == 2 { c.extra = buf[1]; }
+        buf[0]
+    })
+}

commit 085a3b98a919525a90591d63250686edb12b8045
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Mon Jul 28 14:14:19 2014 +0200

    rust-needsdrop: bug fix to expr_use_visitor.rs post-rebase.
---
 src/librustc/middle/expr_use_visitor.rs | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/librustc/middle/expr_use_visitor.rs b/src/librustc/middle/expr_use_visitor.rs
index e4e7efe..15b1d3a 100644
--- a/src/librustc/middle/expr_use_visitor.rs
+++ b/src/librustc/middle/expr_use_visitor.rs
@@ -484,7 +484,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {
                                                  pat.span,
                                                  ty::ReScope(blk.id),
                                                  pattern_type);
-                self.walk_pat(pat_cmt, pat.clone());
+                self.walk_pat_isolated(pat_cmt, pat.clone());
 
                 self.walk_block(&**blk);
             }

commit fa48d452fe738e39371e398f941ebfb5cef3c73c
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Sun Jul 27 10:14:57 2014 +0200

    rust-needsdrop: add ability to query needs-drop for a particular enum variant.
---
 src/librustc/middle/borrowck/mod.rs       | 34 ++++++++++++++++++++++++++++++++++
 src/librustc/middle/borrowck/move_data.rs |  7 +++----
 2 files changed, 37 insertions(+), 4 deletions(-)

diff --git a/src/librustc/middle/borrowck/mod.rs b/src/librustc/middle/borrowck/mod.rs
index 11984bd..9fee126 100644
--- a/src/librustc/middle/borrowck/mod.rs
+++ b/src/librustc/middle/borrowck/mod.rs
@@ -20,6 +20,7 @@ use middle::def;
 use middle::expr_use_visitor as euv;
 use middle::mem_categorization as mc;
 use middle::ty;
+use middle::subst::Subst;
 use util::ppaux::{note_and_explain_region, Repr, UserString};
 
 use std::cell::{Cell};
@@ -350,6 +351,39 @@ impl LoanPath {
                self.repr(tcx), t.repr(tcx));
         t
     }
+
+    fn needs_drop(&self, tcx: &ty::ctxt) -> bool {
+        //! Returns true if this loan path needs drop glue.  Usually
+        //! this just means that the type of the loan path needs drop
+        //! glue, but an enum can have some variants that need drop
+        //! glue and other variants that do not.
+
+        debug!("needs_drop(tcx) self={}", self.repr(tcx));
+
+        let (lp, variant_def_id) = match *self {
+            LpDowncast(ref lp, def_id) => (lp, def_id),
+            _ => return ty::type_needs_drop(tcx, self.to_type(tcx)),
+        };
+
+        // Code below is to handle one enum variant as a special case.
+
+        let lp_type = lp.to_type(tcx);
+        match ty::get(lp_type).sty {
+            ty::ty_enum(enum_def_id, ref substs) => {
+                let variant_info = ty::enum_variant_with_id(tcx, enum_def_id, variant_def_id);
+                let type_contents = ty::TypeContents::union(
+                    variant_info.args.as_slice(),
+                    |arg_ty| {
+                        let arg_ty_subst = arg_ty.subst(tcx, substs);
+                        debug!("needs_drop(tcx) self={} arg_ty={:s} arg_ty_subst={:s}",
+                               self.repr(tcx), arg_ty.repr(tcx), arg_ty_subst.repr(tcx));
+                        ty::type_contents(tcx, arg_ty_subst)
+                    });
+                type_contents.needs_drop(tcx)
+            }
+            _ => fail!("encountered LpDowncast on non-enum base type."),
+        }
+    }
 }
 
 #[deriving(PartialEq, Eq, Hash)]
diff --git a/src/librustc/middle/borrowck/move_data.rs b/src/librustc/middle/borrowck/move_data.rs
index 6e38aa3..8ce366a 100644
--- a/src/librustc/middle/borrowck/move_data.rs
+++ b/src/librustc/middle/borrowck/move_data.rs
@@ -998,10 +998,9 @@ impl MoveData {
     // The above comment should be revised/shortened to a succinct
     // summary.
 
-    fn type_needs_drop(&self, tcx: &ty::ctxt, move_path_index: MovePathIndex) -> bool {
+    fn path_needs_drop(&self, tcx: &ty::ctxt, move_path_index: MovePathIndex) -> bool {
         //! Returns true iff move_path_index needs drop.
-        let path_type = self.path_loan_path(move_path_index).to_type(tcx);
-        ty::type_needs_drop(tcx, path_type)
+        self.path_loan_path(move_path_index).needs_drop(tcx)
     }
 
     fn type_moves_by_default(&self, tcx: &ty::ctxt, move_path_index: MovePathIndex) -> bool {
@@ -1075,7 +1074,7 @@ impl MoveData {
                        self.path_loan_path(move_path_index).repr(tcx));
             }
 
-            if self.type_needs_drop(tcx, move_path_index) {
+            if self.path_needs_drop(tcx, move_path_index) {
                 debug!("add_drop_obligations(a={}) adds {}",
                        a.to_string_(self, tcx),
                        self.path_loan_path(move_path_index).repr(tcx));

commit 1c83d75bc6f744e06feba8cbe8b1fb0b04a15b6c
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Sun Jul 27 08:10:31 2014 +0200

    rust-needsdrop: Added prepass of all match arms to categorize match as move/borrow/copy.
    
    At one point I was also trying to regather local information about the
    individual pattern, and I may need to put that back in in some form.
    
    But for now this yields nice looking results.
---
 src/librustc/middle/expr_use_visitor.rs | 153 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++------------------------------------
 1 file changed, 106 insertions(+), 47 deletions(-)

diff --git a/src/librustc/middle/expr_use_visitor.rs b/src/librustc/middle/expr_use_visitor.rs
index ca39f17..e4e7efe 100644
--- a/src/librustc/middle/expr_use_visitor.rs
+++ b/src/librustc/middle/expr_use_visitor.rs
@@ -109,6 +109,49 @@ pub enum MoveReason {
 }
 
 #[deriving(PartialEq,Show)]
+enum TrackMatchMode {
+    Unknown, Definite(MatchMode), Conflicting
+}
+
+impl TrackMatchMode {
+    fn meet(&mut self, mode: MatchMode) {
+        *self = match (*self, mode) {
+            (Unknown, new) => Definite(new),
+            (Definite(old), new) if old == new => Definite(old),
+            (Definite(old), ConsumingMatch(Copy)) => Definite(old),
+            (Definite(ConsumingMatch(Copy)), new) => Definite(new),
+            _ => Conflicting
+        };
+    }
+
+    fn mode(self) -> MatchMode {
+        match self {
+            // if we don't know, then there was no binding,
+            // and the match will just borrow.
+            Unknown => BorrowingMatch,
+
+            Definite(mm) => mm,
+
+            // if there were conflicting results, then we will hit a
+            // compiler error later.  But just to let the rustc make
+            // progress now, claim that it was a consuming match.
+            Conflicting => ConsumingMatch(Move(PatBindingMove)),
+        }
+    }
+
+    #[allow(dead_code)]
+    fn mode_within(self, outer_context: &TrackMatchMode) -> MatchMode {
+        match self {
+            // if we don't know, or if this is a copy, then inherit
+            // from the outer_context.
+            Unknown |
+            Definite(ConsumingMatch(Copy)) => outer_context.mode(),
+            _ => self.mode()
+        }
+    }
+}
+
+#[deriving(PartialEq,Show)]
 pub enum MatchMode {
     BorrowingMatch,
     ConsumingMatch(ConsumeMode),
@@ -260,7 +303,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {
                 ty::ReScope(body.id), // Args live only as long as the fn body.
                 arg_ty);
 
-            self.walk_pat(arg_cmt, arg.pat.clone());
+            self.walk_pat_isolated(arg_cmt, arg.pat.clone());
         }
     }
 
@@ -379,8 +422,12 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {
                 // walking the arms:
                 self.walk_expr(&**discr);
                 let discr_cmt = return_if_err!(self.mc.cat_expr(&**discr));
+                let mut mode = Unknown;
+                for arm in arms.iter() {
+                    self.walk_arm_prepass(discr_cmt.clone(), arm, &mut mode);
+                }
                 for arm in arms.iter() {
-                    self.walk_arm(discr_cmt.clone(), arm);
+                    self.walk_arm(discr_cmt.clone(), arm, &mode);
                 }
             }
 
@@ -606,7 +653,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {
                 // `walk_pat`:
                 self.walk_expr(&**expr);
                 let init_cmt = return_if_err!(self.mc.cat_expr(&**expr));
-                self.walk_pat(init_cmt, local.pat);
+                self.walk_pat_isolated(init_cmt, local.pat);
             }
         }
     }
@@ -809,9 +856,15 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {
         return true;
     }
 
-    fn walk_arm(&mut self, discr_cmt: mc::cmt, arm: &ast::Arm) {
+    fn walk_arm_prepass(&mut self, discr_cmt: mc::cmt, arm: &ast::Arm, mode: &mut TrackMatchMode) {
+        for &pat in arm.pats.iter() {
+            self.walk_pat_prepass(discr_cmt.clone(), pat, mode);
+        }
+    }
+
+    fn walk_arm(&mut self, discr_cmt: mc::cmt, arm: &ast::Arm, mode: &TrackMatchMode) {
         for &pat in arm.pats.iter() {
-            self.walk_pat(discr_cmt.clone(), pat);
+            self.walk_pat(discr_cmt.clone(), pat, mode);
         }
 
         for guard in arm.guard.iter() {
@@ -821,51 +874,61 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {
         self.consume_expr(&*arm.body);
     }
 
-    fn walk_pat(&mut self, cmt_discr: mc::cmt, pat: Gc<ast::Pat>) {
-        debug!("walk_pat cmt_discr={} pat={}", cmt_discr.repr(self.tcx()),
-               pat.repr(self.tcx()));
-        let mc = &self.mc;
-        let typer = self.typer;
-        let tcx = typer.tcx();
-        let def_map = &self.typer.tcx().def_map;
-        let delegate = &mut self.delegate;
-
-        enum TrackMatchMode {
-            Unknown, Definite(MatchMode), Conflicting
-        }
-        impl TrackMatchMode {
-            fn meet(&mut self, mode: MatchMode) {
-                *self = match (*self, mode) {
-                    (Unknown, new) => Definite(new),
-
-                    (Definite(old), new) if old == new => Definite(old),
+    /// Walks a pat that occurs in isolation (i.e. top-level of a fn
+    /// arg or let binding.  *Not* a match arm or nested pat.)
+    fn walk_pat_isolated(&mut self, cmt_discr: mc::cmt, pat: Gc<ast::Pat>) {
+        let mut mode = Unknown;
+        self.walk_pat_prepass(cmt_discr.clone(), pat, &mut mode);
+        self.walk_pat(cmt_discr, pat, &mode);
+    }
 
-                    (Definite(old), ConsumingMatch(Copy)) => Definite(old),
+    /// Identifies any bindings within `pat` and accumulates within
+    /// `mode` whether the overall pattern/match structure is a move,
+    /// copy, or borrow.
+    fn walk_pat_prepass(&mut self,
+                        cmt_discr: mc::cmt,
+                        pat: Gc<ast::Pat>,
+                        mode: &mut TrackMatchMode) {
+        debug!("walk_pat_prepass cmt_discr={} pat={}", cmt_discr.repr(self.tcx()),
+               pat.repr(self.tcx()));
 
-                    (Definite(ConsumingMatch(Copy)), new) => Definite(new),
+        return_if_err!(self.mc.cat_pattern(cmt_discr.clone(), &*pat, |_mc, cmt_pat, pat| {
+            let tcx = self.typer.tcx();
+            let def_map = &tcx.def_map;
+            if pat_util::pat_is_binding(def_map, pat) {
+                debug!("prepass binding cmt_pat={} pat={}", cmt_pat.repr(tcx), pat.repr(tcx));
 
-                    _ => Conflicting
-                };
+                match pat.node {
+                    ast::PatIdent(ast::BindByRef(_), _, _) =>
+                        mode.meet(BorrowingMatch),
+                    ast::PatIdent(ast::BindByValue(_), _, _) =>
+                        mode.meet(ConsumingMatch(copy_or_move(tcx, cmt_pat.ty, PatBindingMove))),
+                    _ => {
+                        // we will report the error here in the actual
+                        // pass, after the prepass is completed.
+                    }
+                }
             }
+        }));
+    }
 
-            fn mode(self) -> MatchMode {
-                match self {
-                    // if we don't know, then there was no binding,
-                    // and the match will just borrow.
-                    Unknown => BorrowingMatch,
-
-                    Definite(mm) => mm,
+    fn walk_pat(&mut self,
+                cmt_discr: mc::cmt,
+                pat: Gc<ast::Pat>,
+                outer_context_mode: &TrackMatchMode) {
+        debug!("walk_pat cmt_discr={} pat={} outer_context_mode={}",
+               cmt_discr.repr(self.tcx()), pat.repr(self.tcx()), outer_context_mode);
 
-                    // if there were conflicting results, then we will
-                    // hit a compiler error later.  But just to let
-                    // the rustc make progress now, claim that it was
-                    // a consuming match.
-                    Conflicting => ConsumingMatch(Move(PatBindingMove)),
-                }
-            }
-        }
+        // let mut local_mode = Unknown;
+        // self.walk_pat_prepass(cmt_discr.clone(), pat, &mut local_mode);
+        // let match_mode = local_mode.mode_within(outer_context_mode);
+        let match_mode = outer_context_mode.mode();
 
-        let mut match_mode = Unknown;
+        let mc = &self.mc;
+        let typer = self.typer;
+        let tcx = typer.tcx();
+        let def_map = &self.typer.tcx().def_map;
+        let delegate = &mut self.delegate;
 
         return_if_err!(mc.cat_pattern(cmt_discr.clone(), &*pat, |mc, cmt_pat, pat| {
             if pat_util::pat_is_binding(def_map, pat) {
@@ -897,13 +960,11 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {
                         };
                         delegate.borrow(pat.id, pat.span, cmt_pat,
                                              r, bk, RefBinding);
-                        match_mode.meet(BorrowingMatch);
                     }
                     ast::PatIdent(ast::BindByValue(_), _, _) => {
                         let mode = copy_or_move(typer.tcx(), cmt_pat.ty, PatBindingMove);
                         debug!("walk_pat binding consuming pat");
                         delegate.consume_pat(pat, cmt_pat, mode);
-                        match_mode.meet(ConsumingMatch(mode));
                     }
                     _ => {
                         typer.tcx().sess.span_bug(
@@ -959,8 +1020,6 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {
             }
         }));
 
-        let match_mode = match_mode.mode();
-
         return_if_err!(mc.cat_pattern(cmt_discr, &*pat, |mc, cmt_pat, pat| {
             let def_map = def_map.borrow();
             let tcx = typer.tcx();

commit 107df2a9a26132a9205bcfab138023756c951118
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Sat Jul 26 12:38:33 2014 +0200

    rust-needsdrop: checkpoint, very fun.  Got plausible looking dataflow for foo11.rs.
---
 src/librustc/middle/borrowck/gather_loans/gather_moves.rs |  2 +-
 src/librustc/middle/borrowck/mod.rs                       |  2 +-
 src/librustc/middle/borrowck/move_data.rs                 | 36 ++++++++++++++++--------------------
 3 files changed, 18 insertions(+), 22 deletions(-)

diff --git a/src/librustc/middle/borrowck/gather_loans/gather_moves.rs b/src/librustc/middle/borrowck/gather_loans/gather_moves.rs
index e15b69b..5bcf0a2 100644
--- a/src/librustc/middle/borrowck/gather_loans/gather_moves.rs
+++ b/src/librustc/middle/borrowck/gather_loans/gather_moves.rs
@@ -70,7 +70,7 @@ pub fn gather_move_into_variant(bccx: &BorrowckCtxt,
 
     let opt_lp = opt_loan_path(&cmt, bccx.tcx);
     let opt_base_lp = match cmt.cat {
-        mc::cat_downcast(ref base_cmt, variant_def_id) => opt_loan_path(base_cmt, bccx.tcx),
+        mc::cat_downcast(ref base_cmt, _variant_def_id) => opt_loan_path(base_cmt, bccx.tcx),
         _ => fail!("should only encounter move_into_variant on cat_downcast."),
     };
     match (opt_lp, opt_base_lp) {
diff --git a/src/librustc/middle/borrowck/mod.rs b/src/librustc/middle/borrowck/mod.rs
index 14734c2..11984bd 100644
--- a/src/librustc/middle/borrowck/mod.rs
+++ b/src/librustc/middle/borrowck/mod.rs
@@ -879,7 +879,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {
             LpDowncast(ref lp_base, variant_def_id) => {
                 out.push_char('(');
                 self.append_loan_path_to_string(&**lp_base, out);
-                out.push_char(':');
+                out.push_str("->");
                 out.push_str(ty::item_path_str(self.tcx, variant_def_id).as_slice());
                 out.push_char(')');
             }
diff --git a/src/librustc/middle/borrowck/move_data.rs b/src/librustc/middle/borrowck/move_data.rs
index 90865c3..6e38aa3 100644
--- a/src/librustc/middle/borrowck/move_data.rs
+++ b/src/librustc/middle/borrowck/move_data.rs
@@ -311,18 +311,21 @@ impl MoveData {
 
     /// Returns true iff `index` itself cannot be directly split into
     /// child fragments.  This means it is an atomic value (like a
-    /// pointer or an integer), or it an enum (and so we can only
-    /// split off subparts when we narrow it to a particular variant),
-    /// or it is a struct whose fields are never accessed in the
-    /// function being compiled.
-    fn path_is_leaf(&self, index: MovePathIndex, tcx: &ty::ctxt) -> bool {
-
-        let lp = self.path_loan_path(index);
-        let lp_type = lp.to_type(tcx);
-        let is_enum = match ty::get(lp_type).sty {
-            ty::ty_enum(..) => true, _ => false,
-        };
-        return is_enum || self.path_first_child(index) == InvalidMovePathIndex
+    /// pointer or an integer), or it a non-downcasted enum (and so we
+    /// can only split off subparts when we narrow it to a particular
+    /// variant), or it is a struct whose fields are never accessed in
+    /// the function being compiled.
+    fn path_is_leaf(&self, index: MovePathIndex, _tcx: &ty::ctxt) -> bool {
+
+        let first_child = self.path_first_child(index);
+        if first_child == InvalidMovePathIndex {
+            true
+        } else {
+            match *self.path_loan_path(first_child) {
+                LpDowncast(..) => true,
+                LpVar(..) | LpUpvar(..) | LpExtend(..) => false,
+            }
+        }
     }
 
     /// Returns true iff `index` represents downcast to an enum variant (i.e. LpDowncast).
@@ -1011,7 +1014,7 @@ impl MoveData {
                      tcx: &ty::ctxt,
                      root: MovePathIndex,
                      found_leaf: |MovePathIndex|,
-                     found_variant: |MovePathIndex|) {
+                     _found_variant: |MovePathIndex|) {
         //! Here we normalize a path so that it is unraveled to its
         //! consituent droppable pieces that might be independently
         //! handled by the function being compiled: e.g. `s.a.j`
@@ -1030,11 +1033,6 @@ impl MoveData {
             return;
         }
 
-        if self.path_is_downcast_to_variant(root) {
-            found_variant(root);
-            return;
-        }
-
         let mut stack = vec![];
         stack.push(root);
         loop {
@@ -1054,8 +1052,6 @@ impl MoveData {
 
                 if self.path_is_leaf(child, tcx) {
                     found_leaf(child);
-                } else if self.path_is_downcast_to_variant(child) {
-                    found_variant(child);
                 } else {
                     stack.push(child);
                 }

commit 57e191fab42f65c46aeec6e4ef7ed4c8f6ee9606
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Sat Jul 26 12:09:24 2014 +0200

    rust-needsdrop: Checkpoint, implmented variant recognition in euv through move_data.
    
    Added `matched_pat` method to ExprUseVisitor.
    
    Treat a variant match as *removing* the drop obligation for the enum
    value that was matched, and *adding* the drop obligation for the
    variant itself.
---
 src/librustc/middle/borrowck/check_loans.rs               |   6 ++++
 src/librustc/middle/borrowck/gather_loans/gather_moves.rs |  27 ++++++++++++++
 src/librustc/middle/borrowck/gather_loans/mod.rs          |  21 +++++++++++
 src/librustc/middle/borrowck/mod.rs                       |   2 +-
 src/librustc/middle/borrowck/move_data.rs                 | 186 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-------------------
 src/librustc/middle/expr_use_visitor.rs                   |  98 ++++++++++++++++++++++++++++++++++++++++++++++++++-
 src/librustc/middle/mem_categorization.rs                 |  25 ++++++++-----
 7 files changed, 319 insertions(+), 46 deletions(-)

diff --git a/src/librustc/middle/borrowck/check_loans.rs b/src/librustc/middle/borrowck/check_loans.rs
index dfeb382..f09c350 100644
--- a/src/librustc/middle/borrowck/check_loans.rs
+++ b/src/librustc/middle/borrowck/check_loans.rs
@@ -98,6 +98,12 @@ impl<'a, 'tcx> euv::Delegate for CheckLoanCtxt<'a, 'tcx> {
         self.consume_common(consume_id, consume_span, cmt, mode);
     }
 
+    fn matched_pat(&mut self,
+                   _matched_pat: &ast::Pat,
+                   _cmt: mc::cmt,
+                   _mode: euv::MatchMode) { }
+
+
     fn consume_pat(&mut self,
                    consume_pat: &ast::Pat,
                    cmt: mc::cmt,
diff --git a/src/librustc/middle/borrowck/gather_loans/gather_moves.rs b/src/librustc/middle/borrowck/gather_loans/gather_moves.rs
index e0ca21a..e15b69b 100644
--- a/src/librustc/middle/borrowck/gather_loans/gather_moves.rs
+++ b/src/librustc/middle/borrowck/gather_loans/gather_moves.rs
@@ -60,6 +60,33 @@ pub fn gather_move_from_expr(bccx: &BorrowckCtxt,
     gather_move(bccx, move_data, move_error_collector, move_info);
 }
 
+pub fn gather_move_into_variant(bccx: &BorrowckCtxt,
+                                move_data: &MoveData,
+                                _move_error_collector: &MoveErrorCollector,
+                                move_pat: &ast::Pat,
+                                cmt: mc::cmt) { 
+    debug!("gather_match(move_pat={}, cmt={})",
+           move_pat.id, cmt.repr(bccx.tcx));
+
+    let opt_lp = opt_loan_path(&cmt, bccx.tcx);
+    let opt_base_lp = match cmt.cat {
+        mc::cat_downcast(ref base_cmt, variant_def_id) => opt_loan_path(base_cmt, bccx.tcx),
+        _ => fail!("should only encounter move_into_variant on cat_downcast."),
+    };
+    match (opt_lp, opt_base_lp) {
+        (Some(loan_path), Some(base_loan_path)) => {
+            move_data.add_variant_match(bccx.tcx,
+                                        loan_path,
+                                        move_pat.id,
+                                        base_loan_path);
+        }
+        (lp, base_lp) => {
+            debug!("add_variant_match body for ({:?}, {:?}) NOT YET IMPLEMENTED", lp, base_lp);
+        }
+    }
+
+}
+
 pub fn gather_move_from_pat(bccx: &BorrowckCtxt,
                             move_data: &MoveData,
                             move_error_collector: &MoveErrorCollector,
diff --git a/src/librustc/middle/borrowck/gather_loans/mod.rs b/src/librustc/middle/borrowck/gather_loans/mod.rs
index 42f758e..d6e4f2a 100644
--- a/src/librustc/middle/borrowck/gather_loans/mod.rs
+++ b/src/librustc/middle/borrowck/gather_loans/mod.rs
@@ -84,6 +84,27 @@ impl<'a, 'tcx> euv::Delegate for GatherLoanCtxt<'a, 'tcx> {
         }
     }
 
+    fn matched_pat(&mut self,
+                   matched_pat: &ast::Pat,
+                   cmt: mc::cmt,
+                   mode: euv::MatchMode) {
+        debug!("matched_pat(matched_pat={}, cmt={}, mode={})",
+               matched_pat.repr(self.tcx()),
+               cmt.repr(self.tcx()),
+               mode);
+
+        match mode {
+            euv::BorrowingMatch |
+            euv::ConsumingMatch(euv::Copy) => return,
+            euv::ConsumingMatch(euv::Move(_)) => {}
+        }
+
+        gather_moves::gather_move_into_variant(
+            self.bccx, &self.move_data, &self.move_error_collector,
+            matched_pat, cmt);
+    }
+
+
     fn consume_pat(&mut self,
                    consume_pat: &ast::Pat,
                    cmt: mc::cmt,
diff --git a/src/librustc/middle/borrowck/mod.rs b/src/librustc/middle/borrowck/mod.rs
index 5319c08..14734c2 100644
--- a/src/librustc/middle/borrowck/mod.rs
+++ b/src/librustc/middle/borrowck/mod.rs
@@ -1010,7 +1010,7 @@ impl Repr for LoanPath {
                 } else {
                     variant_def_id.repr(tcx)
                 };
-                format!("({} as {})", lp.repr(tcx), variant_str)
+                format!("({}->{})", lp.repr(tcx), variant_str)
             }
         }
     }
diff --git a/src/librustc/middle/borrowck/move_data.rs b/src/librustc/middle/borrowck/move_data.rs
index 7fd77eb..90865c3 100644
--- a/src/librustc/middle/borrowck/move_data.rs
+++ b/src/librustc/middle/borrowck/move_data.rs
@@ -53,6 +53,10 @@ pub struct MoveData {
     /// kill move bits.
     pub path_assignments: RefCell<Vec<Assignment>>,
 
+    /// Enum variant matched within a pattern on some match arm, like
+    /// `SomeStruct{ f: Variant1(x, y) } => ...`
+    pub variant_matches: RefCell<Vec<VariantMatch>>,
+
     /// Assignments to a variable or path, like `x = foo`, but not `x += foo`.
     pub assignee_ids: RefCell<HashSet<ast::NodeId>>,
 
@@ -165,6 +169,17 @@ pub struct Assignment {
     pub span: Span,
 }
 
+pub struct VariantMatch {
+    /// downcast to the variant.
+    pub path: MovePathIndex,
+
+    /// path being downcast to the variant.
+    pub base_path: MovePathIndex,
+
+    /// id where variant's pattern occurs
+    pub id: ast::NodeId,
+}
+
 #[deriving(Clone)]
 pub struct MoveDataFlowOperator;
 
@@ -248,6 +263,25 @@ impl Assignment {
     }
 }
 
+impl VariantMatch {
+    pub fn ty_and_span(&self, tcx: &ty::ctxt) -> (ty::t, Span) {
+        match tcx.map.find(self.id) {
+            Some(ast_map::NodePat(pat)) => (ty::pat_ty(tcx, &*pat), pat.span),
+            r => tcx.sess.bug(format!("{:?} maps to {:?}, not Pat", self, r).as_slice())
+        }
+    }
+    pub fn ty(&self, tcx: &ty::ctxt) -> ty::t {
+        self.ty_and_span(tcx).val0()
+    }
+    pub fn to_string(&self, move_data: &MoveData, tcx: &ty::ctxt) -> String {
+        format!("VariantMatch{:s} path: {}, id: {} {:s}",
+                "{",
+                move_data.path_loan_path(self.path).repr(tcx),
+                self.id,
+                "}")
+    }
+}
+
 impl MoveData {
     pub fn new() -> MoveData {
         MoveData {
@@ -256,6 +290,7 @@ impl MoveData {
             moves: RefCell::new(Vec::new()),
             path_assignments: RefCell::new(Vec::new()),
             var_assignments: RefCell::new(Vec::new()),
+            variant_matches: RefCell::new(Vec::new()),
             assignee_ids: RefCell::new(HashSet::new()),
             fragments: RefCell::new(Vec::new()),
             nonfragments: RefCell::new(Vec::new()),
@@ -274,9 +309,20 @@ impl MoveData {
         self.paths.borrow().get(index.get()).first_move
     }
 
-    /// Returns true iff `index` has no children.
-    fn path_is_leaf(&self, index: MovePathIndex) -> bool {
-        self.path_first_child(index) == InvalidMovePathIndex
+    /// Returns true iff `index` itself cannot be directly split into
+    /// child fragments.  This means it is an atomic value (like a
+    /// pointer or an integer), or it an enum (and so we can only
+    /// split off subparts when we narrow it to a particular variant),
+    /// or it is a struct whose fields are never accessed in the
+    /// function being compiled.
+    fn path_is_leaf(&self, index: MovePathIndex, tcx: &ty::ctxt) -> bool {
+
+        let lp = self.path_loan_path(index);
+        let lp_type = lp.to_type(tcx);
+        let is_enum = match ty::get(lp_type).sty {
+            ty::ty_enum(..) => true, _ => false,
+        };
+        return is_enum || self.path_first_child(index) == InvalidMovePathIndex
     }
 
     /// Returns true iff `index` represents downcast to an enum variant (i.e. LpDowncast).
@@ -339,10 +385,6 @@ impl MoveData {
         }
 
         let index = match *lp {
-            LpDowncast(ref base, _) => {
-                return self.move_path(tcx, base.clone());
-            }
-
             LpVar(..) | LpUpvar(..) => {
                 let index = MovePathIndex(self.paths.borrow().len());
 
@@ -357,6 +399,7 @@ impl MoveData {
                 index
             }
 
+            LpDowncast(ref base, _) |
             LpExtend(ref base, _, _) => {
                 let parent_index = self.move_path(tcx, base.clone());
 
@@ -505,6 +548,33 @@ impl MoveData {
         }
     }
 
+    pub fn add_variant_match(&self,
+                         tcx: &ty::ctxt,
+                         lp: Rc<LoanPath>,
+                         pattern_id: ast::NodeId,
+                         base_lp: Rc<LoanPath>) {
+        /*!
+         * Adds a new record for an match of `base_lp`, downcast to
+         * variant `lp`, that occurs at location `pattern_id`.  (One
+         * should be able to recover teh span info from the
+         * `pattern_id` and the ast_map, I think.)
+         */
+        debug!("add_variant_match(lp={}, pattern_id={:?})",
+               lp.repr(tcx), pattern_id);
+
+        let path_index = self.move_path(tcx, lp.clone());
+        let base_path_index = self.move_path(tcx, base_lp.clone());
+
+        self.nonfragments.borrow_mut().push(path_index);
+        let variant_match = VariantMatch {
+            path: path_index,
+            base_path: base_path_index,
+            id: pattern_id,
+        };
+
+        self.variant_matches.borrow_mut().push(variant_match);
+    }
+
     fn add_fragment_siblings(&self,
                              tcx: &ty::ctxt,
                              lp: Rc<LoanPath>,
@@ -721,6 +791,13 @@ impl MoveData {
             self.remove_drop_obligations(tcx, move, dfcx_needs_drop);
         }
 
+        for variant_match in self.variant_matches.borrow().iter() {
+            debug!("remove_drop_obligations variant_match {}", variant_match.to_string(self, tcx));
+            self.remove_drop_obligations(tcx, variant_match, dfcx_needs_drop);
+            debug!("add_drop_obligations variant_match {}", variant_match.to_string(self, tcx));
+            self.add_drop_obligations(tcx, variant_match, dfcx_needs_drop);
+        }
+
         for (i, assignment) in self.var_assignments.borrow().iter().enumerate() {
             dfcx_assign.add_gen(assignment.id, i);
             self.kill_moves(assignment.path, assignment.id, dfcx_moves);
@@ -746,7 +823,7 @@ impl MoveData {
                     debug!("remove_drop_obligations scope {} {}",
                            kill_id, path.loan_path.repr(tcx));
                     let rm = Removed { where: kill_id, what_path: move_path_index };
-                    self.remove_drop_obligations(tcx, rm, dfcx_needs_drop);
+                    self.remove_drop_obligations(tcx, &rm, dfcx_needs_drop);
                 }
                 LpUpvar(ty::UpvarId { var_id: _, closure_expr_id }) => {
                     let kill_id = closure_to_block(closure_expr_id, tcx);
@@ -755,7 +832,7 @@ impl MoveData {
                     debug!("remove_drop_obligations scope {} {}",
                            kill_id, path.loan_path.repr(tcx));
                     let rm = Removed { where: kill_id, what_path: move_path_index };
-                    self.remove_drop_obligations(tcx, rm, dfcx_needs_drop);
+                    self.remove_drop_obligations(tcx, &rm, dfcx_needs_drop);
                 }
                 LpDowncast(..) => {} // FIXME: is this right, or should this loop to top?
                 LpExtend(..) => {}
@@ -931,7 +1008,7 @@ impl MoveData {
     }
 
     fn for_each_leaf(&self,
-                     _tcx: &ty::ctxt,
+                     tcx: &ty::ctxt,
                      root: MovePathIndex,
                      found_leaf: |MovePathIndex|,
                      found_variant: |MovePathIndex|) {
@@ -945,7 +1022,10 @@ impl MoveData {
         //! Note that the callback is only invoked on unraveled leaves
         //! that also need to be dropped.
 
-        if self.path_is_leaf(root) {
+        let root_lp = self.path_loan_path(root);
+        debug!("for_each_leaf(root_lp={:s})", root_lp.repr(tcx));
+
+        if self.path_is_leaf(root, tcx) {
             found_leaf(root);
             return;
         }
@@ -959,14 +1039,23 @@ impl MoveData {
         stack.push(root);
         loop {
             let top = match stack.pop() { None => break, Some(elem) => elem };
-            assert!(!self.path_is_leaf(top));
+            assert!(!self.path_is_leaf(top, tcx));
             let mut child = self.path_first_child(top);
             while child != InvalidMovePathIndex {
-                if self.path_is_leaf(child) {
+                {
+                    let top_lp = self.path_loan_path(top);
+                    let child_lp = self.path_loan_path(child);
+                    debug!("for_each_leaf(root_lp={:s}){:s} top_lp={:s} child_lp={:s}",
+                           root_lp.repr(tcx),
+                           " ".repeat(stack.len()),
+                           top_lp.repr(tcx),
+                           child_lp.repr(tcx));
+                }
+
+                if self.path_is_leaf(child, tcx) {
                     found_leaf(child);
                 } else if self.path_is_downcast_to_variant(child) {
                     found_variant(child);
-                    continue;
                 } else {
                     stack.push(child);
                 }
@@ -976,45 +1065,52 @@ impl MoveData {
         }
     }
 
-    fn add_drop_obligations(&self,
-                            tcx: &ty::ctxt,
-                            assignment: &Assignment,
-                            dfcx_needs_drop: &mut NeedsDropDataFlow) {
+    fn add_drop_obligations<A:AddNeedsDropArg>(&self,
+                                               tcx: &ty::ctxt,
+                                               a: &A,
+                                               dfcx_needs_drop: &mut NeedsDropDataFlow) {
+        let a_id = a.node_id_adding_obligation();
+        let a_path = a.path_being_established();
+
         let add_gen = |move_path_index| {
-            if self.path_is_downcast_to_variant(move_path_index) {
-                // A downcast to a variant occurs on a match arm.
-                // It does not in itself add a drop-obligation; those
-                // come from the variable bindings within the match arm.
-                return;
+            if self.path_is_downcast_to_variant(a_path) {
+                debug!("add_drop_obligations(a={}) {} is variant on match arm",
+                       a.to_string_(self, tcx),
+                       self.path_loan_path(move_path_index).repr(tcx));
             }
 
             if self.type_needs_drop(tcx, move_path_index) {
-                debug!("add_drop_obligations(assignment={}) adds {}",
-                       assignment.to_string(self, tcx),
+                debug!("add_drop_obligations(a={}) adds {}",
+                       a.to_string_(self, tcx),
                        self.path_loan_path(move_path_index).repr(tcx));
-                dfcx_needs_drop.add_gen(assignment.id, move_path_index.get());
+                dfcx_needs_drop.add_gen(a_id, move_path_index.get());
             } else {
-                debug!("add_drop_obligations(assignment={}) skips non-drop {}",
-                       assignment.to_string(self, tcx),
+                debug!("add_drop_obligations(a={}) skips non-drop {}",
+                       a.to_string_(self, tcx),
                        self.path_loan_path(move_path_index).repr(tcx));
             }
         };
 
         let report_variant = |move_path_index| {
-            debug!("add_drop_obligations(assignment={}) skips variant {}",
-                   assignment.to_string(self, tcx),
+            debug!("add_drop_obligations(a={}) skips variant {}",
+                   a.to_string_(self, tcx),
                    self.path_loan_path(move_path_index).repr(tcx));
         };
 
-        self.for_each_leaf(tcx, assignment.path, add_gen, report_variant);
+        self.for_each_leaf(tcx, a_path, add_gen, report_variant);
     }
 
     fn remove_drop_obligations<A:RemoveNeedsDropArg>(&self,
                                                      tcx: &ty::ctxt,
-                                                     a: A,
+                                                     a: &A,
                                                      dfcx_needs_drop: &mut NeedsDropDataFlow) {
-        //! Kill path and all of its sub-paths.
-        //! Adds fragment-siblings of path as necessary.
+        //! Kills all of the fragment leaves of path.
+        //!
+        //! Also kills all parents of path: while we do normalize a
+        //! path to its fragment leaves, (e.g. `a.j` to `{a.j.x,
+        //! a.j.y, a.j.z}`, an enum variant's path `(b:Variant1).x`
+        //! has the parent `b` that is itself considered a "leaf" for
+        //! the purposes of tracking drop obligations.
 
         let id = a.node_id_removing_obligation();
         let path : MovePathIndex = a.path_being_moved();
@@ -1039,6 +1135,22 @@ impl MoveData {
     }
 }
 
+trait AddNeedsDropArg {
+    fn node_id_adding_obligation(&self) -> ast::NodeId;
+    fn path_being_established(&self) -> MovePathIndex;
+    fn to_string_(&self, move_data: &MoveData, tcx: &ty::ctxt) -> String;
+}
+impl AddNeedsDropArg for Assignment {
+    fn node_id_adding_obligation(&self) -> ast::NodeId { self.id }
+    fn path_being_established(&self) -> MovePathIndex { self.path }
+    fn to_string_(&self, md: &MoveData, tcx: &ty::ctxt) -> String { self.to_string(md, tcx) }
+}
+impl AddNeedsDropArg for VariantMatch {
+    fn node_id_adding_obligation(&self) -> ast::NodeId { self.id }
+    fn path_being_established(&self) -> MovePathIndex { self.path }
+    fn to_string_(&self, md: &MoveData, tcx: &ty::ctxt) -> String { self.to_string(md, tcx) }
+}
+
 trait RemoveNeedsDropArg {
     fn node_id_removing_obligation(&self) -> ast::NodeId;
     fn path_being_moved(&self) -> MovePathIndex;
@@ -1048,10 +1160,14 @@ impl RemoveNeedsDropArg for Removed {
     fn node_id_removing_obligation(&self) -> ast::NodeId { self.where }
     fn path_being_moved(&self) -> MovePathIndex { self.what_path }
 }
-impl<'a> RemoveNeedsDropArg for &'a Move {
+impl<'a> RemoveNeedsDropArg for Move {
     fn node_id_removing_obligation(&self) -> ast::NodeId { self.id }
     fn path_being_moved(&self) -> MovePathIndex { self.path }
 }
+impl<'a> RemoveNeedsDropArg for VariantMatch {
+    fn node_id_removing_obligation(&self) -> ast::NodeId { self.id }
+    fn path_being_moved(&self) -> MovePathIndex { self.base_path }
+}
 
 impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {
     pub fn new(move_data: MoveData,
diff --git a/src/librustc/middle/expr_use_visitor.rs b/src/librustc/middle/expr_use_visitor.rs
index 207620b..ca39f17 100644
--- a/src/librustc/middle/expr_use_visitor.rs
+++ b/src/librustc/middle/expr_use_visitor.rs
@@ -42,6 +42,18 @@ pub trait Delegate {
                cmt: mc::cmt,
                mode: ConsumeMode);
 
+    // The value found at `cmt` has been determined to match the
+    // pattern binding `matched_pat`, and its subparts are being
+    // copied or moved depending on `mode`.  Note that `matched_pat`
+    // is called on all variant/structs in the pattern (i.e., the
+    // interior nodes of the pattern's tree structure) while
+    // consume_pat is called on the binding identifiers in the pattern
+    // (i.e., the leaves of the pattern's tree structure)
+    fn matched_pat(&mut self,
+                   matched_pat: &ast::Pat,
+                   cmt: mc::cmt,
+                   mode: MatchMode);
+
     // The value found at `cmt` is either copied or moved via the
     // pattern binding `consume_pat`, depending on mode.
     fn consume_pat(&mut self,
@@ -97,6 +109,12 @@ pub enum MoveReason {
 }
 
 #[deriving(PartialEq,Show)]
+pub enum MatchMode {
+    BorrowingMatch,
+    ConsumingMatch(ConsumeMode),
+}
+
+#[deriving(PartialEq,Show)]
 pub enum MutateMode {
     Init,
     JustWrite,    // x = y
@@ -811,7 +829,45 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {
         let tcx = typer.tcx();
         let def_map = &self.typer.tcx().def_map;
         let delegate = &mut self.delegate;
-        return_if_err!(mc.cat_pattern(cmt_discr, &*pat, |mc, cmt_pat, pat| {
+
+        enum TrackMatchMode {
+            Unknown, Definite(MatchMode), Conflicting
+        }
+        impl TrackMatchMode {
+            fn meet(&mut self, mode: MatchMode) {
+                *self = match (*self, mode) {
+                    (Unknown, new) => Definite(new),
+
+                    (Definite(old), new) if old == new => Definite(old),
+
+                    (Definite(old), ConsumingMatch(Copy)) => Definite(old),
+
+                    (Definite(ConsumingMatch(Copy)), new) => Definite(new),
+
+                    _ => Conflicting
+                };
+            }
+
+            fn mode(self) -> MatchMode {
+                match self {
+                    // if we don't know, then there was no binding,
+                    // and the match will just borrow.
+                    Unknown => BorrowingMatch,
+
+                    Definite(mm) => mm,
+
+                    // if there were conflicting results, then we will
+                    // hit a compiler error later.  But just to let
+                    // the rustc make progress now, claim that it was
+                    // a consuming match.
+                    Conflicting => ConsumingMatch(Move(PatBindingMove)),
+                }
+            }
+        }
+
+        let mut match_mode = Unknown;
+
+        return_if_err!(mc.cat_pattern(cmt_discr.clone(), &*pat, |mc, cmt_pat, pat| {
             if pat_util::pat_is_binding(def_map, pat) {
                 let tcx = typer.tcx();
 
@@ -841,11 +897,13 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {
                         };
                         delegate.borrow(pat.id, pat.span, cmt_pat,
                                              r, bk, RefBinding);
+                        match_mode.meet(BorrowingMatch);
                     }
                     ast::PatIdent(ast::BindByValue(_), _, _) => {
                         let mode = copy_or_move(typer.tcx(), cmt_pat.ty, PatBindingMove);
                         debug!("walk_pat binding consuming pat");
                         delegate.consume_pat(pat, cmt_pat, mode);
+                        match_mode.meet(ConsumingMatch(mode));
                     }
                     _ => {
                         typer.tcx().sess.span_bug(
@@ -900,6 +958,44 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {
                 }
             }
         }));
+
+        let match_mode = match_mode.mode();
+
+        return_if_err!(mc.cat_pattern(cmt_discr, &*pat, |mc, cmt_pat, pat| {
+            let def_map = def_map.borrow();
+            let tcx = typer.tcx();
+            match pat.node {
+                ast::PatEnum(_, _) | ast::PatIdent(_, _, None) | ast::PatStruct(..) => {
+                    match def_map.find(&pat.id) {
+                        Some(&def::DefVariant(enum_did, variant_did, _is_struct)) => {
+                            let downcast_cmt =
+                                if ty::enum_is_univariant(tcx, enum_did) {
+                                    cmt_pat
+                                } else {
+                                    let cmt_pat_ty = cmt_pat.ty;
+                                    mc.cat_downcast(pat, cmt_pat, cmt_pat_ty, variant_did)
+                                };
+
+                            debug!("variant downcast_cmt={} pat={}",
+                                   downcast_cmt.repr(tcx),
+                                   pat.repr(tcx));
+
+                            delegate.matched_pat(pat, downcast_cmt, match_mode);
+                        }
+
+                        Some(&def::DefStruct(..)) => {
+                            debug!("struct cmt_pat={} pat={}",
+                                   cmt_pat.repr(tcx),
+                                   pat.repr(tcx));
+
+                            delegate.matched_pat(pat, cmt_pat, match_mode);
+                        }
+                        _ => {}
+                    }
+                }
+                _ => {}
+            }
+        }));
     }
 
     fn walk_captures(&mut self, closure_expr: &ast::Expr) {
diff --git a/src/librustc/middle/mem_categorization.rs b/src/librustc/middle/mem_categorization.rs
index 38c4f0d..9c0d364 100644
--- a/src/librustc/middle/mem_categorization.rs
+++ b/src/librustc/middle/mem_categorization.rs
@@ -976,13 +976,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {
                                     downcast_ty: ty::t,
                                     variant_did: ast::DefId)
                                     -> cmt {
-        Rc::new(cmt_ {
-            id: node.id(),
-            span: node.span(),
-            mutbl: base_cmt.mutbl.inherit(),
-            cat: cat_downcast(base_cmt, variant_did),
-            ty: downcast_ty
-        })
+        mk_cat_downcast(node, base_cmt, downcast_ty, variant_did)
     }
 
     pub fn cat_pattern(&self,
@@ -1221,6 +1215,19 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {
     }
 }
 
+fn mk_cat_downcast<N:ast_node>(node: &N,
+                               base_cmt: cmt,
+                               downcast_ty: ty::t,
+                               variant_did: ast::DefId) -> cmt {
+    Rc::new(cmt_ {
+        id: node.id(),
+        span: node.span(),
+        mutbl: base_cmt.mutbl.inherit(),
+        cat: cat_downcast(base_cmt, variant_did),
+        ty: downcast_ty
+    })
+}
+
 pub enum InteriorSafety {
     InteriorUnsafe,
     InteriorSafe
@@ -1351,8 +1358,8 @@ impl Repr for categorization {
             cat_interior(ref cmt, interior) => {
                 format!("{}.{}", cmt.cat.repr(tcx), interior.repr(tcx))
             }
-            cat_downcast(ref cmt, _) => {
-                format!("{}->(enum)", cmt.cat.repr(tcx))
+            cat_downcast(ref cmt, ref variant_did) => {
+                format!("({}->{})", cmt.cat.repr(tcx), variant_did.repr(tcx))
             }
             cat_discr(ref cmt, _) => {
                 cmt.cat.repr(tcx)

commit 5998f0249a599c0d65bfe977883c68a58805bcce
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Thu Jul 24 23:01:26 2014 +0200

    rust-needsdrop: more instrumentation of sibling fragments implied by enum variants.
---
 src/librustc/middle/borrowck/move_data.rs | 53 ++++++++++++++++++++++++++++++++++++++++++++---------
 1 file changed, 44 insertions(+), 9 deletions(-)

diff --git a/src/librustc/middle/borrowck/move_data.rs b/src/librustc/middle/borrowck/move_data.rs
index df678fe..7fd77eb 100644
--- a/src/librustc/middle/borrowck/move_data.rs
+++ b/src/librustc/middle/borrowck/move_data.rs
@@ -279,6 +279,14 @@ impl MoveData {
         self.path_first_child(index) == InvalidMovePathIndex
     }
 
+    /// Returns true iff `index` represents downcast to an enum variant (i.e. LpDowncast).
+    fn path_is_downcast_to_variant(&self, index: MovePathIndex) -> bool {
+        match *self.path_loan_path(index) {
+            LpDowncast(..) => true,
+            _ => false,
+        }
+    }
+
     /// Returns the index of first child, or `InvalidMovePathIndex` if
     /// `index` is leaf.
     fn path_first_child(&self, index: MovePathIndex) -> MovePathIndex {
@@ -910,13 +918,13 @@ impl MoveData {
     // The above comment should be revised/shortened to a succinct
     // summary.
 
-    fn needs_drop(&self, tcx: &ty::ctxt, move_path_index: MovePathIndex) -> bool {
+    fn type_needs_drop(&self, tcx: &ty::ctxt, move_path_index: MovePathIndex) -> bool {
         //! Returns true iff move_path_index needs drop.
         let path_type = self.path_loan_path(move_path_index).to_type(tcx);
         ty::type_needs_drop(tcx, path_type)
     }
 
-    fn moves_by_default(&self, tcx: &ty::ctxt, move_path_index: MovePathIndex) -> bool {
+    fn type_moves_by_default(&self, tcx: &ty::ctxt, move_path_index: MovePathIndex) -> bool {
         //! Returns true iff move_path_index needs moves by default.
         let path_type = self.path_loan_path(move_path_index).to_type(tcx);
         ty::type_contents(tcx, path_type).moves_by_default(tcx)
@@ -925,7 +933,8 @@ impl MoveData {
     fn for_each_leaf(&self,
                      _tcx: &ty::ctxt,
                      root: MovePathIndex,
-                     found_leaf: |MovePathIndex|) {
+                     found_leaf: |MovePathIndex|,
+                     found_variant: |MovePathIndex|) {
         //! Here we normalize a path so that it is unraveled to its
         //! consituent droppable pieces that might be independently
         //! handled by the function being compiled: e.g. `s.a.j`
@@ -941,6 +950,11 @@ impl MoveData {
             return;
         }
 
+        if self.path_is_downcast_to_variant(root) {
+            found_variant(root);
+            return;
+        }
+
         let mut stack = vec![];
         stack.push(root);
         loop {
@@ -950,6 +964,9 @@ impl MoveData {
             while child != InvalidMovePathIndex {
                 if self.path_is_leaf(child) {
                     found_leaf(child);
+                } else if self.path_is_downcast_to_variant(child) {
+                    found_variant(child);
+                    continue;
                 } else {
                     stack.push(child);
                 }
@@ -964,19 +981,32 @@ impl MoveData {
                             assignment: &Assignment,
                             dfcx_needs_drop: &mut NeedsDropDataFlow) {
         let add_gen = |move_path_index| {
-            if self.needs_drop(tcx, move_path_index) {
+            if self.path_is_downcast_to_variant(move_path_index) {
+                // A downcast to a variant occurs on a match arm.
+                // It does not in itself add a drop-obligation; those
+                // come from the variable bindings within the match arm.
+                return;
+            }
+
+            if self.type_needs_drop(tcx, move_path_index) {
                 debug!("add_drop_obligations(assignment={}) adds {}",
                        assignment.to_string(self, tcx),
                        self.path_loan_path(move_path_index).repr(tcx));
                 dfcx_needs_drop.add_gen(assignment.id, move_path_index.get());
             } else {
-                debug!("add_drop_obligations(assignment={}) skips {}",
+                debug!("add_drop_obligations(assignment={}) skips non-drop {}",
                        assignment.to_string(self, tcx),
                        self.path_loan_path(move_path_index).repr(tcx));
             }
         };
 
-        self.for_each_leaf(tcx, assignment.path, add_gen);
+        let report_variant = |move_path_index| {
+            debug!("add_drop_obligations(assignment={}) skips variant {}",
+                   assignment.to_string(self, tcx),
+                   self.path_loan_path(move_path_index).repr(tcx));
+        };
+
+        self.for_each_leaf(tcx, assignment.path, add_gen, report_variant);
     }
 
     fn remove_drop_obligations<A:RemoveNeedsDropArg>(&self,
@@ -990,17 +1020,22 @@ impl MoveData {
         let path : MovePathIndex = a.path_being_moved();
 
         let add_kill = |move_path_index| {
-            if self.moves_by_default(tcx, move_path_index) {
+            if self.type_moves_by_default(tcx, move_path_index) {
                 debug!("remove_drop_obligations(id={}) removes {}",
                        id, self.path_loan_path(move_path_index).repr(tcx));
                 dfcx_needs_drop.add_kill(id, move_path_index.get());
             } else {
-                debug!("remove_drop_obligations(id={}) skips {}",
+                debug!("remove_drop_obligations(id={}) skips copyable {}",
                        id, self.path_loan_path(move_path_index).repr(tcx));
             }
         };
 
-        self.for_each_leaf(tcx, path, add_kill);
+        let report_variant = |move_path_index| {
+            debug!("remove_drop_obligations(id={}) skips variant {}",
+                   id, self.path_loan_path(move_path_index).repr(tcx));
+        };
+
+        self.for_each_leaf(tcx, path, add_kill, report_variant);
     }
 }
 

commit a15395fcd6859a1f16992aceaa86ec1cce8f3959
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Thu Jul 24 18:00:36 2014 +0200

    rust-needsdrop: instrument breakdown between fragment and non-fragment loans.
    
    non-fragment loans are ones that were directly passed to `add_move` --
    i.e. we were already paying for them to have an entry in the move
    database and the dataflow bitsets.
    
    fragment loans are the ones that were added solely for my
    drop-obligation implementation of needs-drop analysis.
---
 src/librustc/middle/borrowck/move_data.rs | 33 +++++++++++++++++++++++++++++++++
 1 file changed, 33 insertions(+)

diff --git a/src/librustc/middle/borrowck/move_data.rs b/src/librustc/middle/borrowck/move_data.rs
index 82fb4fc..df678fe 100644
--- a/src/librustc/middle/borrowck/move_data.rs
+++ b/src/librustc/middle/borrowck/move_data.rs
@@ -674,6 +674,39 @@ impl MoveData {
          * See `doc.rs` for more details.
          */
 
+        {
+            let mut nonfragments = {
+                let mut nonfragments = self.nonfragments.borrow_mut();
+                nonfragments.sort_by(|a, b| a.get().cmp(&b.get()));
+                nonfragments.dedup();
+                nonfragments
+            };
+            let mut fragments = {
+                let mut maybe_fragments = self.fragments.borrow_mut();
+                maybe_fragments.sort_by(|a, b| a.get().cmp(&b.get()));
+                maybe_fragments.dedup();
+
+                // FIXME: why does rustc say that the below code means
+                // `nonfragments` must be declared mut?  Potential
+                // fallout from recent closure changes?
+                maybe_fragments.retain(|f| !nonfragments.contains(f));
+
+                maybe_fragments
+            };
+
+            // See FIXME above: being forced to declare `nonfragments` as mut
+            for (i, &nf) in nonfragments.iter().enumerate() {
+                let lp = self.path_loan_path(nf);
+                debug!("add_gen_kills nonfragment {:u}: {:s}", i, lp.repr(tcx));
+            }
+
+            // See FIXME above: being forced to declare `fragments` as mut
+            for (i, &f) in fragments.iter().enumerate() {
+                let lp = self.path_loan_path(f);
+                debug!("add_gen_kills fragment {:u}: {:s}", i, lp.repr(tcx));
+            }
+        }
+
         for (i, move) in self.moves.borrow().iter().enumerate() {
             dfcx_moves.add_gen(move.id, i);
             debug!("remove_drop_obligations move {}", move.to_string(self, tcx));

commit 483f7b4d004830427cb0181da7048dcd051e8a9c
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Thu Jul 24 17:58:53 2014 +0200

    rust-needsdrop: Include LpDowncast variant info in string representation.
---
 src/librustc/middle/borrowck/mod.rs | 25 ++++++++++++++++++-------
 1 file changed, 18 insertions(+), 7 deletions(-)

diff --git a/src/librustc/middle/borrowck/mod.rs b/src/librustc/middle/borrowck/mod.rs
index ddcb1d5..5319c08 100644
--- a/src/librustc/middle/borrowck/mod.rs
+++ b/src/librustc/middle/borrowck/mod.rs
@@ -876,9 +876,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {
                 out.push_str(ty::local_var_name_str(self.tcx, id).get());
             }
 
-            LpDowncast(ref lp_base, _) => {
-                // FIXME: perhaps extend notation with variant tag notation?
-                self.append_loan_path_to_string(&**lp_base, out)
+            LpDowncast(ref lp_base, variant_def_id) => {
+                out.push_char('(');
+                self.append_loan_path_to_string(&**lp_base, out);
+                out.push_char(':');
+                out.push_str(ty::item_path_str(self.tcx, variant_def_id).as_slice());
+                out.push_char(')');
             }
 
             LpExtend(ref lp_base, _, LpInterior(mc::InteriorField(fname))) => {
@@ -911,9 +914,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {
                                               loan_path: &LoanPath,
                                               out: &mut String) {
         match *loan_path {
-            // FIXME: perhaps extend notation with variant tag notation?
-            LpDowncast(ref lp_base, _) => {
-                self.append_autoderefd_loan_path_to_string(&**lp_base, out)
+            LpDowncast(ref lp_base, variant_def_id) => {
+                out.push_char('(');
+                self.append_autoderefd_loan_path_to_string(&**lp_base, out);
+                out.push_char(':');
+                out.push_str(ty::item_path_str(self.tcx, variant_def_id).as_slice());
+                out.push_char(')');
             }
 
             LpExtend(ref lp_base, _, LpDeref(_)) => {
@@ -999,7 +1005,12 @@ impl Repr for LoanPath {
             }
 
             &LpDowncast(ref lp, variant_def_id) => {
-                format!("({} as {})", lp.repr(tcx), variant_def_id.repr(tcx))
+                let variant_str = if variant_def_id.krate == ast::LOCAL_CRATE {
+                    ty::item_path_str(tcx, variant_def_id)
+                } else {
+                    variant_def_id.repr(tcx)
+                };
+                format!("({} as {})", lp.repr(tcx), variant_str)
             }
         }
     }

commit c11a670945b6c7e1b0e0299dfbc421d8a23be1b0
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Thu Jul 24 07:37:48 2014 +0200

    Put a needs-drop filter back in.
    
    Also, for this go-round, use different filter, `moves_by_default`, for
    the kill sets (aka "remove_drop_obligations").
---
 src/librustc/middle/borrowck/move_data.rs | 38 ++++++++++++++++++++++++++++++--------
 1 file changed, 30 insertions(+), 8 deletions(-)

diff --git a/src/librustc/middle/borrowck/move_data.rs b/src/librustc/middle/borrowck/move_data.rs
index 939b0e2..82fb4fc 100644
--- a/src/librustc/middle/borrowck/move_data.rs
+++ b/src/librustc/middle/borrowck/move_data.rs
@@ -877,6 +877,18 @@ impl MoveData {
     // The above comment should be revised/shortened to a succinct
     // summary.
 
+    fn needs_drop(&self, tcx: &ty::ctxt, move_path_index: MovePathIndex) -> bool {
+        //! Returns true iff move_path_index needs drop.
+        let path_type = self.path_loan_path(move_path_index).to_type(tcx);
+        ty::type_needs_drop(tcx, path_type)
+    }
+
+    fn moves_by_default(&self, tcx: &ty::ctxt, move_path_index: MovePathIndex) -> bool {
+        //! Returns true iff move_path_index needs moves by default.
+        let path_type = self.path_loan_path(move_path_index).to_type(tcx);
+        ty::type_contents(tcx, path_type).moves_by_default(tcx)
+    }
+
     fn for_each_leaf(&self,
                      _tcx: &ty::ctxt,
                      root: MovePathIndex,
@@ -919,10 +931,16 @@ impl MoveData {
                             assignment: &Assignment,
                             dfcx_needs_drop: &mut NeedsDropDataFlow) {
         let add_gen = |move_path_index| {
-            debug!("add_drop_obligations(assignment={}) adds {}",
-                   assignment.to_string(self, tcx),
-                   self.path_loan_path(move_path_index).repr(tcx));
-            dfcx_needs_drop.add_gen(assignment.id, move_path_index.get());
+            if self.needs_drop(tcx, move_path_index) {
+                debug!("add_drop_obligations(assignment={}) adds {}",
+                       assignment.to_string(self, tcx),
+                       self.path_loan_path(move_path_index).repr(tcx));
+                dfcx_needs_drop.add_gen(assignment.id, move_path_index.get());
+            } else {
+                debug!("add_drop_obligations(assignment={}) skips {}",
+                       assignment.to_string(self, tcx),
+                       self.path_loan_path(move_path_index).repr(tcx));
+            }
         };
 
         self.for_each_leaf(tcx, assignment.path, add_gen);
@@ -939,10 +957,14 @@ impl MoveData {
         let path : MovePathIndex = a.path_being_moved();
 
         let add_kill = |move_path_index| {
-            debug!("remove_drop_obligations(id={}) removes {}",
-                   id, self.path_loan_path(move_path_index).repr(tcx));
-
-            dfcx_needs_drop.add_kill(id, move_path_index.get());
+            if self.moves_by_default(tcx, move_path_index) {
+                debug!("remove_drop_obligations(id={}) removes {}",
+                       id, self.path_loan_path(move_path_index).repr(tcx));
+                dfcx_needs_drop.add_kill(id, move_path_index.get());
+            } else {
+                debug!("remove_drop_obligations(id={}) skips {}",
+                       id, self.path_loan_path(move_path_index).repr(tcx));
+            }
         };
 
         self.for_each_leaf(tcx, path, add_kill);

commit de4bf5f4e8fc3b80ece0b1b48a304e811ee140e5
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Thu Jul 24 07:35:59 2014 +0200

    code cleanup, placate some lints.
---
 src/librustc/middle/borrowck/move_data.rs | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/src/librustc/middle/borrowck/move_data.rs b/src/librustc/middle/borrowck/move_data.rs
index 0573a49..939b0e2 100644
--- a/src/librustc/middle/borrowck/move_data.rs
+++ b/src/librustc/middle/borrowck/move_data.rs
@@ -603,13 +603,13 @@ impl MoveData {
                 }
             }
 
-            (&ty::ty_enum(def_id, ref substs), Some((variant_def_id, ref _lp2))) => {
+            (&ty::ty_enum(def_id, ref _substs), Some((variant_def_id, ref _lp2))) => {
                 let variant_info = ty::enum_variant_with_id(tcx, def_id, variant_def_id);
                 match *origin_field_name {
                     mc::NamedField(ast_name) => {
                         let variant_arg_names = variant_info.arg_names.as_ref().unwrap();
                         let variant_arg_types = &variant_info.args;
-                        for (variant_arg_ident, variant_arg_ty) in variant_arg_names.iter().zip(variant_arg_types.iter()) {
+                        for (variant_arg_ident, _variant_arg_ty) in variant_arg_names.iter().zip(variant_arg_types.iter()) {
                             if variant_arg_ident.name == ast_name {
                                 continue;
                             }
@@ -619,8 +619,8 @@ impl MoveData {
                         }
                     }
                     mc::PositionalField(tuple_idx) => {
-                        let mut variant_arg_types = variant_info.args.iter();
-                        for (i, variant_arg_ty) in variant_arg_types.enumerate() {
+                        let variant_arg_types = &variant_info.args;
+                        for (i, _variant_arg_ty) in variant_arg_types.iter().enumerate() {
                             if tuple_idx == i {
                                 continue;
                             }

commit 543fb1e7ff6086cfc8c76b4c616369ca8c2337a9
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Thu Jul 24 00:57:53 2014 +0200

    WIP checkpoint: code to calculate fragment siblings of enum variant.
    
    Along the way, I attempted to move the check Drop impl stuff into
    different places, and eventually removed my `fn needs_drop` predicate
    entirely, though I am now not sure why I exactly did that in such a
    manner.  Anyway I almost certainly will want it back in some form.
    But this is all WIP so that's fine.
---
 src/librustc/middle/borrowck/check_loans.rs               |  22 ++++++++----
 src/librustc/middle/borrowck/gather_loans/gather_moves.rs |   4 +--
 src/librustc/middle/borrowck/gather_loans/lifetime.rs     |   4 +--
 src/librustc/middle/borrowck/gather_loans/mod.rs          |   5 ++-
 src/librustc/middle/borrowck/gather_loans/move_error.rs   |   2 +-
 src/librustc/middle/borrowck/gather_loans/restrictions.rs |   2 +-
 src/librustc/middle/borrowck/mod.rs                       |  94 ++++++++++++++++++++++++++++++++++++++------------
 src/librustc/middle/borrowck/move_data.rs                 | 182 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++--------------------------------
 src/librustc/middle/mem_categorization.rs                 |  19 ++++++-----
 src/librustc/middle/ty.rs                                 |  49 ++++++++++++++++++--------
 src/librustc/middle/typeck/check/regionck.rs              |   6 ++--
 11 files changed, 269 insertions(+), 120 deletions(-)

diff --git a/src/librustc/middle/borrowck/check_loans.rs b/src/librustc/middle/borrowck/check_loans.rs
index df637e7..dfeb382 100644
--- a/src/librustc/middle/borrowck/check_loans.rs
+++ b/src/librustc/middle/borrowck/check_loans.rs
@@ -123,7 +123,7 @@ impl<'a, 'tcx> euv::Delegate for CheckLoanCtxt<'a, 'tcx> {
                borrow_id, cmt.repr(self.tcx()), loan_region,
                bk, loan_cause);
 
-        match opt_loan_path(&cmt) {
+        match opt_loan_path(&cmt, self.tcx()) {
             Some(lp) => {
                 let moved_value_use_kind = match loan_cause {
                     euv::ClosureCapture(_) => MovedInCapture,
@@ -146,7 +146,7 @@ impl<'a, 'tcx> euv::Delegate for CheckLoanCtxt<'a, 'tcx> {
         debug!("mutate(assignment_id={}, assignee_cmt={})",
                assignment_id, assignee_cmt.repr(self.tcx()));
 
-        match opt_loan_path(&assignee_cmt) {
+        match opt_loan_path(&assignee_cmt, self.tcx()) {
             Some(lp) => {
                 match mode {
                     euv::Init | euv::JustWrite => {
@@ -297,6 +297,10 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {
                 LpVar(_) | LpUpvar(_) => {
                     break;
                 }
+                LpDowncast(ref lp_base, _) => {
+                    loan_path = &**lp_base;
+                    continue;
+                }
                 LpExtend(ref lp_base, _, _) => {
                     loan_path = &**lp_base;
                 }
@@ -526,7 +530,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {
                       span: Span,
                       cmt: mc::cmt,
                       mode: euv::ConsumeMode) {
-        match opt_loan_path(&cmt) {
+        match opt_loan_path(&cmt, self.tcx()) {
             Some(lp) => {
                 let moved_value_use_kind = match mode {
                     euv::Copy => {
@@ -690,6 +694,10 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {
             LpVar(_) | LpUpvar(_) => {
                 // assigning to `x` does not require that `x` is initialized
             }
+            LpDowncast(ref lp_base, _) => {
+                self.check_if_assigned_path_is_moved(id, span,
+                                                     use_kind, lp_base);
+            }
             LpExtend(ref lp_base, _, LpInterior(_)) => {
                 // assigning to `P.f` is ok if assigning to `P` is ok
                 self.check_if_assigned_path_is_moved(id, span,
@@ -732,7 +740,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {
         // if they cannot already have been assigned
         if self.is_local_variable_or_arg(assignee_cmt.clone()) {
             assert!(assignee_cmt.mutbl.is_immutable()); // no "const" locals
-            let lp = opt_loan_path(&assignee_cmt).unwrap();
+            let lp = opt_loan_path(&assignee_cmt, self.tcx()).unwrap();
             self.move_data.each_assignment_of(assignment_id, &lp, |assign| {
                 self.bccx.report_reassigned_immutable_variable(
                     assignment_span,
@@ -744,7 +752,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {
         }
 
         // Otherwise, just a plain error.
-        match opt_loan_path(&assignee_cmt) {
+        match opt_loan_path(&assignee_cmt, self.tcx()) {
             Some(lp) => {
                 self.bccx.span_err(
                     assignment_span,
@@ -804,7 +812,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {
                         cmt = b;
                     }
 
-                    mc::cat_downcast(b) |
+                    mc::cat_downcast(b, _) |
                     mc::cat_interior(b, _) => {
                         assert_eq!(cmt.mutbl, mc::McInherited);
                         cmt = b;
@@ -864,7 +872,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {
             //! Check for assignments that violate the terms of an
             //! outstanding loan.
 
-            let loan_path = match opt_loan_path(&assignee_cmt) {
+            let loan_path = match opt_loan_path(&assignee_cmt, this.tcx()) {
                 Some(lp) => lp,
                 None => { return; /* no loan path, can't be any loans */ }
             };
diff --git a/src/librustc/middle/borrowck/gather_loans/gather_moves.rs b/src/librustc/middle/borrowck/gather_loans/gather_moves.rs
index f58cc95..e0ca21a 100644
--- a/src/librustc/middle/borrowck/gather_loans/gather_moves.rs
+++ b/src/librustc/middle/borrowck/gather_loans/gather_moves.rs
@@ -101,7 +101,7 @@ fn gather_move(bccx: &BorrowckCtxt,
         None => ()
     }
 
-    match opt_loan_path(&move_info.cmt) {
+    match opt_loan_path(&move_info.cmt, bccx.tcx) {
         Some(loan_path) => {
             move_data.add_move(bccx.tcx, loan_path,
                                move_info.id, move_info.kind);
@@ -152,7 +152,7 @@ fn check_and_get_illegal_move_origin(bccx: &BorrowckCtxt,
             None
         }
 
-        mc::cat_downcast(ref b) |
+        mc::cat_downcast(ref b, _) |
         mc::cat_interior(ref b, _) => {
             match ty::get(b.ty).sty {
                 ty::ty_struct(did, _) | ty::ty_enum(did, _) => {
diff --git a/src/librustc/middle/borrowck/gather_loans/lifetime.rs b/src/librustc/middle/borrowck/gather_loans/lifetime.rs
index e13717e..103a099 100644
--- a/src/librustc/middle/borrowck/gather_loans/lifetime.rs
+++ b/src/librustc/middle/borrowck/gather_loans/lifetime.rs
@@ -81,7 +81,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {
                 Ok(())
             }
 
-            mc::cat_downcast(ref base) |
+            mc::cat_downcast(ref base, _) |
             mc::cat_deref(ref base, _, mc::OwnedPtr) |     // L-Deref-Send
             mc::cat_interior(ref base, _) |                // L-Field
             mc::cat_deref(ref base, _, mc::GcPtr) => {
@@ -185,7 +185,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {
             mc::cat_deref(_, _, mc::Implicit(_, r)) => {
                 r
             }
-            mc::cat_downcast(ref cmt) |
+            mc::cat_downcast(ref cmt, _) |
             mc::cat_deref(ref cmt, _, mc::OwnedPtr) |
             mc::cat_deref(ref cmt, _, mc::GcPtr) |
             mc::cat_interior(ref cmt, _) |
diff --git a/src/librustc/middle/borrowck/gather_loans/mod.rs b/src/librustc/middle/borrowck/gather_loans/mod.rs
index 1118939..42f758e 100644
--- a/src/librustc/middle/borrowck/gather_loans/mod.rs
+++ b/src/librustc/middle/borrowck/gather_loans/mod.rs
@@ -133,7 +133,7 @@ impl<'a, 'tcx> euv::Delegate for GatherLoanCtxt<'a, 'tcx> {
         debug!("mutate(assignment_id={}, assignee_cmt={})",
                assignment_id, assignee_cmt.repr(self.tcx()));
 
-        match opt_loan_path(&assignee_cmt) {
+        match opt_loan_path(&assignee_cmt, self.tcx()) {
             Some(lp) => {
                 gather_moves::gather_assignment(self.bccx, &self.move_data,
                                                 assignment_id, assignment_span,
@@ -401,6 +401,9 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {
             LpUpvar(ty::UpvarId{ var_id: local_id, closure_expr_id: _ }) => {
                 self.tcx().used_mut_nodes.borrow_mut().insert(local_id);
             }
+            LpDowncast(ref base, _) => {
+                self.mark_loan_path_as_mutated(&**base);
+            }
             LpExtend(ref base, mc::McInherited, _) => {
                 self.mark_loan_path_as_mutated(&**base);
             }
diff --git a/src/librustc/middle/borrowck/gather_loans/move_error.rs b/src/librustc/middle/borrowck/gather_loans/move_error.rs
index 4f9e51a..c4b9b33 100644
--- a/src/librustc/middle/borrowck/gather_loans/move_error.rs
+++ b/src/librustc/middle/borrowck/gather_loans/move_error.rs
@@ -124,7 +124,7 @@ fn report_cannot_move_out_of(bccx: &BorrowckCtxt, move_from: mc::cmt) {
                         bccx.cmt_to_string(&*move_from)).as_slice());
         }
 
-        mc::cat_downcast(ref b) |
+        mc::cat_downcast(ref b, _) |
         mc::cat_interior(ref b, _) => {
             match ty::get(b.ty).sty {
                 ty::ty_struct(did, _)
diff --git a/src/librustc/middle/borrowck/gather_loans/restrictions.rs b/src/librustc/middle/borrowck/gather_loans/restrictions.rs
index 90e17e4..b2ad930 100644
--- a/src/librustc/middle/borrowck/gather_loans/restrictions.rs
+++ b/src/librustc/middle/borrowck/gather_loans/restrictions.rs
@@ -85,7 +85,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {
                 SafeIf(lp.clone(), vec![lp])
             }
 
-            mc::cat_downcast(cmt_base) => {
+            mc::cat_downcast(cmt_base, _) => {
                 // When we borrow the interior of an enum, we have to
                 // ensure the enum itself is not mutated, because that
                 // could cause the type of the memory to change.
diff --git a/src/librustc/middle/borrowck/mod.rs b/src/librustc/middle/borrowck/mod.rs
index f07cd6f..ddcb1d5 100644
--- a/src/librustc/middle/borrowck/mod.rs
+++ b/src/librustc/middle/borrowck/mod.rs
@@ -279,9 +279,10 @@ impl Loan {
 
 #[deriving(PartialEq, Eq, Hash)]
 pub enum LoanPath {
-    LpVar(ast::NodeId),               // `x` in doc.rs
-    LpUpvar(ty::UpvarId),             // `x` captured by-value into closure
-    LpExtend(Rc<LoanPath>, mc::MutabilityCategory, LoanPathElem)
+    LpVar(ast::NodeId),                   // `x` in doc.rs
+    LpUpvar(ty::UpvarId),                 // `x` captured by-value into closure
+    LpDowncast(Rc<LoanPath>, ast::DefId), // `x` downcast to particular enum variant
+    LpExtend(Rc<LoanPath>, mc::MutabilityCategory, LoanPathElem),
 }
 
 impl LoanPath {
@@ -294,9 +295,22 @@ impl LoanPath {
             LpUpvar(ty::UpvarId { var_id: id, closure_expr_id: _ }) |
             LpVar(id) => ty::node_id_to_type_opt(tcx, id),
 
+            // treat the downcasted enum as having the enum's type;
+            // extracting the particular types within the variant is
+            // handled by `LpExtend` cases.
+            LpDowncast(ref lp, _variant_did) => Some(lp.to_type(tcx)),
+
             LpExtend(ref lp, _mc, ref loan_path_elem) => {
+                let (opt_variant_did, lp) = match **lp {
+                    LpDowncast(ref sub_lp, variant_did) =>
+                        (Some(variant_did), sub_lp),
+                    LpVar(..) | LpUpvar(..) | LpExtend(..) =>
+                        (None, lp)
+                };
+
                 let t = lp.to_type(tcx);
                 let t_sty = &ty::get(t).sty;
+
                 match (loan_path_elem, t_sty) {
                     (&LpDeref(_), &ty::ty_ptr(ty::mt{ty: t, ..})) |
                     (&LpDeref(_), &ty::ty_rptr(_, ty::mt{ty: t, ..})) |
@@ -304,10 +318,10 @@ impl LoanPath {
                     (&LpDeref(_), &ty::ty_uniq(t)) => Some(t),
 
                     (&LpInterior(Field(mc::NamedField(ast_name))),
-                     _) => ty::named_element_ty(tcx, t, ast_name),
+                     _) => ty::named_element_ty(tcx, t, ast_name, opt_variant_did),
 
                     (&LpInterior(Field(mc::PositionalField(idx))),
-                     _) => ty::positional_element_ty(tcx, t, idx),
+                     _) => ty::positional_element_ty(tcx, t, idx, opt_variant_did),
 
                     // (Deliberately not using ty::array_element_ty
                     // here, because that assumes r-value context and
@@ -323,7 +337,6 @@ impl LoanPath {
                 }
             }
         };
-
         let t = opt_ty.unwrap_or_else(|| {
             let id = self.kill_scope(tcx);
             let msg = format!("no type found for lp={:s}", self.repr(tcx));
@@ -343,6 +356,13 @@ impl LoanPath {
 pub enum LoanPathElem {
     LpDeref(mc::PointerKind),    // `*LV` in doc.rs
     LpInterior(mc::InteriorKind) // `LV.f` in doc.rs
+    // LpInterior(mc::InteriorKind, Box<InteriorInfo>) // `LV.f` in doc.rs
+}
+
+pub enum InteriorInfo {
+    StructInterior(ty::t),
+    TupleIndexInterior(Vec<ty::t>),
+    EnumVariantInterior(ty::VariantInfo),
 }
 
 pub fn closure_to_block(closure_id: ast::NodeId,
@@ -364,19 +384,22 @@ impl LoanPath {
             LpVar(local_id) => tcx.region_maps.var_scope(local_id),
             LpUpvar(upvar_id) =>
                 closure_to_block(upvar_id.closure_expr_id, tcx),
+            LpDowncast(ref base, _) |
             LpExtend(ref base, _, _) => base.kill_scope(tcx),
         }
     }
 }
 
-pub fn opt_loan_path(cmt: &mc::cmt) -> Option<Rc<LoanPath>> {
+pub fn opt_loan_path(cmt: &mc::cmt, tcx: &ty::ctxt) -> Option<Rc<LoanPath>> {
     //! Computes the `LoanPath` (if any) for a `cmt`.
     //! Note that this logic is somewhat duplicated in
     //! the method `compute()` found in `gather_loans::restrictions`,
     //! which allows it to share common loan path pieces as it
     //! traverses the CMT.
 
-    match cmt.cat {
+    debug!("opt_loan_path(cmt={})", cmt.repr(tcx));
+
+    let ret = match cmt.cat {
         mc::cat_rvalue(..) |
         mc::cat_static_item |
         mc::cat_copied_upvar(mc::CopiedUpvar { onceness: ast::Many, .. }) => {
@@ -397,22 +420,37 @@ pub fn opt_loan_path(cmt: &mc::cmt) -> Option<Rc<LoanPath>> {
         }
 
         mc::cat_deref(ref cmt_base, _, pk) => {
-            opt_loan_path(cmt_base).map(|lp| {
-                Rc::new(LpExtend(lp, cmt.mutbl, LpDeref(pk)))
+            opt_loan_path(cmt_base, tcx).map(|lp| {
+                let lp : LoanPath =
+                    LpExtend(lp, cmt.mutbl, LpDeref(pk)); 
+                Rc::new(lp)
             })
         }
 
         mc::cat_interior(ref cmt_base, ik) => {
-            opt_loan_path(cmt_base).map(|lp| {
-                Rc::new(LpExtend(lp, cmt.mutbl, LpInterior(ik)))
+            opt_loan_path(cmt_base, tcx).map(|lp| {
+                let lp : LoanPath =
+                    LpExtend(lp, cmt.mutbl, LpInterior(ik));
+                Rc::new(lp)
             })
         }
 
-        mc::cat_downcast(ref cmt_base) |
-        mc::cat_discr(ref cmt_base, _) => {
-            opt_loan_path(cmt_base)
-        }
-    }
+        mc::cat_downcast(ref cmt_base, variant_def_id) =>
+            opt_loan_path(cmt_base, tcx)
+            .map(|lp| {
+                debug!("opt_loan_path cat_downcast \
+                        cmt.ty={} ({:?}) \
+                        cmt_base.ty={} ({:?})",
+                       cmt.ty.repr(tcx), cmt.ty,
+                       cmt_base.ty.repr(tcx), cmt_base.ty);
+                Rc::new(LpDowncast(lp, variant_def_id))
+            }),
+        mc::cat_discr(ref cmt_base, _) => opt_loan_path(cmt_base, tcx),
+    };
+
+    debug!("opt_loan_path(cmt={}) => {}", cmt.repr(tcx), ret.repr(tcx));
+
+    ret
 }
 
 ///////////////////////////////////////////////////////////////////////////
@@ -669,7 +707,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {
     pub fn bckerr_to_string(&self, err: &BckError) -> String {
         match err.code {
             err_mutbl => {
-                let descr = match opt_loan_path(&err.cmt) {
+                let descr = match opt_loan_path(&err.cmt, self.tcx) {
                     None => {
                         format!("{} {}",
                                 err.cmt.mutbl.to_user_str(),
@@ -701,7 +739,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {
                 }
             }
             err_out_of_scope(..) => {
-                let msg = match opt_loan_path(&err.cmt) {
+                let msg = match opt_loan_path(&err.cmt, self.tcx) {
                     None => "borrowed value".to_string(),
                     Some(lp) => {
                         format!("`{}`", self.loan_path_to_string(&*lp))
@@ -710,7 +748,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {
                 format!("{} does not live long enough", msg)
             }
             err_borrowed_pointer_too_short(..) => {
-                let descr = match opt_loan_path(&err.cmt) {
+                let descr = match opt_loan_path(&err.cmt, self.tcx) {
                     Some(lp) => {
                         format!("`{}`", self.loan_path_to_string(&*lp))
                     }
@@ -808,7 +846,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {
             }
 
             err_borrowed_pointer_too_short(loan_scope, ptr_scope) => {
-                let descr = match opt_loan_path(&err.cmt) {
+                let descr = match opt_loan_path(&err.cmt, self.tcx) {
                     Some(lp) => {
                         format!("`{}`", self.loan_path_to_string(&*lp))
                     }
@@ -838,6 +876,11 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {
                 out.push_str(ty::local_var_name_str(self.tcx, id).get());
             }
 
+            LpDowncast(ref lp_base, _) => {
+                // FIXME: perhaps extend notation with variant tag notation?
+                self.append_loan_path_to_string(&**lp_base, out)
+            }
+
             LpExtend(ref lp_base, _, LpInterior(mc::InteriorField(fname))) => {
                 self.append_autoderefd_loan_path_to_string(&**lp_base, out);
                 match fname {
@@ -868,6 +911,11 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {
                                               loan_path: &LoanPath,
                                               out: &mut String) {
         match *loan_path {
+            // FIXME: perhaps extend notation with variant tag notation?
+            LpDowncast(ref lp_base, _) => {
+                self.append_autoderefd_loan_path_to_string(&**lp_base, out)
+            }
+
             LpExtend(ref lp_base, _, LpDeref(_)) => {
                 // For a path like `(*x).f` or `(*x)[3]`, autoderef
                 // rules would normally allow users to omit the `*x`.
@@ -949,6 +997,10 @@ impl Repr for LoanPath {
             &LpExtend(ref lp, _, LpInterior(ref interior)) => {
                 format!("{}.{}", lp.repr(tcx), interior.repr(tcx))
             }
+
+            &LpDowncast(ref lp, variant_def_id) => {
+                format!("({} as {})", lp.repr(tcx), variant_def_id.repr(tcx))
+            }
         }
     }
 }
diff --git a/src/librustc/middle/borrowck/move_data.rs b/src/librustc/middle/borrowck/move_data.rs
index 9314aae..0573a49 100644
--- a/src/librustc/middle/borrowck/move_data.rs
+++ b/src/librustc/middle/borrowck/move_data.rs
@@ -192,6 +192,9 @@ fn loan_path_is_precise(loan_path: &LoanPath) -> bool {
         LpExtend(ref lp_base, _, _) => {
             loan_path_is_precise(&**lp_base)
         }
+        LpDowncast(ref lp_base, _) => {
+            loan_path_is_precise(&**lp_base)
+        }
     }
 }
 
@@ -328,6 +331,10 @@ impl MoveData {
         }
 
         let index = match *lp {
+            LpDowncast(ref base, _) => {
+                return self.move_path(tcx, base.clone());
+            }
+
             LpVar(..) | LpUpvar(..) => {
                 let index = MovePathIndex(self.paths.borrow().len());
 
@@ -400,6 +407,9 @@ impl MoveData {
             None => {
                 match **lp {
                     LpVar(..) | LpUpvar(..) => { }
+                    LpDowncast(ref b, _) => {
+                        self.add_existing_base_paths(b, result);
+                    }
                     LpExtend(ref b, _, _) => {
                         self.add_existing_base_paths(b, result);
                     }
@@ -439,7 +449,7 @@ impl MoveData {
             next_move: next_move
         });
 
-        self.add_fragment_siblings(tcx, lp);
+        self.add_fragment_siblings(tcx, lp, id);
     }
 
     pub fn add_assignment(&self,
@@ -460,7 +470,7 @@ impl MoveData {
         let path_index = self.move_path(tcx, lp.clone());
 
         self.nonfragments.borrow_mut().push(path_index);
-        
+
         match mode {
             euv::Init | euv::JustWrite => {
                 self.assignee_ids.borrow_mut().insert(assignee_id);
@@ -489,17 +499,21 @@ impl MoveData {
 
     fn add_fragment_siblings(&self,
                              tcx: &ty::ctxt,
-                             lp: Rc<LoanPath>) {
+                             lp: Rc<LoanPath>,
+                             origin_id: ast::NodeId) {
         /*! Adds all of the precisely-tracked siblings of `lp` as
          * potential move paths of interest. For example, if `lp`
          * represents `s.x.j`, then adds moves paths for `s.x.i` and
          * `s.x.k`, the siblings of `s.x.j`.
          */
-        debug!("add_fragment_siblings(lp={})", lp.repr(tcx));
+        debug!("add_fragment_siblings(lp={}, origin_id={})",
+               lp.repr(tcx), origin_id);
 
         match *lp {
             LpVar(_) | LpUpvar(_) => {} // Local variables have no siblings.
 
+            LpDowncast(..) => {} // an enum variant (on its own) has no siblings.
+
             // *LV for OwnedPtr itself has no siblings, but we might need
             // to propagate inward.  Not sure.
             LpExtend(_, _, LpDeref(mc::OwnedPtr)) => unimplemented!(),
@@ -512,53 +526,114 @@ impl MoveData {
 
             // field access LV.x and tuple access LV#k are the cases
             // we are interested in
-            LpExtend(ref parent, mc,
-                     LpInterior(mc::InteriorField(ref field_name))) =>
+            LpExtend(ref loan_parent, mc,
+                     LpInterior(mc::InteriorField(ref field_name))) => {
+                let enum_variant_info = match **loan_parent {
+                    LpDowncast(ref loan_parent_2, variant_def_id) =>
+                        Some((variant_def_id, loan_parent_2.clone())),
+                    LpExtend(..) | LpVar(..) | LpUpvar(..) =>
+                        None,
+                };
                 self.add_fragment_siblings_for_extension(
-                    tcx, parent, mc, field_name, &lp),
+                    tcx, loan_parent, mc, field_name, &lp, origin_id, enum_variant_info);
+            }
         }
     }
 
     fn add_fragment_siblings_for_extension(&self,
                                            tcx: &ty::ctxt,
-                                           parent: &Rc<LoanPath>,
+                                           parent_lp: &Rc<LoanPath>,
                                            mc: mc::MutabilityCategory,
                                            origin_field_name: &mc::FieldName,
-                                           origin_lp: &Rc<LoanPath>) {
+                                           origin_lp: &Rc<LoanPath>,
+                                           _origin_id: ast::NodeId,
+                                           enum_variant_info: Option<(ast::DefId, Rc<LoanPath>)>) {
         /*! We have determined that `origin_lp` destructures to
          * LpExtend(parent, original_field_name). Based on this,
          * add move paths for all of the siblings of `origin_lp`.
          */
-        let parent_ty = parent.to_type(tcx);
-
-        match *origin_field_name {
-            mc::NamedField(ast_name) => {
-                let parent_def_id = match ty::get(parent_ty).sty {
-                    ty::ty_struct(def_id, ref _substs) |
-                    ty::ty_enum(def_id, ref _substs) => def_id,
-                    _ => fail!("type shouldn't have named fields"),
-                };
-                let fields = ty::lookup_struct_fields(tcx, parent_def_id);
-                for f in fields.iter().filter(|field| field.name != ast_name) {
-                    self.add_fragment_sibling(
-                        tcx, parent.clone(), mc, mc::NamedField(f.name), origin_lp);
-                }
-            }
-            mc::PositionalField(tuple_idx) => {
-                let tuple_len = match ty::get(parent_ty).sty {
-                    ty::ty_tup(ref v) => v.len(),
-                    ty::ty_struct(def_id, ref _substs) =>
-                        ty::lookup_struct_fields(tcx, def_id).len(),
-                    ty::ty_enum(def_id, ref _substs) =>
-                        ty::lookup_struct_fields(tcx, def_id).len(),
-                    _ => fail!("type shouldn't have positional fields"),
+        let parent_ty = parent_lp.to_type(tcx);
+
+        let add_fragment_sibling = |field_name, _field_type| {
+            self.add_fragment_sibling(
+                tcx, parent_lp.clone(), mc, field_name, origin_lp);
+        };
+
+        match (&ty::get(parent_ty).sty, enum_variant_info) {
+            (&ty::ty_tup(ref v), None) => {
+                let tuple_idx = match *origin_field_name {
+                    mc::PositionalField(tuple_idx) => tuple_idx,
+                    mc::NamedField(_) =>
+                        fail!("tuple type should not have named fields."),
                 };
+                let tuple_len = v.len();
                 for i in range(0, tuple_len) {
                     if i == tuple_idx { continue }
-                    self.add_fragment_sibling(
-                        tcx, parent.clone(), mc, mc::PositionalField(i), origin_lp);
+                    let field_type =
+                        // v[i];
+                        ();
+                    let field_name = mc::PositionalField(i);
+                    add_fragment_sibling(field_name, field_type);
+                }
+            }
+
+            (&ty::ty_struct(def_id, ref _substs), None) => {
+                let fields = ty::lookup_struct_fields(tcx, def_id);
+                match *origin_field_name {
+                    mc::NamedField(ast_name) => {
+                        for f in fields.iter() {
+                            if f.name == ast_name {
+                                continue;
+                            }
+                            let field_name = mc::NamedField(f.name);
+                            let field_type = ();
+                            add_fragment_sibling(field_name, field_type);
+                        }
+                    }
+                    mc::PositionalField(tuple_idx) => {
+                        for (i, _f) in fields.iter().enumerate() {
+                            if i == tuple_idx {
+                                continue
+                            }
+                            let field_name = mc::PositionalField(i);
+                            let field_type = ();
+                            add_fragment_sibling(field_name, field_type);
+                        }
+                    }
                 }
             }
+
+            (&ty::ty_enum(def_id, ref substs), Some((variant_def_id, ref _lp2))) => {
+                let variant_info = ty::enum_variant_with_id(tcx, def_id, variant_def_id);
+                match *origin_field_name {
+                    mc::NamedField(ast_name) => {
+                        let variant_arg_names = variant_info.arg_names.as_ref().unwrap();
+                        let variant_arg_types = &variant_info.args;
+                        for (variant_arg_ident, variant_arg_ty) in variant_arg_names.iter().zip(variant_arg_types.iter()) {
+                            if variant_arg_ident.name == ast_name {
+                                continue;
+                            }
+                            let field_name = mc::NamedField(variant_arg_ident.name);
+                            let field_type = ();
+                            add_fragment_sibling(field_name, field_type);
+                        }
+                    }
+                    mc::PositionalField(tuple_idx) => {
+                        let mut variant_arg_types = variant_info.args.iter();
+                        for (i, variant_arg_ty) in variant_arg_types.enumerate() {
+                            if tuple_idx == i {
+                                continue;
+                            }
+                            let field_name = mc::PositionalField(i);
+                            let field_type = ();
+                            add_fragment_sibling(field_name, field_type);
+                        }
+                    }
+                }
+            }
+
+            ref sty => fail!("type {} ({:?}) shouldn't have named fields",
+                             parent_ty.repr(tcx), sty),
         }
     }
 
@@ -572,7 +647,7 @@ impl MoveData {
          * of `origin_lp` (the original loan-path).
          */
         let loan_path_elem = LpInterior(mc::InteriorField(new_field_name));
-        let lp = LpExtend(parent, mc, loan_path_elem);
+        let lp : LoanPath = LpExtend(parent, mc, loan_path_elem);
         debug!("add_fragment_sibling(lp={}, origin_lp={})",
                lp.repr(tcx), origin_lp.repr(tcx));
         let mp = self.move_path(tcx, Rc::new(lp));
@@ -641,6 +716,7 @@ impl MoveData {
                     let rm = Removed { where: kill_id, what_path: move_path_index };
                     self.remove_drop_obligations(tcx, rm, dfcx_needs_drop);
                 }
+                LpDowncast(..) => {} // FIXME: is this right, or should this loop to top?
                 LpExtend(..) => {}
             }
         }
@@ -657,6 +733,7 @@ impl MoveData {
                     let kill_id = closure_to_block(closure_expr_id, tcx);
                     dfcx_assign.add_kill(kill_id, assignment_index);
                 }
+                LpDowncast(..) |
                 LpExtend(..) => {
                     tcx.sess.bug("var assignment for non var path");
                 }
@@ -800,16 +877,10 @@ impl MoveData {
     // The above comment should be revised/shortened to a succinct
     // summary.
 
-    fn needs_drop(&self, tcx: &ty::ctxt, move_path_index: MovePathIndex) -> bool {
-        //! Returns true iff move_path_index needs drop.
-        let path_type = self.path_loan_path(move_path_index).to_type(tcx);
-        ty::type_needs_drop(tcx, path_type)
-    }
-
-    fn for_each_droppable_leaf(&self,
-                               tcx: &ty::ctxt,
-                               root: MovePathIndex,
-                               found_droppable_leaf: |MovePathIndex|) {
+    fn for_each_leaf(&self,
+                     _tcx: &ty::ctxt,
+                     root: MovePathIndex,
+                     found_leaf: |MovePathIndex|) {
         //! Here we normalize a path so that it is unraveled to its
         //! consituent droppable pieces that might be independently
         //! handled by the function being compiled: e.g. `s.a.j`
@@ -820,12 +891,8 @@ impl MoveData {
         //! Note that the callback is only invoked on unraveled leaves
         //! that also need to be dropped.
 
-        if !self.needs_drop(tcx, root) {
-            return;
-        }
-
         if self.path_is_leaf(root) {
-            found_droppable_leaf(root);
+            found_leaf(root);
             return;
         }
 
@@ -833,16 +900,13 @@ impl MoveData {
         stack.push(root);
         loop {
             let top = match stack.pop() { None => break, Some(elem) => elem };
-            assert!(self.needs_drop(tcx, top));
             assert!(!self.path_is_leaf(top));
             let mut child = self.path_first_child(top);
             while child != InvalidMovePathIndex {
-                if self.needs_drop(tcx, child) {
-                    if self.path_is_leaf(child) {
-                        found_droppable_leaf(child);
-                    } else {
-                        stack.push(child);
-                    }
+                if self.path_is_leaf(child) {
+                    found_leaf(child);
+                } else {
+                    stack.push(child);
                 }
 
                 child = self.path_next_sibling(child);
@@ -861,7 +925,7 @@ impl MoveData {
             dfcx_needs_drop.add_gen(assignment.id, move_path_index.get());
         };
 
-        self.for_each_droppable_leaf(tcx, assignment.path, add_gen);
+        self.for_each_leaf(tcx, assignment.path, add_gen);
     }
 
     fn remove_drop_obligations<A:RemoveNeedsDropArg>(&self,
@@ -881,7 +945,7 @@ impl MoveData {
             dfcx_needs_drop.add_kill(id, move_path_index.get());
         };
 
-        self.for_each_droppable_leaf(tcx, path, add_kill);
+        self.for_each_leaf(tcx, path, add_kill);
     }
 }
 
diff --git a/src/librustc/middle/mem_categorization.rs b/src/librustc/middle/mem_categorization.rs
index abed04c..38c4f0d 100644
--- a/src/librustc/middle/mem_categorization.rs
+++ b/src/librustc/middle/mem_categorization.rs
@@ -88,7 +88,7 @@ pub enum categorization {
     cat_arg(ast::NodeId),              // formal argument
     cat_deref(cmt, uint, PointerKind), // deref of a ptr
     cat_interior(cmt, InteriorKind),   // something interior: field, tuple, etc
-    cat_downcast(cmt),                 // selects a particular enum variant (*1)
+    cat_downcast(cmt, ast::DefId),     // selects a particular enum variant (*1)
     cat_discr(cmt, ast::NodeId),       // match discriminant (see preserve())
 
     // (*1) downcast is only required if the enum has more than one variant
@@ -973,13 +973,14 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {
     pub fn cat_downcast<N:ast_node>(&self,
                                     node: &N,
                                     base_cmt: cmt,
-                                    downcast_ty: ty::t)
+                                    downcast_ty: ty::t,
+                                    variant_did: ast::DefId)
                                     -> cmt {
         Rc::new(cmt_ {
             id: node.id(),
             span: node.span(),
             mutbl: base_cmt.mutbl.inherit(),
-            cat: cat_downcast(base_cmt),
+            cat: cat_downcast(base_cmt, variant_did),
             ty: downcast_ty
         })
     }
@@ -1052,14 +1053,14 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {
           }
           ast::PatEnum(_, Some(ref subpats)) => {
             match self.tcx().def_map.borrow().find(&pat.id) {
-                Some(&def::DefVariant(enum_did, _, _)) => {
+                Some(&def::DefVariant(enum_did, variant_did, _)) => {
                     // variant(x, y, z)
 
                     let downcast_cmt = {
                         if ty::enum_is_univariant(self.tcx(), enum_did) {
                             cmt // univariant, no downcast needed
                         } else {
-                            self.cat_downcast(pat, cmt.clone(), cmt.ty)
+                            self.cat_downcast(pat, cmt.clone(), cmt.ty, variant_did)
                         }
                     };
 
@@ -1213,7 +1214,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {
           cat_discr(ref cmt, _) => {
             self.cmt_to_string(&**cmt)
           }
-          cat_downcast(ref cmt) => {
+          cat_downcast(ref cmt, _) => {
             self.cmt_to_string(&**cmt)
           }
         }
@@ -1252,7 +1253,7 @@ impl cmt_ {
             cat_upvar(..) => {
                 Rc::new((*self).clone())
             }
-            cat_downcast(ref b) |
+            cat_downcast(ref b, _) |
             cat_discr(ref b, _) |
             cat_interior(ref b, _) |
             cat_deref(ref b, _, OwnedPtr) => {
@@ -1276,7 +1277,7 @@ impl cmt_ {
             cat_deref(ref b, _, Implicit(ty::MutBorrow, _)) |
             cat_deref(ref b, _, BorrowedPtr(ty::UniqueImmBorrow, _)) |
             cat_deref(ref b, _, Implicit(ty::UniqueImmBorrow, _)) |
-            cat_downcast(ref b) |
+            cat_downcast(ref b, _) |
             cat_deref(ref b, _, OwnedPtr) |
             cat_interior(ref b, _) |
             cat_discr(ref b, _) => {
@@ -1350,7 +1351,7 @@ impl Repr for categorization {
             cat_interior(ref cmt, interior) => {
                 format!("{}.{}", cmt.cat.repr(tcx), interior.repr(tcx))
             }
-            cat_downcast(ref cmt) => {
+            cat_downcast(ref cmt, _) => {
                 format!("{}->(enum)", cmt.cat.repr(tcx))
             }
             cat_discr(ref cmt, _) => {
diff --git a/src/librustc/middle/ty.rs b/src/librustc/middle/ty.rs
index 52fe114..a018595 100644
--- a/src/librustc/middle/ty.rs
+++ b/src/librustc/middle/ty.rs
@@ -3097,29 +3097,50 @@ pub fn array_element_ty(t: t) -> Option<t> {
 }
 
 /// Returns the type of element at index `i` in tuple or tuple-like type.
-pub fn positional_element_ty(cx: &ctxt, t: t, i: uint) -> Option<t> {
-    match get(t).sty {
-        ty_tup(ref v) => v.as_slice().get(i).map(|&t| t),
-        ty_struct(def_id, ref _substs) => lookup_struct_fields(cx, def_id)
+/// requires variant_id be Some(_) iff t represents a ty_enum.
+pub fn positional_element_ty(cx: &ctxt, t: t, i: uint, variant_id: Option<ast::DefId>) -> Option<t> {
+
+    // FIXME probably need to pass in substs from the surrounding
+    // context, not the substs from the definition itself.
+
+    match (&get(t).sty, variant_id) {
+        (&ty_tup(ref v), None) => v.as_slice().get(i).map(|&t| t),
+
+
+        (&ty_struct(def_id, ref substs), None) => lookup_struct_fields(cx, def_id)
             .as_slice().get(i)
-            .map(|&t|lookup_item_type(cx, t.id).ty),
-        ty_enum(_def_id, ref _substs) => unimplemented!(),
+            .map(|&t|lookup_item_type(cx, t.id).ty.subst(cx, substs)),
+
+        (&ty_enum(def_id, ref substs), Some(variant_def_id)) => {
+            let variant_info = enum_variant_with_id(cx, def_id, variant_def_id);
+            variant_info.args.as_slice().get(i).map(|t|t.subst(cx, substs))
+        }
+
         _ => None
     }
 }
 
 /// Returns the type of element at field `n` in struct or struct-like type.
-pub fn named_element_ty(cx: &ctxt, t: t, n: ast::Name) -> Option<t> {
-    match get(t).sty {
-        ty_struct(def_id, ref _substs) => {
+/// requires variant_id is Some(_) iff t represents a ty_enum.
+pub fn named_element_ty(cx: &ctxt, t: t, n: ast::Name, variant_id: Option<ast::DefId>) -> Option<t> {
+
+    // FIXME probably need to pass in substs from the surrounding
+    // context, not the substs from the definition itself.
+
+    match (&get(t).sty, variant_id) {
+        (&ty_struct(def_id, ref substs), None) => {
             let r = lookup_struct_fields(cx, def_id);
             r.iter().find(|f| f.name == n)
-                // FIXME probably need to pass in substs from the
-                // surrounding context, not the substs from the
-                // definition itself.
-                .map(|&f| lookup_field_type(cx, def_id, f.id, _substs))
+                .map(|&f| lookup_field_type(cx, def_id, f.id, substs))
+        }
+        (&ty_enum(def_id, ref substs), Some(variant_def_id)) => {
+            let variant_info = enum_variant_with_id(cx, def_id, variant_def_id);
+            variant_info.arg_names.as_ref()
+                .expect("must have struct enum variant if accessing a named fields")
+                .iter().zip(variant_info.args.iter())
+                .find(|&(ident, _)| ident.name == n)
+                .map(|(_ident, arg_t)| arg_t.subst(cx, substs))
         }
-        ty_enum(_def_id, ref _substs) => unimplemented!(),
         _ => None
     }
 }
diff --git a/src/librustc/middle/typeck/check/regionck.rs b/src/librustc/middle/typeck/check/regionck.rs
index eb630d0..33e4f87 100644
--- a/src/librustc/middle/typeck/check/regionck.rs
+++ b/src/librustc/middle/typeck/check/regionck.rs
@@ -1446,7 +1446,7 @@ fn link_region(rcx: &Rcx,
             }
 
             mc::cat_discr(cmt_base, _) |
-            mc::cat_downcast(cmt_base) |
+            mc::cat_downcast(cmt_base, _) |
             mc::cat_deref(cmt_base, _, mc::GcPtr(..)) |
             mc::cat_deref(cmt_base, _, mc::OwnedPtr) |
             mc::cat_interior(cmt_base, _) => {
@@ -1648,7 +1648,7 @@ fn adjust_upvar_borrow_kind_for_mut(rcx: &Rcx,
         match cmt.cat.clone() {
             mc::cat_deref(base, _, mc::OwnedPtr) |
             mc::cat_interior(base, _) |
-            mc::cat_downcast(base) |
+            mc::cat_downcast(base, _) |
             mc::cat_discr(base, _) => {
                 // Interior or owned data is mutable if base is
                 // mutable, so iterate to the base.
@@ -1703,7 +1703,7 @@ fn adjust_upvar_borrow_kind_for_unique(rcx: &Rcx, cmt: mc::cmt) {
         match cmt.cat.clone() {
             mc::cat_deref(base, _, mc::OwnedPtr) |
             mc::cat_interior(base, _) |
-            mc::cat_downcast(base) |
+            mc::cat_downcast(base, _) |
             mc::cat_discr(base, _) => {
                 // Interior or owned data is unique if base is
                 // unique.

commit 8c8de74db175500d0e0d79d753663c03d8ebae5c
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Mon Jul 21 19:05:47 2014 +0200

    rust-needsdrop checkpoint: plausible struct fragments.
    
    Since I'm likely to remove this comment in a future rebase but want to
    record it somewhere, here goes:
    
        // A digression on needs-drop design.
        //
        // Lets assume we had a pre-existing drop obligation ND = { s.a, s2 }, where:
        // ```
        // struct S { a: A, b: B, c: C }
        // struct A { i: I, j: J, k: K }
        // struct J { x: X, y: Y, z: Z }
        // ```
        // and `s : S` (and `s2 : S` as well).
        //
        // Moving `s.a.j.x` implies that:
        // * We no longer have a drop-obligation for s.a in its entirety: ND' := ND \ { s.a }
        // * We now do have drop-obligations for the portions of `s.a` that were not moved:
        //   ND' := ND + { s.a.i, s.a.k }
        // * Likewise, we also have drop-obligations for the portions of `s.a.j` that were
        //   not moved:
        //   ND' := ND + { s.a.j.y, s.a.j.z }
        //
        // Altogether, the above modifications accumulate to:
        // ND' := ND \ { s.a } + { s.a.i, s.a.j.y, s.a.j.z, s.a.k }
        //
        // To simplify constructions like the above let us define taking the derivative
        // of a path P with respect to an appropriate subpath suffix S: d/d{S}(P)
        //
        // So for example, d/d{.j.x}(s.a) := { s.a.i, s.a.j.y, s.a.j.z, s.a.k }
        //
        // TODO: Write definition of d/d{S}(P), presumably by induction on suffix S.
        //
        // For d/d{.j.x}(s.a), S = .j.x and P = s.a:
        //
        // 1. P_0 = s.a      : remove obligation s.a, if present
        //
        // 2. P_1 = s.a.j    : assert obligation s.a.j not present; add
        //                     all needs-drop fields of s.a, then remove s.a.j.
        // 3. P_2 = s.a.j.x  : assert obligation s.a.j.x not present; add
        //                     all needs-drop fields of s.a.j, then remove s.a.j.x.
        //
        // Big Question: Under the kill/gen paradigm, how do I ensure that
        // I only add the bits associated with d/d{.j.x}(s.a) and not the
        // bits associated with d/d{.a.j.x}(s) ?  I.e. the explanation
        // above makes assumptions about computations I will be able to do
        // as part the transfer function, but I need to encode those
        // computations as gen+kill bits.
        //
        // ==> one way to resolve this problem while remaining under the
        //     gen/kill paradigm is to carry-on with a suggestion I made
        //     to Niko a while back, namely to treat the path `s` as a
        //     shorthand for
        //
        //      `{ s.a.i, s.a.j.x, s.a.j.y, s.a.j.z, s.a.k, s.b, s.c }`,
        //
        //     and likewise `s.a` as as shorthand for
        //
        //      `{ s.a.i, s.a.j.x, s.a.j.y, s.a.j.z, s.a.k }`
        //
        //     That is, put these paths through a normalization process that
        //     unrolls them to their leaves (or at least, their leaves with
        //     respect to a given piece of code.
        //
        //     I might even be able to implement this independently of
        //     the other dataflow analyses, since happenstance led me
        //     to make the needs-drop analysis separate from the
        //     loans/moves/assigns analyses.
        //
        // UPDATE: The above is in fact the strategy that Felix went with.
        // The above comment should be revised/shortened to a succinct
        // summary.
    
    check_drops: fixes to the warning output.
    
    Most importantly, fixed the notes to point to the *uninitialized*
    paths.
    
    Made `LoanPath::to_type` provide a better msg when type lookup fails.
    
    rust-needsdrop: fixes to `LoanPath::to_type` and `ty::positional_element_ty`.
    
    rust-needsdrop: Ignore unreachable portions of control-flow graph.
---
 src/librustc/middle/borrowck/check_drops.rs | 177 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 src/librustc/middle/borrowck/mod.rs         |  61 ++++++++++++++++-----
 src/librustc/middle/borrowck/move_data.rs   | 326 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++--------------------------------
 src/librustc/middle/dataflow.rs             |  62 +++++++++++++++++----
 src/librustc/middle/ty.rs                   |   6 ++-
 5 files changed, 513 insertions(+), 119 deletions(-)

diff --git a/src/librustc/middle/borrowck/check_drops.rs b/src/librustc/middle/borrowck/check_drops.rs
new file mode 100644
index 0000000..523ea68
--- /dev/null
+++ b/src/librustc/middle/borrowck/check_drops.rs
@@ -0,0 +1,177 @@
+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT
+// file at the top-level directory of this distribution and at
+// http://rust-lang.org/COPYRIGHT.
+//
+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
+// option. This file may not be copied, modified, or distributed
+// except according to those terms.
+
+#![allow(unused_imports)]
+#![allow(unused_variable)]
+
+use middle::borrowck::*;
+use middle::borrowck::move_data::{Assignment, Move};
+use euv = middle::expr_use_visitor;
+use mc = middle::mem_categorization;
+use middle::dataflow;
+use middle::graph;
+use middle::cfg;
+use middle::ty;
+use middle::ty::TypeContents;
+use std::rc::Rc;
+use std::collections::hashmap::HashMap;
+use syntax::{ast,ast_map};
+
+pub fn check_drops(bccx: &BorrowckCtxt,
+                   flowed_move_data: &move_data::FlowedMoveData,
+                   cfg: &cfg::CFG,
+                   decl: &ast::FnDecl,
+                   body: &ast::Block) {
+    debug!("check_dtors(body id={:?})", body.id);
+
+    cfg.graph.each_node(|node_index, node| {
+        // Special case: do not flag violations for control flow from
+        // return expressions.  Each return can be prefixed with
+        // separate destructor invocation code specialized to whatever
+        // paths need dropping.
+        if node_index == cfg.exit {
+            return true;
+        }
+
+        // Do not bother doing the query for unreachable portions of
+        // the control flow graph.
+        if !cfg.is_reachable(node_index) {
+            return true;
+        }
+
+        // First, figure out if there is >1 incoming edge.
+        {
+            let mut how_many = 0u;
+            cfg.graph.each_incoming_edge(node_index, |_edge_index, _edge| {
+                how_many += 1;
+                how_many <= 1 // keep looking until we see >1.
+            });
+
+            if how_many <= 1 {
+                return true;
+            }
+        }
+
+        // Okay, >1 incoming edge.
+        //
+        // Now we need to verify that all predecessor nodes establish
+        // the same set of destruction obligations for the current
+        // scope.
+        //
+        // We could just do a pairwise comparison, e.g. assume that the
+        // first incoming edge is correct, then compare (1st, 2nd);
+        // (2nd, 3rd); etc, until we encounter a difference, and then
+        // report that as an error.
+        //
+        // However, under the (not yet validated) assumption that most
+        // errors that we see will be missing calls to drop, we adopt
+        // a different strategy: First, compute the intersection `I`
+        // of the destruction obligations for all incoming edges.
+        // Then compare each edge's destruction obligations against
+        // `I`, and report all extra entries as needing to be
+        // explicitly dropped on this edge (or to be reconstructed on
+        // the edges where it was moved away).
+
+        let move_data = &flowed_move_data.move_data;
+        let needs_drop = &flowed_move_data.dfcx_needs_drop;
+        let path_count = move_data.paths.borrow().len();
+
+        let intersection = {
+            // (it doesn't matter which index we grab this from, we going
+            // to fill it with ones anyway.)
+            let mut temp = needs_drop.bitset_for(dataflow::Entry, node_index);
+            for u in temp.mut_iter() { *u = -1 as uint; }
+            cfg.graph.each_incoming_edge(node_index, |_edge_index, edge| {
+                let source = edge.source();
+                if cfg.is_reachable(source) {
+                    needs_drop.apply_op(dataflow::Exit,
+                                        source,
+                                        temp.as_mut_slice(),
+                                        dataflow::Intersect);
+                }
+                true
+            });
+            temp
+        };
+
+        cfg.graph.each_incoming_edge(node_index, |edge_index, edge| {
+            let source = edge.source();
+            let temp = needs_drop.bitset_for(dataflow::Exit, source);
+            if temp != intersection {
+                let source_id = cfg.graph.node(source).data.id;
+                let opt_source_span = bccx.tcx.map.opt_span(source_id);
+                needs_drop.each_bit_for_node(dataflow::Exit, source, |bit_idx| {
+                    if !cfg.is_reachable(source) ||
+                        dataflow::is_bit_set(intersection.as_slice(), bit_idx) {
+                        return true;
+                    }
+
+                    let paths = move_data.paths.borrow();
+                    let path = paths.get(bit_idx);
+                    let lp = &path.loan_path;
+                    let loan_path_str = bccx.loan_path_to_string(lp.deref());
+
+                    let cfgidx_and_id = format!(" (cfgidx={}, id={})", source, source_id);
+                    let where = if bccx.tcx.sess.verbose() {
+                        cfgidx_and_id.as_slice()
+                    } else {
+                        ""
+                    };
+
+                    let msg = format!("Storage at `{:s}` is left initialized here{:s}, \
+                                       but uninitialized on other control flow paths. \
+                                       (Consider either calling `drop()` on it here, \
+                                       or reinitializing it on the other paths)",
+                                      loan_path_str, where);
+
+                    match opt_source_span {
+                        Some(span) => bccx.tcx.sess.span_warn(span, msg.as_slice()),
+                        None => bccx.tcx.sess.warn(msg.as_slice()),
+                    }
+                    cfg.graph.each_incoming_edge(node_index, |edge_index, edge| {
+                        let source2 = edge.source();
+                        if !cfg.is_reachable(source2) {
+                            return true;
+                        }
+
+                        let temp2 = needs_drop.bitset_for(dataflow::Exit, source2);
+                        let mut count = 0u;
+                        if !dataflow::is_bit_set(temp2.as_slice(), bit_idx) {
+                            count += 1;
+                            let source2_id = cfg.graph.node(source2).data.id;
+                            let opt_source2_span = bccx.tcx.map.opt_span(source2_id);
+                            let cfgidx_and_id = format!(" (cfgidx={}, id={})",
+                                                        source2, source2_id);
+                            let where = if bccx.tcx.sess.verbose() {
+                                cfgidx_and_id.as_slice()
+                            } else {
+                                ""
+                            };
+                            let msg = format!("Path {:u} here{:s} leaves `{:s}` \
+                                               uninitialized.",
+                                              count, where, loan_path_str);
+                            match opt_source2_span {
+                                Some(span) => bccx.tcx.sess.span_note(span, msg.as_slice()),
+                                None => bccx.tcx.sess.note(msg.as_slice()),
+                            }
+                        }
+                        true
+                    });
+
+                    true
+                });
+            }
+
+            true
+        });
+
+        true
+    });
+}
diff --git a/src/librustc/middle/borrowck/mod.rs b/src/librustc/middle/borrowck/mod.rs
index 45dbe10..f07cd6f 100644
--- a/src/librustc/middle/borrowck/mod.rs
+++ b/src/librustc/middle/borrowck/mod.rs
@@ -55,7 +55,7 @@ pub mod graphviz;
 
 pub mod move_data;
 
-// pub mod needs_drop;
+pub mod check_drops;
 
 #[deriving(Clone)]
 pub struct LoanDataFlowOperator;
@@ -141,6 +141,8 @@ fn borrowck_fn(this: &mut BorrowckCtxt,
                        move_data:flowed_moves } =
         build_borrowck_dataflow_data(this, fk, decl, &cfg, body, sp, id);
 
+    check_drops::check_drops(this, &flowed_moves, &cfg, decl, body);
+
     check_loans::check_loans(this, &loan_dfcx, flowed_moves,
                              all_loans.as_slice(), decl, body);
 
@@ -284,25 +286,56 @@ pub enum LoanPath {
 
 impl LoanPath {
     fn to_type(&self, tcx: &ty::ctxt) -> ty::t {
-        match *self {
+        use Element = middle::mem_categorization::InteriorElement;
+        use Field = middle::mem_categorization::InteriorField;
+
+        debug!("lp.to_type() for lp={:s}", self.repr(tcx));
+        let opt_ty = match *self {
             LpUpvar(ty::UpvarId { var_id: id, closure_expr_id: _ }) |
-            LpVar(id) => ty::node_id_to_type_opt(tcx, id).unwrap(),
+            LpVar(id) => ty::node_id_to_type_opt(tcx, id),
 
             LpExtend(ref lp, _mc, ref loan_path_elem) => {
                 let t = lp.to_type(tcx);
-                match *loan_path_elem {
-                    LpDeref(_pointer_kind) =>
-                        // (claiming deref is explicit)
-                        ty::deref(t, true).unwrap().ty,
-                    LpInterior(mc::InteriorElement(_element_kind)) =>
-                        ty::array_element_ty(t).unwrap().ty,
-                    LpInterior(mc::InteriorField(mc::NamedField(field_name))) =>
-                        ty::named_element_ty(tcx, t, field_name).unwrap(),
-                    LpInterior(mc::InteriorField(mc::PositionalField(tuple_idx))) =>
-                        ty::positional_element_ty(tcx, t, tuple_idx).unwrap(),
+                let t_sty = &ty::get(t).sty;
+                match (loan_path_elem, t_sty) {
+                    (&LpDeref(_), &ty::ty_ptr(ty::mt{ty: t, ..})) |
+                    (&LpDeref(_), &ty::ty_rptr(_, ty::mt{ty: t, ..})) |
+                    (&LpDeref(_), &ty::ty_box(t)) |
+                    (&LpDeref(_), &ty::ty_uniq(t)) => Some(t),
+
+                    (&LpInterior(Field(mc::NamedField(ast_name))),
+                     _) => ty::named_element_ty(tcx, t, ast_name),
+
+                    (&LpInterior(Field(mc::PositionalField(idx))),
+                     _) => ty::positional_element_ty(tcx, t, idx),
+
+                    // (Deliberately not using ty::array_element_ty
+                    // here, because that assumes r-value context and
+                    // returns deref'ed elem type, but loan structure
+                    // separates element-access from deref.)
+                    (&LpInterior(Element(_)), &ty::ty_str) =>
+                        Some(ty::mk_ptr(tcx, ty::mt{ty: ty::mk_u8(),
+                                                    mutbl: ast::MutImmutable})),
+                    (&LpInterior(Element(_)), &ty::ty_vec(mt, _len)) =>
+                        Some(ty::mk_ptr(tcx, mt)),
+
+                    _ => None,
                 }
             }
-        }
+        };
+
+        let t = opt_ty.unwrap_or_else(|| {
+            let id = self.kill_scope(tcx);
+            let msg = format!("no type found for lp={:s}", self.repr(tcx));
+            let opt_span = tcx.map.opt_span(id);
+            match opt_span {
+                Some(s) => tcx.sess.span_bug(s, msg.as_slice()),
+                None => tcx.sess.bug(msg.as_slice()),
+            }
+        });
+        debug!("lp.to_type() for lp={:s} returns t={:s}",
+               self.repr(tcx), t.repr(tcx));
+        t
     }
 }
 
diff --git a/src/librustc/middle/borrowck/move_data.rs b/src/librustc/middle/borrowck/move_data.rs
index 99430c8..9314aae 100644
--- a/src/librustc/middle/borrowck/move_data.rs
+++ b/src/librustc/middle/borrowck/move_data.rs
@@ -271,10 +271,20 @@ impl MoveData {
         self.paths.borrow().get(index.get()).first_move
     }
 
+    /// Returns true iff `index` has no children.
+    fn path_is_leaf(&self, index: MovePathIndex) -> bool {
+        self.path_first_child(index) == InvalidMovePathIndex
+    }
+
+    /// Returns the index of first child, or `InvalidMovePathIndex` if
+    /// `index` is leaf.
     fn path_first_child(&self, index: MovePathIndex) -> MovePathIndex {
         self.paths.borrow().get(index.get()).first_child
     }
 
+    /// Returns index for next sibling, or `InvalidMovePathIndex` if
+    /// `index` has no remaining siblings in the list.  (The head of
+    /// the list is the parent's first child; see `path_first_child`).
     fn path_next_sibling(&self, index: MovePathIndex) -> MovePathIndex {
         self.paths.borrow().get(index.get()).next_sibling
     }
@@ -485,6 +495,7 @@ impl MoveData {
          * represents `s.x.j`, then adds moves paths for `s.x.i` and
          * `s.x.k`, the siblings of `s.x.j`.
          */
+        debug!("add_fragment_siblings(lp={})", lp.repr(tcx));
 
         match *lp {
             LpVar(_) | LpUpvar(_) => {} // Local variables have no siblings.
@@ -501,52 +512,78 @@ impl MoveData {
 
             // field access LV.x and tuple access LV#k are the cases
             // we are interested in
-            LpExtend(ref parent, mc, LpInterior(mc::InteriorField(ref field_name))) => {
-                let add_new_field = |new_field_name| {
-                    let loan_path_elem = LpInterior(mc::InteriorField(new_field_name));
-                    let lp = LpExtend(parent.clone(), mc, loan_path_elem);
-                    let mp = self.move_path(tcx, Rc::new(lp));
-
-                    // Do not worry about checking for duplicates
-                    // here; if necessary we will sort and dedup after
-                    // all are added.
-                    self.fragments.borrow_mut().push(mp);
-
-                    mp
-                };
+            LpExtend(ref parent, mc,
+                     LpInterior(mc::InteriorField(ref field_name))) =>
+                self.add_fragment_siblings_for_extension(
+                    tcx, parent, mc, field_name, &lp),
+        }
+    }
 
-                let parent_ty = parent.to_type(tcx);
-                match *field_name {
-                    mc::NamedField(ast_name) => {
-                        let parent_def_id = match ty::get(parent_ty).sty {
-                            ty::ty_struct(def_id, ref _substs) |
-                            ty::ty_enum(def_id, ref _substs) => def_id,
-                            _ => fail!("type with named fields must be struct or enum"),
-                        };
-                        let fields = ty::lookup_struct_fields(tcx, parent_def_id);
-                        for f in fields.iter().filter(|field| field.name != ast_name) {
-                            add_new_field(mc::NamedField(f.name));
-                        }
-                    }
-                    mc::PositionalField(tuple_idx) => {
-                        let tuple_len = match ty::get(parent_ty).sty {
-                            ty::ty_tup(ref v) => v.len(),
-                            ty::ty_struct(def_id, ref _substs) =>
-                                ty::lookup_struct_fields(tcx, def_id).len(),
-                            ty::ty_enum(def_id, ref _substs) =>
-                                ty::lookup_struct_fields(tcx, def_id).len(),
-                            _ => fail!("type with positional field must be tuple, struct or enum"),
-                        };
-                        for i in range(0, tuple_len) {
-                            if i == tuple_idx { continue }
-                            add_new_field(mc::PositionalField(i));
-                        }
-                    }
+    fn add_fragment_siblings_for_extension(&self,
+                                           tcx: &ty::ctxt,
+                                           parent: &Rc<LoanPath>,
+                                           mc: mc::MutabilityCategory,
+                                           origin_field_name: &mc::FieldName,
+                                           origin_lp: &Rc<LoanPath>) {
+        /*! We have determined that `origin_lp` destructures to
+         * LpExtend(parent, original_field_name). Based on this,
+         * add move paths for all of the siblings of `origin_lp`.
+         */
+        let parent_ty = parent.to_type(tcx);
+
+        match *origin_field_name {
+            mc::NamedField(ast_name) => {
+                let parent_def_id = match ty::get(parent_ty).sty {
+                    ty::ty_struct(def_id, ref _substs) |
+                    ty::ty_enum(def_id, ref _substs) => def_id,
+                    _ => fail!("type shouldn't have named fields"),
+                };
+                let fields = ty::lookup_struct_fields(tcx, parent_def_id);
+                for f in fields.iter().filter(|field| field.name != ast_name) {
+                    self.add_fragment_sibling(
+                        tcx, parent.clone(), mc, mc::NamedField(f.name), origin_lp);
+                }
+            }
+            mc::PositionalField(tuple_idx) => {
+                let tuple_len = match ty::get(parent_ty).sty {
+                    ty::ty_tup(ref v) => v.len(),
+                    ty::ty_struct(def_id, ref _substs) =>
+                        ty::lookup_struct_fields(tcx, def_id).len(),
+                    ty::ty_enum(def_id, ref _substs) =>
+                        ty::lookup_struct_fields(tcx, def_id).len(),
+                    _ => fail!("type shouldn't have positional fields"),
+                };
+                for i in range(0, tuple_len) {
+                    if i == tuple_idx { continue }
+                    self.add_fragment_sibling(
+                        tcx, parent.clone(), mc, mc::PositionalField(i), origin_lp);
                 }
             }
         }
     }
 
+    fn add_fragment_sibling(&self,
+                            tcx: &ty::ctxt,
+                            parent: Rc<LoanPath>,
+                            mc: mc::MutabilityCategory,
+                            new_field_name: mc::FieldName,
+                            origin_lp: &Rc<LoanPath>) -> MovePathIndex {
+        /*! Adds the single sibling `LpExtend(parent, new_field_name)`
+         * of `origin_lp` (the original loan-path).
+         */
+        let loan_path_elem = LpInterior(mc::InteriorField(new_field_name));
+        let lp = LpExtend(parent, mc, loan_path_elem);
+        debug!("add_fragment_sibling(lp={}, origin_lp={})",
+               lp.repr(tcx), origin_lp.repr(tcx));
+        let mp = self.move_path(tcx, Rc::new(lp));
+
+        // Do not worry about checking for duplicates here; if
+        // necessary, we will sort and dedup after all are added.
+        self.fragments.borrow_mut().push(mp);
+
+        mp
+    }
+
     fn add_gen_kills(&self,
                      tcx: &ty::ctxt,
                      dfcx_moves: &mut MoveDataFlow,
@@ -565,7 +602,7 @@ impl MoveData {
         for (i, move) in self.moves.borrow().iter().enumerate() {
             dfcx_moves.add_gen(move.id, i);
             debug!("remove_drop_obligations move {}", move.to_string(self, tcx));
-            self.remove_drop_obligation(move, dfcx_needs_drop);
+            self.remove_drop_obligations(tcx, move, dfcx_needs_drop);
         }
 
         for (i, assignment) in self.var_assignments.borrow().iter().enumerate() {
@@ -587,17 +624,22 @@ impl MoveData {
             match *path.loan_path {
                 LpVar(id) => {
                     let kill_id = tcx.region_maps.var_scope(id);
-                    let path = *self.path_map.borrow().get(&path.loan_path);
-                    self.kill_moves(path, kill_id, dfcx_moves);
-                    self.remove_drop_obligation(
-                        Removed { where: kill_id, what_path: path }, dfcx_needs_drop);
+                    let move_path_index =
+                        *self.path_map.borrow().get(&path.loan_path);
+                    self.kill_moves(move_path_index, kill_id, dfcx_moves);
+                    debug!("remove_drop_obligations scope {} {}",
+                           kill_id, path.loan_path.repr(tcx));
+                    let rm = Removed { where: kill_id, what_path: move_path_index };
+                    self.remove_drop_obligations(tcx, rm, dfcx_needs_drop);
                 }
                 LpUpvar(ty::UpvarId { var_id: _, closure_expr_id }) => {
                     let kill_id = closure_to_block(closure_expr_id, tcx);
-                    let path = *self.path_map.borrow().get(&path.loan_path);
-                    self.kill_moves(path, kill_id, dfcx_moves);
-                    self.remove_drop_obligation(
-                        Removed { where: kill_id, what_path: path }, dfcx_needs_drop);
+                    let move_path_index = *self.path_map.borrow().get(&path.loan_path);
+                    self.kill_moves(move_path_index, kill_id, dfcx_moves);
+                    debug!("remove_drop_obligations scope {} {}",
+                           kill_id, path.loan_path.repr(tcx));
+                    let rm = Removed { where: kill_id, what_path: move_path_index };
+                    self.remove_drop_obligations(tcx, rm, dfcx_needs_drop);
                 }
                 LpExtend(..) => {}
             }
@@ -689,57 +731,157 @@ impl MoveData {
         }
     }
 
+
+    // A digression on needs-drop design.
+    //
+    // Lets assume we had a pre-existing drop obligation ND = { s.a, s2 }, where:
+    // ```
+    // struct S { a: A, b: B, c: C }
+    // struct A { i: I, j: J, k: K }
+    // struct J { x: X, y: Y, z: Z }
+    // ```
+    // and `s : S` (and `s2 : S` as well).
+    //
+    // Moving `s.a.j.x` implies that:
+    // * We no longer have a drop-obligation for s.a in its entirety: ND' := ND \ { s.a }
+    // * We now do have drop-obligations for the portions of `s.a` that were not moved:
+    //   ND' := ND + { s.a.i, s.a.k }
+    // * Likewise, we also have drop-obligations for the portions of `s.a.j` that were
+    //   not moved:
+    //   ND' := ND + { s.a.j.y, s.a.j.z }
+    //
+    // Altogether, the above modifications accumulate to:
+    // ND' := ND \ { s.a } + { s.a.i, s.a.j.y, s.a.j.z, s.a.k }
+    //
+    // To simplify constructions like the above let us define taking the derivative
+    // of a path P with respect to an appropriate subpath suffix S: d/d{S}(P)
+    //
+    // So for example, d/d{.j.x}(s.a) := { s.a.i, s.a.j.y, s.a.j.z, s.a.k }
+    //
+    // TODO: Write definition of d/d{S}(P), presumably by induction on suffix S.
+    //
+    // For d/d{.j.x}(s.a), S = .j.x and P = s.a:
+    //
+    // 1. P_0 = s.a      : remove obligation s.a, if present
+    //
+    // 2. P_1 = s.a.j    : assert obligation s.a.j not present; add
+    //                     all needs-drop fields of s.a, then remove s.a.j.
+    // 3. P_2 = s.a.j.x  : assert obligation s.a.j.x not present; add
+    //                     all needs-drop fields of s.a.j, then remove s.a.j.x.
+    //
+    // Big Question: Under the kill/gen paradigm, how do I ensure that
+    // I only add the bits associated with d/d{.j.x}(s.a) and not the
+    // bits associated with d/d{.a.j.x}(s) ?  I.e. the explanation
+    // above makes assumptions about computations I will be able to do
+    // as part the transfer function, but I need to encode those
+    // computations as gen+kill bits.
+    //
+    // ==> one way to resolve this problem while remaining under the
+    //     gen/kill paradigm is to carry-on with a suggestion I made
+    //     to Niko a while back, namely to treat the path `s` as a
+    //     shorthand for
+    //
+    //      `{ s.a.i, s.a.j.x, s.a.j.y, s.a.j.z, s.a.k, s.b, s.c }`,
+    //
+    //     and likewise `s.a` as as shorthand for
+    //
+    //      `{ s.a.i, s.a.j.x, s.a.j.y, s.a.j.z, s.a.k }`
+    //
+    //     That is, put these paths through a normalization process that
+    //     unrolls them to their leaves (or at least, their leaves with
+    //     respect to a given piece of code.
+    //
+    //     I might even be able to implement this independently of
+    //     the other dataflow analyses, since happenstance led me
+    //     to make the needs-drop analysis separate from the
+    //     loans/moves/assigns analyses.
+    //
+    // UPDATE: The above is in fact the strategy that Felix went with.
+    // The above comment should be revised/shortened to a succinct
+    // summary.
+
+    fn needs_drop(&self, tcx: &ty::ctxt, move_path_index: MovePathIndex) -> bool {
+        //! Returns true iff move_path_index needs drop.
+        let path_type = self.path_loan_path(move_path_index).to_type(tcx);
+        ty::type_needs_drop(tcx, path_type)
+    }
+
+    fn for_each_droppable_leaf(&self,
+                               tcx: &ty::ctxt,
+                               root: MovePathIndex,
+                               found_droppable_leaf: |MovePathIndex|) {
+        //! Here we normalize a path so that it is unraveled to its
+        //! consituent droppable pieces that might be independently
+        //! handled by the function being compiled: e.g. `s.a.j`
+        //! unravels to `{ s.a.j.x, s.a.j.y, s.a.j.z }` (assuming the
+        //! function never moves out any part of those unraveled
+        //! elements).
+        //!
+        //! Note that the callback is only invoked on unraveled leaves
+        //! that also need to be dropped.
+
+        if !self.needs_drop(tcx, root) {
+            return;
+        }
+
+        if self.path_is_leaf(root) {
+            found_droppable_leaf(root);
+            return;
+        }
+
+        let mut stack = vec![];
+        stack.push(root);
+        loop {
+            let top = match stack.pop() { None => break, Some(elem) => elem };
+            assert!(self.needs_drop(tcx, top));
+            assert!(!self.path_is_leaf(top));
+            let mut child = self.path_first_child(top);
+            while child != InvalidMovePathIndex {
+                if self.needs_drop(tcx, child) {
+                    if self.path_is_leaf(child) {
+                        found_droppable_leaf(child);
+                    } else {
+                        stack.push(child);
+                    }
+                }
+
+                child = self.path_next_sibling(child);
+            }
+        }
+    }
+
     fn add_drop_obligations(&self,
                             tcx: &ty::ctxt,
                             assignment: &Assignment,
                             dfcx_needs_drop: &mut NeedsDropDataFlow) {
-        if ty::type_needs_drop(tcx, assignment.ty(tcx)) {
-            dfcx_needs_drop.add_gen(assignment.id, assignment.path.get());
-        }
+        let add_gen = |move_path_index| {
+            debug!("add_drop_obligations(assignment={}) adds {}",
+                   assignment.to_string(self, tcx),
+                   self.path_loan_path(move_path_index).repr(tcx));
+            dfcx_needs_drop.add_gen(assignment.id, move_path_index.get());
+        };
+
+        self.for_each_droppable_leaf(tcx, assignment.path, add_gen);
     }
 
-    fn remove_drop_obligation<A:RemoveNeedsDropArg>(&self,
-                                                    a: A,
-                                                    dfcx_needs_drop: &mut NeedsDropDataFlow) {
-        // Kill path and all of its sub-paths.
-        // Lets assume we had a pre-existing drop obligation ND = { s.a, s2 },
-        // where:
-        // ```
-        // struct S { a: A, b: B, c: C }
-        // struct A { i: I, j: J, k: K }
-        // struct J { x: X, y: Y, z: Z }
-        // and s : S (and s2 : S as well).
-        //
-        // Moving `s.a.j.x` implies that:
-        // * We no longer have a drop-obligation for s.a in its entirety: ND' := ND \ { s.a }
-        // * We now do have drop-obligations for the portions of `s.a` that were not moved:
-        //   ND' := ND + { s.a.i, s.a.k }
-        // * Likewise, we also have drop-obligations for the portions of `s.a.j` that were
-        //   not moved:
-        //   ND' := ND + { s.a.j.y, s.a.j.z }
-        //
-        // Altogether, the above modifications accumulate to:
-        // ND' := ND \ { s.a } + { s.a.i, s.a.j.y, s.a.j.z, s.a.k }
-        //
-        // To simplify constructions like the above let us define taking the derivative
-        // of a path P with respect to an appropriate subpath suffix S: d/d{S}(P)
-        //
-        // So for example, d/d{.j.x}(s.a) := { s.a.i, s.a.j.y, s.a.j.z, s.a.k }
-        //
-        // TODO: Write definition of d/d{S}(P), presumably by induction on suffix S.
-        //
-        // For d/d{.j.x}(s.a), S = .j.x and P = s.a:
-        //
-        // 1. P_0 = s.a      : remove obligation s.a, if present
-        //
-        // 2. P_1 = s.a.j    : assert obligation s.a.j not present; add
-        //                     all needs-drop fields of s.a, then remove s.a.j.
-        // 3. P_2 = s.a.j.x  : assert obligation s.a.j.x not present; add
-        //                     all needs-drop fields of s.a.j, then remove s.a.j.x.
+    fn remove_drop_obligations<A:RemoveNeedsDropArg>(&self,
+                                                     tcx: &ty::ctxt,
+                                                     a: A,
+                                                     dfcx_needs_drop: &mut NeedsDropDataFlow) {
+        //! Kill path and all of its sub-paths.
+        //! Adds fragment-siblings of path as necessary.
 
         let id = a.node_id_removing_obligation();
-        let path = a.path_being_moved();
-        dfcx_needs_drop.add_kill(id, path.get());
+        let path : MovePathIndex = a.path_being_moved();
+
+        let add_kill = |move_path_index| {
+            debug!("remove_drop_obligations(id={}) removes {}",
+                   id, self.path_loan_path(move_path_index).repr(tcx));
+
+            dfcx_needs_drop.add_kill(id, move_path_index.get());
+        };
+
+        self.for_each_droppable_leaf(tcx, path, add_kill);
     }
 }
 
diff --git a/src/librustc/middle/dataflow.rs b/src/librustc/middle/dataflow.rs
index c32f8db..835798d 100644
--- a/src/librustc/middle/dataflow.rs
+++ b/src/librustc/middle/dataflow.rs
@@ -275,6 +275,19 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {
         (start, end)
     }
 
+    pub fn bitset_for(&self, e: EntryOrExit, cfgidx: CFGIndex) -> Vec<uint> {
+        self.with_set(e, cfgidx, || Vec::new(), |slice| slice.to_owned())
+    }
+
+    /// Let S be the entry/exit (`e`) set for `cfgidx`.  Sets `bits`
+    /// to `bits o S` where `o` denotes the bitwise operator `oper`.
+    pub fn apply_op<Op:BitwiseOperator>(&self,
+                                        e: EntryOrExit,
+                                        cfgidx: CFGIndex,
+                                        bits: &mut [uint],
+                                        oper: Op) {
+        self.with_set(e, cfgidx, || (), |slice| { bitwise(bits, slice, &oper); })
+    }
 
     pub fn each_bit_on_entry(&self,
                              id: ast::NodeId,
@@ -292,15 +305,28 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {
     pub fn each_bit_for_node(&self,
                              e: EntryOrExit,
                              cfgidx: CFGIndex,
-                             f: |uint| -> bool)
+                             on_one: |uint| -> bool)
                              -> bool {
         //! Iterates through each bit that is set on entry/exit to `cfgidx`.
         //! Only useful after `propagate()` has been called.
 
+        self.with_set(e, cfgidx, || true, |slice| {
+            debug!("{:s} each_bit_for_node({}, cfgidx={}) bits={}",
+                   self.analysis_name, e, cfgidx, bits_to_string(slice));
+            self.each_one_bit(slice, |x|on_one(x))
+        })
+    }
+
+    fn with_set<A>(&self,
+                   e: EntryOrExit,
+                   cfgidx: CFGIndex,
+                   default: || -> A,
+                   f: |&[uint]| -> A) -> A {
+
         if self.bits_per_id == 0 {
-            // Skip the surprisingly common degenerate case.  (Note
+            // degenerate case: use the default.  (Note
             // compute_id_range requires self.words_per_id > 0.)
-            return true;
+            return default();
         }
 
         let (start, end) = self.compute_id_range(cfgidx);
@@ -315,9 +341,8 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {
                 temp_bits.as_slice()
             }
         };
-        debug!("{:s} each_bit_for_node({}, cfgidx={}) bits={}",
-               self.analysis_name, e, cfgidx, bits_to_string(slice));
-        self.each_bit(slice, f)
+
+        f(slice)
     }
 
     pub fn each_gen_bit(&self, id: ast::NodeId, f: |uint| -> bool)
@@ -338,11 +363,11 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {
         let gens = self.gens.slice(start, end);
         debug!("{:s} each_gen_bit(id={:?}, gens={})",
                self.analysis_name, id, bits_to_string(gens));
-        self.each_bit(gens, f)
+        self.each_one_bit(gens, f)
     }
 
-    fn each_bit(&self, words: &[uint], f: |uint| -> bool) -> bool {
-        //! Helper for iterating over the bits in a bit set.
+    fn each_one_bit(&self, words: &[uint], f: |uint| -> bool) -> bool {
+        //! Helper for iterating over the 1 bits in a bit set.
         //! Returns false on the first call to `f` that returns false;
         //! if all calls to `f` return true, then returns true.
 
@@ -575,6 +600,14 @@ fn bitwise<Op:BitwiseOperator>(out_vec: &mut [uint],
     changed
 }
 
+pub fn is_bit_set(words: &[uint], bit: uint) -> bool {
+    let word = bit / uint::BITS;
+    let bit_in_word = bit % uint::BITS;
+    let bit_mask = 1 << bit_in_word;
+    let oldv = words[word];
+    0 != (oldv & bit_mask)
+}
+
 fn set_bit(words: &mut [uint], bit: uint) -> bool {
     debug!("set_bit: words={} bit={}",
            mut_bits_to_string(words), bit_str(bit));
@@ -594,11 +627,18 @@ fn bit_str(bit: uint) -> String {
     format!("[{}:{}-{:02x}]", bit, byte, lobits)
 }
 
-struct Union;
+pub struct Union;
 impl BitwiseOperator for Union {
     fn join(&self, a: uint, b: uint) -> uint { a | b }
 }
-struct Subtract;
+pub struct Subtract;
 impl BitwiseOperator for Subtract {
     fn join(&self, a: uint, b: uint) -> uint { a & !b }
 }
+pub struct Intersect;
+impl BitwiseOperator for Intersect {
+    fn join(&self, a: uint, b: uint) -> uint { a & b }
+}
+pub fn subtract(a: &mut [uint], b: &[uint]) {
+    bitwise(a, b, &Subtract);
+}
diff --git a/src/librustc/middle/ty.rs b/src/librustc/middle/ty.rs
index 3afe9bf..52fe114 100644
--- a/src/librustc/middle/ty.rs
+++ b/src/librustc/middle/ty.rs
@@ -3097,10 +3097,12 @@ pub fn array_element_ty(t: t) -> Option<t> {
 }
 
 /// Returns the type of element at index `i` in tuple or tuple-like type.
-pub fn positional_element_ty(_cx: &ctxt, t: t, i: uint) -> Option<t> {
+pub fn positional_element_ty(cx: &ctxt, t: t, i: uint) -> Option<t> {
     match get(t).sty {
         ty_tup(ref v) => v.as_slice().get(i).map(|&t| t),
-        ty_struct(_def_id, ref _substs) => unimplemented!(),
+        ty_struct(def_id, ref _substs) => lookup_struct_fields(cx, def_id)
+            .as_slice().get(i)
+            .map(|&t|lookup_item_type(cx, t.id).ty),
         ty_enum(_def_id, ref _substs) => unimplemented!(),
         _ => None
     }

commit fe571d60942a55a897ae7cb675803020409fd02d
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Mon Jul 21 12:34:56 2014 +0200

    Add accessor to map a LoanPath to its type.
---
 src/librustc/middle/borrowck/mod.rs | 24 ++++++++++++++++++++++++
 1 file changed, 24 insertions(+)

diff --git a/src/librustc/middle/borrowck/mod.rs b/src/librustc/middle/borrowck/mod.rs
index 1cbed9a..45dbe10 100644
--- a/src/librustc/middle/borrowck/mod.rs
+++ b/src/librustc/middle/borrowck/mod.rs
@@ -282,6 +282,30 @@ pub enum LoanPath {
     LpExtend(Rc<LoanPath>, mc::MutabilityCategory, LoanPathElem)
 }
 
+impl LoanPath {
+    fn to_type(&self, tcx: &ty::ctxt) -> ty::t {
+        match *self {
+            LpUpvar(ty::UpvarId { var_id: id, closure_expr_id: _ }) |
+            LpVar(id) => ty::node_id_to_type_opt(tcx, id).unwrap(),
+
+            LpExtend(ref lp, _mc, ref loan_path_elem) => {
+                let t = lp.to_type(tcx);
+                match *loan_path_elem {
+                    LpDeref(_pointer_kind) =>
+                        // (claiming deref is explicit)
+                        ty::deref(t, true).unwrap().ty,
+                    LpInterior(mc::InteriorElement(_element_kind)) =>
+                        ty::array_element_ty(t).unwrap().ty,
+                    LpInterior(mc::InteriorField(mc::NamedField(field_name))) =>
+                        ty::named_element_ty(tcx, t, field_name).unwrap(),
+                    LpInterior(mc::InteriorField(mc::PositionalField(tuple_idx))) =>
+                        ty::positional_element_ty(tcx, t, tuple_idx).unwrap(),
+                }
+            }
+        }
+    }
+}
+
 #[deriving(PartialEq, Eq, Hash)]
 pub enum LoanPathElem {
     LpDeref(mc::PointerKind),    // `*LV` in doc.rs

commit 3818fa79ba0e0c984b6679cc1d3597c4ef1f0772
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Mon Jul 21 12:34:22 2014 +0200

    ty.rs: Add accessors for extracting types from field accesses to ty.rs.
---
 src/librustc/middle/ty.rs | 26 ++++++++++++++++++++++++++
 1 file changed, 26 insertions(+)

diff --git a/src/librustc/middle/ty.rs b/src/librustc/middle/ty.rs
index feed762..3afe9bf 100644
--- a/src/librustc/middle/ty.rs
+++ b/src/librustc/middle/ty.rs
@@ -3096,6 +3096,32 @@ pub fn array_element_ty(t: t) -> Option<t> {
     }
 }
 
+/// Returns the type of element at index `i` in tuple or tuple-like type.
+pub fn positional_element_ty(_cx: &ctxt, t: t, i: uint) -> Option<t> {
+    match get(t).sty {
+        ty_tup(ref v) => v.as_slice().get(i).map(|&t| t),
+        ty_struct(_def_id, ref _substs) => unimplemented!(),
+        ty_enum(_def_id, ref _substs) => unimplemented!(),
+        _ => None
+    }
+}
+
+/// Returns the type of element at field `n` in struct or struct-like type.
+pub fn named_element_ty(cx: &ctxt, t: t, n: ast::Name) -> Option<t> {
+    match get(t).sty {
+        ty_struct(def_id, ref _substs) => {
+            let r = lookup_struct_fields(cx, def_id);
+            r.iter().find(|f| f.name == n)
+                // FIXME probably need to pass in substs from the
+                // surrounding context, not the substs from the
+                // definition itself.
+                .map(|&f| lookup_field_type(cx, def_id, f.id, _substs))
+        }
+        ty_enum(_def_id, ref _substs) => unimplemented!(),
+        _ => None
+    }
+}
+
 pub fn node_id_to_trait_ref(cx: &ctxt, id: ast::NodeId) -> Rc<ty::TraitRef> {
     match cx.trait_refs.borrow().find(&id) {
         Some(t) => t.clone(),

commit 2735b2e623837468f3bf7491990ea0275cae63ae
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Sun Jul 27 10:37:20 2014 +0200

    more play tests in rootdir.
---
 Makefile  |  9 +++++++--
 foo10.rs  | 23 +++++++++++++++++++++++
 foo10a.rs | 17 +++++++++++++++++
 foo11.rs  | 24 ++++++++++++++++++++++++
 foo12.rs  | 24 ++++++++++++++++++++++++
 foo13.rs  | 29 +++++++++++++++++++++++++++++
 iter1.rs  | 50 ++++++++++++++++++++++++++++++++++++++++++++++++++
 7 files changed, 174 insertions(+), 2 deletions(-)

diff --git a/Makefile b/Makefile
index 8db44b8..8c8a62c 100644
--- a/Makefile
+++ b/Makefile
@@ -1,4 +1,6 @@
-FILES=foo1.rs foo2.rs foo3.rs foo4.rs foo5.rs foo6.rs foo7.rs foo8.rs
+FILES=foo1.rs foo2.rs foo3.rs foo4.rs foo5.rs foo6.rs foo7.rs foo8.rs \
+      foo11.rs foo12.rs \
+      iter1.rs
 
 all: $(patsubst %.rs,%.dot,$(FILES))
 
@@ -15,4 +17,7 @@ objdir-dbg/x86_64-apple-darwin/stage1/rustc: src/etc/rustc-wrapper.macosx.sh obj
 	chmod +x $@
 
 %.dot: %.rs Makefile objdir-dbg/x86_64-apple-darwin/stage1/rustc
-	$(RUSTC_LIB) -Z flowgraph-print-needs-drop --pretty flowgraph=foo $< -o $@
+	$(RUSTC_LIB) -Z flowgraph-print-all --pretty flowgraph=foo $< -o $@
+
+%.log: %.rs Makefile objdir-dbg/x86_64-apple-darwin/stage1/rustc
+	RUST_LOG=rustc::middle::borrowck,rustc::middle::ty,rustc::middle::typeck,rustc::middle::expr_use_visitor  $(RUSTC_LIB) -Z flowgraph-print-all --pretty flowgraph=foo $< -o $@.dot 2> $@
diff --git a/foo10.rs b/foo10.rs
new file mode 100644
index 0000000..eceaa45
--- /dev/null
+++ b/foo10.rs
@@ -0,0 +1,23 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub struct Foo<X,Y> { _x: X, _y: Y, _z: X, _w: X }
+
+pub fn foo<X,Y:Copy>(b: bool, mut s: Foo<X,Y>, f: |X| -> int) -> int {
+    //                                                          // NEEDS_DROP={s}
+    s._x = s._z; // s._x assigned here (and s._z moved here).
+    //                                                          // NEEDS_DROP={s._x, s._w}
+    if b {
+        //                                                      // NEEDS_DROP={s._x, s._w}
+        f(s._x) // Path s._x moved in this branch ...
+        //                                                      // NEEDS_DROP={s._w}
+    } else {
+        //                                                      // NEEDS_DROP={s._x, s._w}
+        3    // ... but not this one ...
+        //                                                      // NEEDS_DROP={s._x, s._w}
+    } // ... thus expect notice at this join-point.
+}
diff --git a/foo10a.rs b/foo10a.rs
new file mode 100644
index 0000000..dbd1585
--- /dev/null
+++ b/foo10a.rs
@@ -0,0 +1,17 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub struct Foo<X,Y> { _x: X, _y: Y, _z: X, _w: X }
+
+pub fn foo<X,Y:Copy>(b: bool, mut s: Foo<X,Y>, f: |X| -> int) -> int {
+    s._x = s._z; // s._x assigned here (and s._z moved here).
+    if b {
+        f(s._x) // Path s._x moved in this branch ...
+    } else {
+        3    // ... but not this one ...
+    } // ... thus expect notice at this join-point.
+}
diff --git a/foo11.rs b/foo11.rs
new file mode 100644
index 0000000..b20accf
--- /dev/null
+++ b/foo11.rs
@@ -0,0 +1,24 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub enum Foo<A,B> { Fx(A), Fy(B) }
+
+pub fn foo<X,Y>(s: Foo<X,Y>, f: |X| -> int, g: |Y| -> int) -> int {
+    //                                                          // NEEDS_DROP={s}
+    match s {
+        Fx(x) => {
+    //                                                          // NEEDS_DROP={x}
+            f(x)
+    //                                                          // NEEDS_DROP={}
+        }
+        Fy(y) => {
+    //                                                          // NEEDS_DROP={y}
+            g(y)
+    //                                                          // NEEDS_DROP={}
+        }
+    } // ... this should be fine.
+}
diff --git a/foo12.rs b/foo12.rs
new file mode 100644
index 0000000..7ba2e6f
--- /dev/null
+++ b/foo12.rs
@@ -0,0 +1,24 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub enum Foo<A,B> { Fx(A), Fy(B) }
+
+pub fn foo<X,Y:Copy>(s: Foo<X,Y>, f: |X| -> int, g: |Y| -> int) -> int {
+    //                                                          // NEEDS_DROP={s}
+    match s {
+        Fx(x) => {
+    //                                                          // NEEDS_DROP={x}
+            f(x)
+    //                                                          // NEEDS_DROP={}
+        }
+        Fy(y) => {
+    //                                                          // NEEDS_DROP={}
+            g(y)
+    //                                                          // NEEDS_DROP={}
+        }
+    } // ... this should be fine.
+}
diff --git a/foo13.rs b/foo13.rs
new file mode 100644
index 0000000..af13eb9
--- /dev/null
+++ b/foo13.rs
@@ -0,0 +1,29 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub enum Foo<A,B> { Fx(A), Fy(B) }
+
+pub fn foo<X,Y:Copy>(s: Foo<X,Y>, f: |X| -> int, f2: |&X| -> int, g: |Y| -> int) -> int {
+    //                                                          // NEEDS_DROP={s}
+    match s {
+        Fx(ref x2) if true => {
+    //                                                          // NEEDS_DROP={s}
+            f2(x2)
+    //                                                          // NEEDS_DROP={s}
+        }
+        Fx(x) => {
+    //                                                          // NEEDS_DROP={x}
+            f(x)
+    //                                                          // NEEDS_DROP={}
+        }
+        Fy(y) => {
+    //                                                          // NEEDS_DROP={}
+            g(y)
+    //                                                          // NEEDS_DROP={}
+        }
+    } // ... this should be fine.
+}
diff --git a/iter1.rs b/iter1.rs
new file mode 100644
index 0000000..206e0ad
--- /dev/null
+++ b/iter1.rs
@@ -0,0 +1,50 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub fn drop<T>(_x: T) { }
+
+pub trait GreaterThan { fn gt(&self, that: &Self) -> bool; }
+
+pub enum Option<T> {
+    /// No value
+    None,
+    /// Some value `T`
+    Some(T)
+}
+
+impl<T> Option<T> {
+    pub fn map<U>(self, f: |T| -> U) -> Option<U> {
+        match self { Some(x) => Some(f(x)), None => None }
+    }
+}
+
+pub trait Iterator<A> {
+    fn fold<B>(&mut self, init: B, f: |B, A| -> B) -> B;
+
+    #[inline]
+    // originally named `max_by`
+    fn max_by<B: GreaterThan>(&mut self, f: |&A| -> B) -> Option<A> {
+        fn foo<A,B: GreaterThan>(f: |&A| -> B,
+                                 max: Option<(A, B)>,
+                                 x: A) -> Option<(A, B)> {
+            let x_val = f(&x);
+            match max {
+                None             => Some((x, x_val)),
+                Some((y, y_val)) => if x_val.gt(&y_val) {
+                    drop((y, y_val));
+                    Some((x, x_val))
+                } else {
+                    drop((x, x_val));
+                    Some((y, y_val))
+                }
+            }
+        }
+
+        self.fold(None, |max: Option<(A, B)>, x| foo(|a|f(a), max, x))
+            .map(|(x, _)| x)
+    }
+}

commit 422dc8e597ec27f9d9db44d9712f1d27008a6c4d
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Fri Jul 18 21:13:48 2014 +0200

    root testsuite: DO NOT CHECK-IN.
    
    random tests to feed into stage1 no libs compiler.
    
    wrapper script for rustc I am reasonably happy with.  (Note that my system kept falling back on some fallback path in earlier iterations of this script that did not use eval -- I think that is a Mac OS X rpath oddity that still needs fixing.)
    
    add workspace files to the ignored things.
---
 .gitignore                      |  3 +++
 Makefile                        | 18 ++++++++++++++++++
 foo.rs                          | 13 +++++++++++++
 foo1.rs                         | 18 ++++++++++++++++++
 foo2.rs                         | 20 ++++++++++++++++++++
 foo3.rs                         | 21 +++++++++++++++++++++
 foo4.rs                         | 23 +++++++++++++++++++++++
 foo5.rs                         | 21 +++++++++++++++++++++
 foo6.rs                         | 23 +++++++++++++++++++++++
 foo7.rs                         | 22 ++++++++++++++++++++++
 foo8.rs                         | 26 ++++++++++++++++++++++++++
 foo_no_std.rs                   | 13 +++++++++++++
 src/etc/rustc-wrapper.macosx.sh |  4 ++++
 13 files changed, 225 insertions(+)

diff --git a/.gitignore b/.gitignore
index 5d5da13..6a1c426 100644
--- a/.gitignore
+++ b/.gitignore
@@ -92,3 +92,6 @@ tmp.*.rs
 version.md
 version.ml
 version.texi
+*.pot
+/*.dot
+/objdir-*
diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..8db44b8
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,18 @@
+FILES=foo1.rs foo2.rs foo3.rs foo4.rs foo5.rs foo6.rs foo7.rs foo8.rs
+
+all: $(patsubst %.rs,%.dot,$(FILES))
+
+RUSTC_LIB=$(RUSTC) --crate-type=lib
+
+RUSTC ?= objdir-dbg/x86_64-apple-darwin/stage1/rustc
+
+rwildcard=$(foreach d,$(wildcard $1*),$(call rwildcard,$d/,$2) \
+  $(filter $(subst *,%,$2),$d))
+
+objdir-dbg/x86_64-apple-darwin/stage1/rustc: src/etc/rustc-wrapper.macosx.sh objdir-dbg/x86_64-apple-darwin/stage1/bin/rustc Makefile $(call rwildcard,src/,*.rs)
+	cd objdir-dbg && make-rustc-stage1 --no-libs
+	cp $< $@
+	chmod +x $@
+
+%.dot: %.rs Makefile objdir-dbg/x86_64-apple-darwin/stage1/rustc
+	$(RUSTC_LIB) -Z flowgraph-print-needs-drop --pretty flowgraph=foo $< -o $@
diff --git a/foo.rs b/foo.rs
new file mode 100644
index 0000000..3918fbd
--- /dev/null
+++ b/foo.rs
@@ -0,0 +1,13 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="sized"] pub trait Sized { }
+
+pub fn foo<T>(b: bool, x: T, f: |T| -> int) -> int {
+    if b {
+        f(x) // Variable x moved in this branch ...
+    } else {
+        3    // ... but not this one ...
+    } // ... thus expect notice at this join-point.
+}
diff --git a/foo1.rs b/foo1.rs
new file mode 100644
index 0000000..5a4f3b0
--- /dev/null
+++ b/foo1.rs
@@ -0,0 +1,18 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="sized"] pub trait Sized { }
+
+pub fn foo<T>(b: bool, x: T, f: |T| -> int) -> int {
+    //                                                          // NEEDS_DROP={x}
+    if b {
+    //                                                          // NEEDS_DROP={x}
+        f(x) // Variable x moved in this branch ...
+    //                                                          // NEEDS_DROP={}
+    } else {
+    //                                                          // NEEDS_DROP={x}
+        3    // ... but not this one ...
+    //                                                          // NEEDS_DROP={x}
+    } // ... thus expect notice at this join-point.
+}
diff --git a/foo2.rs b/foo2.rs
new file mode 100644
index 0000000..cadd513
--- /dev/null
+++ b/foo2.rs
@@ -0,0 +1,20 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub fn foo<T:Copy>(b: bool, x: T, f: |T| -> int) -> int {
+    //                                                          // NEEDS_DROP={}
+    if b {
+    //                                                          // NEEDS_DROP={}
+        f(x) // Variable x copied in this branch ...
+    //                                                          // NEEDS_DROP={}
+    } else {
+    //                                                          // NEEDS_DROP={}
+        3    // ... but not this one ...
+    //                                                          // NEEDS_DROP={}
+    } // ... but since it is copy, needs-drop = {}.  (Copy and Drop are mutually exclusive)
+    //                                                          // NEEDS_DROP={}
+}
diff --git a/foo3.rs b/foo3.rs
new file mode 100644
index 0000000..ae08e42
--- /dev/null
+++ b/foo3.rs
@@ -0,0 +1,21 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub struct Foo<X,Y> { _x: X, _y: Y }
+
+pub fn foo<X,Y:Copy>(b: bool, s: Foo<X,Y>, f: |X| -> int, _g: |Y| -> int) -> int {
+    //                                                          // NEEDS_DROP={s}
+    if b {
+    //                                                          // NEEDS_DROP={s}
+        f(s._x) // Path s._x moved in this branch ...
+    //                                                          // NEEDS_DROP={}
+    } else {
+    //                                                          // NEEDS_DROP={s}
+        3    // ... but not this one ...
+    //                                                          // NEEDS_DROP={s}
+    } // ... thus expect notice at this join-point.
+}
diff --git a/foo4.rs b/foo4.rs
new file mode 100644
index 0000000..3848582
--- /dev/null
+++ b/foo4.rs
@@ -0,0 +1,23 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub struct Foo<X,Y> { _x: X, _y: Y, _z: X }
+
+pub fn foo<X,Y:Copy>(b: bool, mut s: Foo<X,Y>, f: |X| -> int) -> int {
+    //                                                          // NEEDS_DROP={s}
+    s._x = s._z; // s._x assigned here (and s._z moved here).
+    //                                                          // NEEDS_DROP={s._x}
+    if b {
+        //                                                      // NEEDS_DROP={s._x}
+        f(s._x) // Path s._x moved in this branch ...
+        //                                                      // NEEDS_DROP={}
+    } else {
+        //                                                      // NEEDS_DROP={s._x}
+        3    // ... but not this one ...
+        //                                                      // NEEDS_DROP={s._x}
+    } // ... thus expect notice at this join-point.
+}
diff --git a/foo5.rs b/foo5.rs
new file mode 100644
index 0000000..a998055
--- /dev/null
+++ b/foo5.rs
@@ -0,0 +1,21 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub struct Foo<X,Y> { _x: X, _y: Y, _z: X }
+
+pub fn foo<X,Y:Copy>(b: bool, s: Foo<X,Y>, f: |X| -> int) -> int {
+    //                                                          // NEEDS_DROP={s}
+    if b {
+        //                                                      // NEEDS_DROP={s}
+        f(s._x) // Path s._x moved in this branch ...
+        //                                                      // NEEDS_DROP={s._z}
+    } else {
+        //                                                      // NEEDS_DROP={s}
+        3    // ... but not this one ...
+        //                                                      // NEEDS_DROP={s}
+    } // ... thus expect notice at this join-point.
+}
diff --git a/foo6.rs b/foo6.rs
new file mode 100644
index 0000000..fdc8d2b
--- /dev/null
+++ b/foo6.rs
@@ -0,0 +1,23 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub struct Foo<X,Y> { _x: X, _y: Y, _z: X }
+
+pub fn foo<X,Y:Copy>(b: bool, mut s: Foo<X,Y>, f: |X| -> int, x: X) -> int {
+    //                                                          // NEEDS_DROP={s, x}
+    s._x = x;
+    //                                                          // NEEDS_DROP={s}
+    if b {
+        //                                                      // NEEDS_DROP={s}
+        f(s._x) // Path s._x moved in this branch ...
+        //                                                      // NEEDS_DROP={s._z}
+    } else {
+        //                                                      // NEEDS_DROP={s}
+        3    // ... but not this one ...
+        //                                                      // NEEDS_DROP={s}
+    } // ... thus expect notice at this join-point.
+}
diff --git a/foo7.rs b/foo7.rs
new file mode 100644
index 0000000..3cdd48e
--- /dev/null
+++ b/foo7.rs
@@ -0,0 +1,22 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub struct Foo<X,Y> { _x: X, _y: Y, _z: X }
+
+pub fn foo<X,Y:Copy>(b: bool, mut s: Foo<X,Y>, _f: |X| -> int, x: X) -> int {
+    //                                                          // NEEDS_DROP={s,x}
+    if b {
+        //                                                      // NEEDS_DROP={s,x}
+        s._x = x; // `x` moved in this branch
+        //                                                      // NEEDS_DROP={s}
+        4
+    } else {
+        //                                                      // NEEDS_DROP={s,x}
+        3    // ... but not this one ...
+        //                                                      // NEEDS_DROP={s,x}
+    } // ... thus expect notice at this join-point.
+}
diff --git a/foo8.rs b/foo8.rs
new file mode 100644
index 0000000..52a8a1a
--- /dev/null
+++ b/foo8.rs
@@ -0,0 +1,26 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="copy"]  pub trait Copy { }
+#[lang="sized"] pub trait Sized { }
+
+pub struct Foo<X,Y> { _x: X, _y: Y, _z: X }
+
+pub fn foo<X,Y:Copy>(b: bool, mut s: Foo<X,Y>, _f: |X| -> int, _g: || -> X) -> int {
+    //                                                          // NEEDS_DROP={s}
+    _f(s._x);
+    //                                                          // NEEDS_DROP={s._z}
+    _f(s._z);
+    //                                                          // NEEDS_DROP={}
+    // all of `s` is moved away ...
+    if b {
+        //                                                      // NEEDS_DROP={}
+        s._x = _g(); // but `s._x` is re-established in this branch
+        //                                                      // NEEDS_DROP={s._x}
+        4
+    } else {
+        //                                                      // NEEDS_DROP={}
+        3 // ... but not this one ...
+    } // ... thus expect notice at this join-point.
+}
diff --git a/foo_no_std.rs b/foo_no_std.rs
new file mode 100644
index 0000000..6dcb847
--- /dev/null
+++ b/foo_no_std.rs
@@ -0,0 +1,13 @@
+#![feature(lang_items)]
+#![no_std]
+#![crate_type="lib"]
+
+#[lang="sized"] pub trait Sized { }
+
+pub fn foo<T>(b: bool, x: T, f: |T| -> int) -> int {
+    if b {
+        f(x)
+    } else {
+        3
+    }
+}
diff --git a/src/etc/rustc-wrapper.macosx.sh b/src/etc/rustc-wrapper.macosx.sh
new file mode 100755
index 0000000..7f63eb7
--- /dev/null
+++ b/src/etc/rustc-wrapper.macosx.sh
@@ -0,0 +1,4 @@
+DIR=$(dirname $0)
+CMD="DYLD_LIBRARY_PATH=$DIR/lib:$DYLD_LIBRARY_PATH exec $DIR/bin/rustc $@"
+# echo $CMD
+eval "$CMD"

commit 2bbf5cc8e02651f76a3be4bfdc21299ca0a65eca
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Sun Jul 20 21:48:44 2014 +0200

    pretty flowgraph: added support for looking up a fn via suffix of its path (instead of node id).
    
    it can also now be used to look up methods (before it could only
    lookup fn items).  However, it still assumes that the only non-final
    path components are mod names, when I really should add types in there
    as well.
---
 src/librustc/driver/driver.rs | 115 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++---------------------------
 src/librustc/driver/mod.rs    |  40 ++++++++++++++++++++++++++++++++++++++++
 2 files changed, 128 insertions(+), 27 deletions(-)

diff --git a/src/librustc/driver/driver.rs b/src/librustc/driver/driver.rs
index 22f6848..c4dc7f6 100644
--- a/src/librustc/driver/driver.rs
+++ b/src/librustc/driver/driver.rs
@@ -30,6 +30,7 @@ use util::nodemap::{NodeSet};
 
 use serialize::{json, Encodable};
 
+use std::from_str::FromStr;
 use std::io;
 use std::io::fs;
 use arena::TypedArena;
@@ -965,6 +966,57 @@ fn gather_flowgraph_variants(sess: &Session) -> Vec<borrowck_dot::Variant> {
     variants
 }
 
+pub enum FlowGraphId {
+    FlowGraphViaNode(ast::NodeId),
+    FlowGraphViaPath(String),
+}
+
+impl FromStr for FlowGraphId {
+    fn from_str(s: &str) -> Option<FlowGraphId> {
+        let oi: Option<ast::NodeId> = FromStr::from_str(s);
+        match oi {
+            Some(i) => Some(FlowGraphViaNode(i)),
+            None => Some(FlowGraphViaPath(s.to_string())),
+        }
+    }
+}
+
+impl FlowGraphId {
+    fn to_node_id(self,
+                  tcx: &ty::ctxt) -> ast::NodeId {
+        let sess = &tcx.sess;
+        let string = match self {
+            FlowGraphViaNode(node_id) => return node_id,
+            FlowGraphViaPath(string) => string,
+        };
+
+        let fail_because = |is_wrong_because| -> ast::NodeId {
+            let message =
+                format!("pretty flowgraph= needs NodeId (int) or unique \
+                         path suffix (b::c::d); got {:s}, which {:s}",
+                        string, is_wrong_because);
+            sess.fatal(message.as_slice())
+        };
+
+        let parts : Vec<&str> = string.as_slice().split_str("::").collect();
+        let mut saw_node = ast::DUMMY_NODE_ID;
+        let mut seen = 0u;
+        for node in tcx.map.nodes_matching_suffix(parts.as_slice()) {
+            saw_node = node;
+            seen += 1;
+            if seen > 1 {
+                fail_because("does not resolve uniquely");
+            }
+        }
+        if seen == 0 {
+            fail_because("does not resolve to any item");
+        }
+
+        assert!(seen == 1);
+        return saw_node;
+    }
+}
+
 pub fn pretty_print_input(sess: Session,
                           cfg: ast::CrateConfig,
                           input: &Input,
@@ -1030,33 +1082,11 @@ pub fn pretty_print_input(sess: Session,
                                 &annotation,
                                 is_expanded)
         }
-        PpmFlowGraph(nodeid) => {
+        PpmFlowGraph(flow_graph_id) => {
+            let variants = gather_flowgraph_variants(&sess);
             let ast_map = ast_map.expect("--pretty flowgraph missing ast_map");
-            let node = ast_map.find(nodeid).unwrap_or_else(|| {
-                sess.fatal(format!("--pretty flowgraph couldn't find id: {}",
-                                   nodeid).as_slice())
-            });
-            let code = blocks::Code::from_node(node);
-            match code {
-                Some(code) => {
-                    let variants = gather_flowgraph_variants(&sess);
-                    let analysis = phase_3_run_analysis_passes(sess, &krate,
-                                                               ast_map, id);
-                    print_flowgraph(variants, analysis, code, out)
-                }
-                None => {
-                    let message = format!("--pretty=flowgraph needs \
-                                           block, fn, or method; got {:?}",
-                                          node);
-
-                    // point to what was found, if there's an
-                    // accessible span.
-                    match ast_map.opt_span(nodeid) {
-                        Some(sp) => sess.span_fatal(sp, message.as_slice()),
-                        None => sess.fatal(message.as_slice())
-                    }
-                }
-            }
+            let analysis = phase_3_run_analysis_passes(sess, &krate, ast_map, id);
+            print_flowgraph(variants, analysis, flow_graph_id, out)
         }
         _ => {
             pprust::print_crate(sess.codemap(),
@@ -1072,11 +1102,42 @@ pub fn pretty_print_input(sess: Session,
 
 }
 
+fn flow_graph_id_to_code(flow_graph_id: FlowGraphId,
+                         analysis: &CrateAnalysis) -> blocks::Code {
+    let ty_cx = &analysis.ty_cx;
+    let ast_map = &ty_cx.map;
+    let sess = &ty_cx.sess;
+
+    let nodeid = flow_graph_id.to_node_id(ty_cx);
+    let node = ast_map.find(nodeid).unwrap_or_else(|| {
+        sess.fatal(format!("--pretty flowgraph couldn't find id: {}",
+                           nodeid).as_slice())
+    });
+    let code = blocks::Code::from_node(node);
+    match code {
+        Some(code) => code,
+        None => {
+            let message = format!("--pretty=flowgraph needs \
+                                   block, fn, or method; got {:?}",
+                                  node);
+
+            // point to what was found, if there's an
+            // accessible span.
+            match ast_map.opt_span(nodeid) {
+                Some(sp) => sess.span_fatal(sp, message.as_slice()),
+                None => sess.fatal(message.as_slice())
+            }
+        }
+    }
+}
+
 fn print_flowgraph<W:io::Writer>(variants: Vec<borrowck_dot::Variant>,
                                  analysis: CrateAnalysis,
-                                 code: blocks::Code,
+                                 flow_graph_id: FlowGraphId,
                                  mut out: W) -> io::IoResult<()> {
     let ty_cx = &analysis.ty_cx;
+
+    let code = flow_graph_id_to_code(flow_graph_id, &analysis);
     let cfg = match code {
         blocks::BlockCode(block) => cfg::CFG::new(ty_cx, &*block),
         blocks::FnLikeCode(fn_like) => cfg::CFG::new(ty_cx, &*fn_like.body()),
diff --git a/src/librustc/driver/mod.rs b/src/librustc/driver/mod.rs
index 5e00b9e..cb385da 100644
--- a/src/librustc/driver/mod.rs
+++ b/src/librustc/driver/mod.rs
@@ -385,6 +385,46 @@ fn print_crate_info(sess: &Session,
     }
 }
 
+<<<<<<< HEAD
+||||||| merged common ancestors
+pub enum PpMode {
+    PpmNormal,
+    PpmExpanded,
+    PpmTyped,
+    PpmIdentified,
+    PpmExpandedIdentified,
+    PpmFlowGraph(ast::NodeId),
+}
+
+pub fn parse_pretty(sess: &Session, name: &str) -> PpMode {
+    let mut split = name.splitn('=', 1);
+    let first = split.next().unwrap();
+    let opt_second = split.next();
+    match (opt_second, first) {
+        (None, "normal")       => PpmNormal,
+        (None, "expanded")     => PpmExpanded,
+        (None, "typed")        => PpmTyped,
+        (None, "expanded,identified") => PpmExpandedIdentified,
+        (None, "identified")   => PpmIdentified,
+        (arg, "flowgraph") => {
+             match arg.and_then(from_str) {
+                 Some(id) => PpmFlowGraph(id),
+                 None => {
+                     sess.fatal(format!("`pretty flowgraph=<nodeid>` needs \
+                                         an integer <nodeid>; got {}",
+                                        arg.unwrap_or("nothing")).as_slice())
+                 }
+             }
+        }
+        _ => {
+            sess.fatal(format!(
+                "argument to `pretty` must be one of `normal`, \
+                 `expanded`, `flowgraph=<nodeid>`, `typed`, `identified`, \
+                 or `expanded,identified`; got {}", name).as_slice());
+        }
+    }
+}
+
 fn parse_crate_attrs(sess: &Session, input: &Input) ->
                      Vec<ast::Attribute> {
     let result = match *input {

commit 31e5aa0f9f3f17fbff473cac5e474d170d8876be
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Sun Jul 20 21:49:03 2014 +0200

    checkpoint some more debug instrumentation.
    
    Instrumentation and notes to self.
    
    Sketched out some initial code for tracking needs-drop fragments.
    
    Put in some more notes on how d/d{S}(P) is calculated.
---
 src/librustc/middle/borrowck/move_data.rs | 146 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 144 insertions(+), 2 deletions(-)

diff --git a/src/librustc/middle/borrowck/move_data.rs b/src/librustc/middle/borrowck/move_data.rs
index a8a2f49..99430c8 100644
--- a/src/librustc/middle/borrowck/move_data.rs
+++ b/src/librustc/middle/borrowck/move_data.rs
@@ -55,6 +55,16 @@ pub struct MoveData {
 
     /// Assignments to a variable or path, like `x = foo`, but not `x += foo`.
     pub assignee_ids: RefCell<HashSet<ast::NodeId>>,
+
+    /// During move_data construction, `fragments` tracks paths that
+    /// *might* be needs-drop leftovers.  When move_data has been
+    /// completed, `fragments` tracks paths that are *definitely*
+    /// needs-drop left-overs.
+    pub fragments: RefCell<Vec<MovePathIndex>>,
+
+    /// `nonfragments` always tracks paths that have been definitely
+    /// used directly in moves).
+    pub nonfragments: RefCell<Vec<MovePathIndex>>,
 }
 
 pub struct FlowedMoveData<'a, 'tcx: 'a> {
@@ -202,6 +212,15 @@ impl Move {
     pub fn ty(&self, tcx: &ty::ctxt) -> ty::t {
         self.ty_and_span(tcx).val0()
     }
+
+    pub fn to_string(&self, move_data: &MoveData, tcx: &ty::ctxt) -> String {
+        format!("Move{:s} path: {}, id: {}, kind: {:?} {:s}",
+                "{",
+                move_data.path_loan_path(self.path).repr(tcx),
+                self.id,
+                self.kind,
+                "}")
+    }
 }
 
 impl Assignment {
@@ -217,6 +236,13 @@ impl Assignment {
     pub fn ty(&self, tcx: &ty::ctxt) -> ty::t {
         self.ty_and_span(tcx).val0()
     }
+    pub fn to_string(&self, move_data: &MoveData, tcx: &ty::ctxt) -> String {
+        format!("Assignment{:s} path: {}, id: {} {:s}",
+                "{",
+                move_data.path_loan_path(self.path).repr(tcx),
+                self.id,
+                "}")
+    }
 }
 
 impl MoveData {
@@ -228,6 +254,8 @@ impl MoveData {
             path_assignments: RefCell::new(Vec::new()),
             var_assignments: RefCell::new(Vec::new()),
             assignee_ids: RefCell::new(HashSet::new()),
+            fragments: RefCell::new(Vec::new()),
+            nonfragments: RefCell::new(Vec::new()),
         }
     }
 
@@ -273,7 +301,7 @@ impl MoveData {
         self.path_parent(index) == InvalidMovePathIndex
     }
 
-    pub fn move_path(&self,
+    fn move_path(&self,
                      tcx: &ty::ctxt,
                      lp: Rc<LoanPath>) -> MovePathIndex {
         /*!
@@ -386,9 +414,11 @@ impl MoveData {
                id,
                kind);
 
-        let path_index = self.move_path(tcx, lp);
+        let path_index = self.move_path(tcx, lp.clone());
         let move_index = MoveIndex(self.moves.borrow().len());
 
+        self.nonfragments.borrow_mut().push(path_index);
+
         let next_move = self.path_first_move(path_index);
         self.set_path_first_move(path_index, move_index);
 
@@ -398,6 +428,8 @@ impl MoveData {
             kind: kind,
             next_move: next_move
         });
+
+        self.add_fragment_siblings(tcx, lp);
     }
 
     pub fn add_assignment(&self,
@@ -417,6 +449,8 @@ impl MoveData {
 
         let path_index = self.move_path(tcx, lp.clone());
 
+        self.nonfragments.borrow_mut().push(path_index);
+        
         match mode {
             euv::Init | euv::JustWrite => {
                 self.assignee_ids.borrow_mut().insert(assignee_id);
@@ -443,6 +477,76 @@ impl MoveData {
         }
     }
 
+    fn add_fragment_siblings(&self,
+                             tcx: &ty::ctxt,
+                             lp: Rc<LoanPath>) {
+        /*! Adds all of the precisely-tracked siblings of `lp` as
+         * potential move paths of interest. For example, if `lp`
+         * represents `s.x.j`, then adds moves paths for `s.x.i` and
+         * `s.x.k`, the siblings of `s.x.j`.
+         */
+
+        match *lp {
+            LpVar(_) | LpUpvar(_) => {} // Local variables have no siblings.
+
+            // *LV for OwnedPtr itself has no siblings, but we might need
+            // to propagate inward.  Not sure.
+            LpExtend(_, _, LpDeref(mc::OwnedPtr)) => unimplemented!(),
+
+            // *LV has no siblings
+            LpExtend(_, _, LpDeref(_)) => {}
+
+            // LV[j] is not tracked precisely
+            LpExtend(_, _, LpInterior(mc::InteriorElement(_))) => {}
+
+            // field access LV.x and tuple access LV#k are the cases
+            // we are interested in
+            LpExtend(ref parent, mc, LpInterior(mc::InteriorField(ref field_name))) => {
+                let add_new_field = |new_field_name| {
+                    let loan_path_elem = LpInterior(mc::InteriorField(new_field_name));
+                    let lp = LpExtend(parent.clone(), mc, loan_path_elem);
+                    let mp = self.move_path(tcx, Rc::new(lp));
+
+                    // Do not worry about checking for duplicates
+                    // here; if necessary we will sort and dedup after
+                    // all are added.
+                    self.fragments.borrow_mut().push(mp);
+
+                    mp
+                };
+
+                let parent_ty = parent.to_type(tcx);
+                match *field_name {
+                    mc::NamedField(ast_name) => {
+                        let parent_def_id = match ty::get(parent_ty).sty {
+                            ty::ty_struct(def_id, ref _substs) |
+                            ty::ty_enum(def_id, ref _substs) => def_id,
+                            _ => fail!("type with named fields must be struct or enum"),
+                        };
+                        let fields = ty::lookup_struct_fields(tcx, parent_def_id);
+                        for f in fields.iter().filter(|field| field.name != ast_name) {
+                            add_new_field(mc::NamedField(f.name));
+                        }
+                    }
+                    mc::PositionalField(tuple_idx) => {
+                        let tuple_len = match ty::get(parent_ty).sty {
+                            ty::ty_tup(ref v) => v.len(),
+                            ty::ty_struct(def_id, ref _substs) =>
+                                ty::lookup_struct_fields(tcx, def_id).len(),
+                            ty::ty_enum(def_id, ref _substs) =>
+                                ty::lookup_struct_fields(tcx, def_id).len(),
+                            _ => fail!("type with positional field must be tuple, struct or enum"),
+                        };
+                        for i in range(0, tuple_len) {
+                            if i == tuple_idx { continue }
+                            add_new_field(mc::PositionalField(i));
+                        }
+                    }
+                }
+            }
+        }
+    }
+
     fn add_gen_kills(&self,
                      tcx: &ty::ctxt,
                      dfcx_moves: &mut MoveDataFlow,
@@ -460,17 +564,20 @@ impl MoveData {
 
         for (i, move) in self.moves.borrow().iter().enumerate() {
             dfcx_moves.add_gen(move.id, i);
+            debug!("remove_drop_obligations move {}", move.to_string(self, tcx));
             self.remove_drop_obligation(move, dfcx_needs_drop);
         }
 
         for (i, assignment) in self.var_assignments.borrow().iter().enumerate() {
             dfcx_assign.add_gen(assignment.id, i);
             self.kill_moves(assignment.path, assignment.id, dfcx_moves);
+            debug!("add_drop_obligations var_assignment {}", assignment.to_string(self, tcx));
             self.add_drop_obligations(tcx, assignment, dfcx_needs_drop);
         }
 
         for assignment in self.path_assignments.borrow().iter() {
             self.kill_moves(assignment.path, assignment.id, dfcx_moves);
+            debug!("add_drop_obligations path_assignment {}", assignment.to_string(self, tcx));
             self.add_drop_obligations(tcx, assignment, dfcx_needs_drop);
         }
 
@@ -595,6 +702,41 @@ impl MoveData {
                                                     a: A,
                                                     dfcx_needs_drop: &mut NeedsDropDataFlow) {
         // Kill path and all of its sub-paths.
+        // Lets assume we had a pre-existing drop obligation ND = { s.a, s2 },
+        // where:
+        // ```
+        // struct S { a: A, b: B, c: C }
+        // struct A { i: I, j: J, k: K }
+        // struct J { x: X, y: Y, z: Z }
+        // and s : S (and s2 : S as well).
+        //
+        // Moving `s.a.j.x` implies that:
+        // * We no longer have a drop-obligation for s.a in its entirety: ND' := ND \ { s.a }
+        // * We now do have drop-obligations for the portions of `s.a` that were not moved:
+        //   ND' := ND + { s.a.i, s.a.k }
+        // * Likewise, we also have drop-obligations for the portions of `s.a.j` that were
+        //   not moved:
+        //   ND' := ND + { s.a.j.y, s.a.j.z }
+        //
+        // Altogether, the above modifications accumulate to:
+        // ND' := ND \ { s.a } + { s.a.i, s.a.j.y, s.a.j.z, s.a.k }
+        //
+        // To simplify constructions like the above let us define taking the derivative
+        // of a path P with respect to an appropriate subpath suffix S: d/d{S}(P)
+        //
+        // So for example, d/d{.j.x}(s.a) := { s.a.i, s.a.j.y, s.a.j.z, s.a.k }
+        //
+        // TODO: Write definition of d/d{S}(P), presumably by induction on suffix S.
+        //
+        // For d/d{.j.x}(s.a), S = .j.x and P = s.a:
+        //
+        // 1. P_0 = s.a      : remove obligation s.a, if present
+        //
+        // 2. P_1 = s.a.j    : assert obligation s.a.j not present; add
+        //                     all needs-drop fields of s.a, then remove s.a.j.
+        // 3. P_2 = s.a.j.x  : assert obligation s.a.j.x not present; add
+        //                     all needs-drop fields of s.a.j, then remove s.a.j.x.
+
         let id = a.node_id_removing_obligation();
         let path = a.path_being_moved();
         dfcx_needs_drop.add_kill(id, path.get());

commit 87d69fbb3a02ff0475fb9881f82da1c599af3bb9
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Thu Jul 17 19:32:53 2014 +0200

    checkpoint prelim needs drop analysis.
---
 src/librustc/driver/config.rs              |   3 +
 src/librustc/driver/driver.rs              | 522 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 src/librustc/driver/pretty.rs              |   4 +
 src/librustc/middle/borrowck/graphviz.rs   |  24 ++++--
 src/librustc/middle/borrowck/mod.rs        |  30 ++-----
 src/librustc/middle/borrowck/move_data.rs  | 154 +++++++++++++++++++++++++++++++--
 src/librustc/middle/borrowck/needs_drop.rs | 169 ++++++++++++++++++++++++++++++++++++
 7 files changed, 870 insertions(+), 36 deletions(-)

diff --git a/src/librustc/driver/config.rs b/src/librustc/driver/config.rs
index 8f4f54c..32751a7 100644
--- a/src/librustc/driver/config.rs
+++ b/src/librustc/driver/config.rs
@@ -188,6 +188,7 @@ debugging_opts!(
         FLOWGRAPH_PRINT_LOANS,
         FLOWGRAPH_PRINT_MOVES,
         FLOWGRAPH_PRINT_ASSIGNS,
+        FLOWGRAPH_PRINT_NEEDS_DROP,
         FLOWGRAPH_PRINT_ALL
     ]
     0
@@ -231,6 +232,8 @@ pub fn debugging_opts_map() -> Vec<(&'static str, &'static str, u64)> {
                        --pretty flowgraph output", FLOWGRAPH_PRINT_MOVES),
      ("flowgraph-print-assigns", "Include assignment analysis data in \
                        --pretty flowgraph output", FLOWGRAPH_PRINT_ASSIGNS),
+     ("flowgraph-print-needs-drop", "Include needs-drop analysis data in \
+                       --pretty flowgraph output", FLOWGRAPH_PRINT_NEEDS_DROP),
      ("flowgraph-print-all", "Include all dataflow analysis data in \
                        --pretty flowgraph output", FLOWGRAPH_PRINT_ALL))
 }
diff --git a/src/librustc/driver/driver.rs b/src/librustc/driver/driver.rs
index 4c71c2d..22f6848 100644
--- a/src/librustc/driver/driver.rs
+++ b/src/librustc/driver/driver.rs
@@ -613,6 +613,528 @@ fn write_out_deps(sess: &Session,
     }
 }
 
+<<<<<<< HEAD
+||||||| merged common ancestors
+struct IdentifiedAnnotation;
+
+impl pprust::PpAnn for IdentifiedAnnotation {
+    fn pre(&self,
+           s: &mut pprust::State,
+           node: pprust::AnnNode) -> io::IoResult<()> {
+        match node {
+            pprust::NodeExpr(_) => s.popen(),
+            _ => Ok(())
+        }
+    }
+    fn post(&self,
+            s: &mut pprust::State,
+            node: pprust::AnnNode) -> io::IoResult<()> {
+        match node {
+            pprust::NodeItem(item) => {
+                try!(pp::space(&mut s.s));
+                s.synth_comment(item.id.to_string())
+            }
+            pprust::NodeBlock(blk) => {
+                try!(pp::space(&mut s.s));
+                s.synth_comment(format!("block {}", blk.id))
+            }
+            pprust::NodeExpr(expr) => {
+                try!(pp::space(&mut s.s));
+                try!(s.synth_comment(expr.id.to_string()));
+                s.pclose()
+            }
+            pprust::NodePat(pat) => {
+                try!(pp::space(&mut s.s));
+                s.synth_comment(format!("pat {}", pat.id))
+            }
+        }
+    }
+}
+
+struct TypedAnnotation {
+    analysis: CrateAnalysis,
+}
+
+impl pprust::PpAnn for TypedAnnotation {
+    fn pre(&self,
+           s: &mut pprust::State,
+           node: pprust::AnnNode) -> io::IoResult<()> {
+        match node {
+            pprust::NodeExpr(_) => s.popen(),
+            _ => Ok(())
+        }
+    }
+    fn post(&self,
+            s: &mut pprust::State,
+            node: pprust::AnnNode) -> io::IoResult<()> {
+        let tcx = &self.analysis.ty_cx;
+        match node {
+            pprust::NodeExpr(expr) => {
+                try!(pp::space(&mut s.s));
+                try!(pp::word(&mut s.s, "as"));
+                try!(pp::space(&mut s.s));
+                try!(pp::word(&mut s.s,
+                              ppaux::ty_to_string(
+                                  tcx,
+                                  ty::expr_ty(tcx, expr)).as_slice()));
+                s.pclose()
+            }
+            _ => Ok(())
+        }
+    }
+}
+
+fn gather_flowgraph_variants(sess: &Session) -> Vec<borrowck_dot::Variant> {
+    let print_loans   = config::FLOWGRAPH_PRINT_LOANS;
+    let print_moves   = config::FLOWGRAPH_PRINT_MOVES;
+    let print_assigns = config::FLOWGRAPH_PRINT_ASSIGNS;
+    let print_all     = config::FLOWGRAPH_PRINT_ALL;
+    let opt = |print_which| sess.debugging_opt(print_which);
+    let mut variants = Vec::new();
+    if opt(print_all) || opt(print_loans) {
+        variants.push(borrowck_dot::Loans);
+    }
+    if opt(print_all) || opt(print_moves) {
+        variants.push(borrowck_dot::Moves);
+    }
+    if opt(print_all) || opt(print_assigns) {
+        variants.push(borrowck_dot::Assigns);
+    }
+    variants
+}
+
+pub fn pretty_print_input(sess: Session,
+                          cfg: ast::CrateConfig,
+                          input: &Input,
+                          ppm: PpMode,
+                          ofile: Option<Path>) {
+    let krate = phase_1_parse_input(&sess, cfg, input);
+    let id = link::find_crate_name(Some(&sess), krate.attrs.as_slice(), input);
+
+    let (krate, ast_map, is_expanded) = match ppm {
+        PpmExpanded | PpmExpandedIdentified | PpmTyped | PpmFlowGraph(_) => {
+            let (krate, ast_map)
+                = match phase_2_configure_and_expand(&sess, krate,
+                                                     id.as_slice(), None) {
+                    None => return,
+                    Some(p) => p,
+                };
+            (krate, Some(ast_map), true)
+        }
+        _ => (krate, None, false)
+    };
+
+    let src_name = source_name(input);
+    let src = Vec::from_slice(sess.codemap()
+                                  .get_filemap(src_name.as_slice())
+                                  .src
+                                  .as_bytes());
+    let mut rdr = MemReader::new(src);
+
+    let out = match ofile {
+        None => box io::stdout() as Box<Writer>,
+        Some(p) => {
+            let r = io::File::create(&p);
+            match r {
+                Ok(w) => box w as Box<Writer>,
+                Err(e) => fail!("print-print failed to open {} due to {}",
+                                p.display(), e),
+            }
+        }
+    };
+    match ppm {
+        PpmIdentified | PpmExpandedIdentified => {
+            pprust::print_crate(sess.codemap(),
+                                sess.diagnostic(),
+                                &krate,
+                                src_name.to_string(),
+                                &mut rdr,
+                                out,
+                                &IdentifiedAnnotation,
+                                is_expanded)
+        }
+        PpmTyped => {
+            let ast_map = ast_map.expect("--pretty=typed missing ast_map");
+            let analysis = phase_3_run_analysis_passes(sess, &krate, ast_map, id);
+            let annotation = TypedAnnotation {
+                analysis: analysis
+            };
+            pprust::print_crate(annotation.analysis.ty_cx.sess.codemap(),
+                                annotation.analysis.ty_cx.sess.diagnostic(),
+                                &krate,
+                                src_name.to_string(),
+                                &mut rdr,
+                                out,
+                                &annotation,
+                                is_expanded)
+        }
+        PpmFlowGraph(nodeid) => {
+            let ast_map = ast_map.expect("--pretty flowgraph missing ast_map");
+            let node = ast_map.find(nodeid).unwrap_or_else(|| {
+                sess.fatal(format!("--pretty flowgraph couldn't find id: {}",
+                                   nodeid).as_slice())
+            });
+            let code = blocks::Code::from_node(node);
+            match code {
+                Some(code) => {
+                    let variants = gather_flowgraph_variants(&sess);
+                    let analysis = phase_3_run_analysis_passes(sess, &krate,
+                                                               ast_map, id);
+                    print_flowgraph(variants, analysis, code, out)
+                }
+                None => {
+                    let message = format!("--pretty=flowgraph needs \
+                                           block, fn, or method; got {:?}",
+                                          node);
+
+                    // point to what was found, if there's an
+                    // accessible span.
+                    match ast_map.opt_span(nodeid) {
+                        Some(sp) => sess.span_fatal(sp, message.as_slice()),
+                        None => sess.fatal(message.as_slice())
+                    }
+                }
+            }
+        }
+        _ => {
+            pprust::print_crate(sess.codemap(),
+                                sess.diagnostic(),
+                                &krate,
+                                src_name.to_string(),
+                                &mut rdr,
+                                out,
+                                &pprust::NoAnn,
+                                is_expanded)
+        }
+    }.unwrap()
+
+}
+
+fn print_flowgraph<W:io::Writer>(variants: Vec<borrowck_dot::Variant>,
+                                 analysis: CrateAnalysis,
+                                 code: blocks::Code,
+                                 mut out: W) -> io::IoResult<()> {
+    let ty_cx = &analysis.ty_cx;
+    let cfg = match code {
+        blocks::BlockCode(block) => cfg::CFG::new(ty_cx, &*block),
+        blocks::FnLikeCode(fn_like) => cfg::CFG::new(ty_cx, &*fn_like.body()),
+    };
+    debug!("cfg: {:?}", cfg);
+
+    match code {
+        _ if variants.len() == 0 => {
+            let lcfg = LabelledCFG {
+                ast_map: &ty_cx.map,
+                cfg: &cfg,
+                name: format!("node_{}", code.id()),
+            };
+            let r = dot::render(&lcfg, &mut out);
+            return expand_err_details(r);
+        }
+        blocks::BlockCode(_) => {
+            ty_cx.sess.err("--pretty flowgraph with -Z flowgraph-print \
+                            annotations requires fn-like node id.");
+            return Ok(())
+        }
+        blocks::FnLikeCode(fn_like) => {
+            let fn_parts = FnPartsWithCFG::from_fn_like(&fn_like, &cfg);
+            let (bccx, analysis_data) =
+                borrowck::build_borrowck_dataflow_data_for_fn(ty_cx, fn_parts);
+
+            let lcfg = LabelledCFG {
+                ast_map: &ty_cx.map,
+                cfg: &cfg,
+                name: format!("node_{}", code.id()),
+            };
+            let lcfg = borrowck_dot::DataflowLabeller {
+                inner: lcfg,
+                variants: variants,
+                borrowck_ctxt: &bccx,
+                analysis_data: &analysis_data,
+            };
+            let r = dot::render(&lcfg, &mut out);
+            return expand_err_details(r);
+        }
+    }
+
+    fn expand_err_details(r: io::IoResult<()>) -> io::IoResult<()> {
+        r.map_err(|ioerr| {
+            let orig_detail = ioerr.detail.clone();
+            let m = "graphviz::render failed";
+            io::IoError {
+                detail: Some(match orig_detail {
+                    None => m.into_string(),
+                    Some(d) => format!("{}: {}", m, d)
+                }),
+                ..ioerr
+            }
+        })
+    }
+}
+
+=======
+struct IdentifiedAnnotation;
+
+impl pprust::PpAnn for IdentifiedAnnotation {
+    fn pre(&self,
+           s: &mut pprust::State,
+           node: pprust::AnnNode) -> io::IoResult<()> {
+        match node {
+            pprust::NodeExpr(_) => s.popen(),
+            _ => Ok(())
+        }
+    }
+    fn post(&self,
+            s: &mut pprust::State,
+            node: pprust::AnnNode) -> io::IoResult<()> {
+        match node {
+            pprust::NodeItem(item) => {
+                try!(pp::space(&mut s.s));
+                s.synth_comment(item.id.to_string())
+            }
+            pprust::NodeBlock(blk) => {
+                try!(pp::space(&mut s.s));
+                s.synth_comment(format!("block {}", blk.id))
+            }
+            pprust::NodeExpr(expr) => {
+                try!(pp::space(&mut s.s));
+                try!(s.synth_comment(expr.id.to_string()));
+                s.pclose()
+            }
+            pprust::NodePat(pat) => {
+                try!(pp::space(&mut s.s));
+                s.synth_comment(format!("pat {}", pat.id))
+            }
+        }
+    }
+}
+
+struct TypedAnnotation {
+    analysis: CrateAnalysis,
+}
+
+impl pprust::PpAnn for TypedAnnotation {
+    fn pre(&self,
+           s: &mut pprust::State,
+           node: pprust::AnnNode) -> io::IoResult<()> {
+        match node {
+            pprust::NodeExpr(_) => s.popen(),
+            _ => Ok(())
+        }
+    }
+    fn post(&self,
+            s: &mut pprust::State,
+            node: pprust::AnnNode) -> io::IoResult<()> {
+        let tcx = &self.analysis.ty_cx;
+        match node {
+            pprust::NodeExpr(expr) => {
+                try!(pp::space(&mut s.s));
+                try!(pp::word(&mut s.s, "as"));
+                try!(pp::space(&mut s.s));
+                try!(pp::word(&mut s.s,
+                              ppaux::ty_to_string(
+                                  tcx,
+                                  ty::expr_ty(tcx, expr)).as_slice()));
+                s.pclose()
+            }
+            _ => Ok(())
+        }
+    }
+}
+
+fn gather_flowgraph_variants(sess: &Session) -> Vec<borrowck_dot::Variant> {
+    let print_loans      = config::FLOWGRAPH_PRINT_LOANS;
+    let print_moves      = config::FLOWGRAPH_PRINT_MOVES;
+    let print_assigns    = config::FLOWGRAPH_PRINT_ASSIGNS;
+    let print_needs_drop = config::FLOWGRAPH_PRINT_NEEDS_DROP;
+    let print_all        = config::FLOWGRAPH_PRINT_ALL;
+    let opt = |print_which| sess.debugging_opt(print_which);
+    let mut variants = Vec::new();
+    if opt(print_all) || opt(print_loans) {
+        variants.push(borrowck_dot::Loans);
+    }
+    if opt(print_all) || opt(print_moves) {
+        variants.push(borrowck_dot::Moves);
+    }
+    if opt(print_all) || opt(print_assigns) {
+        variants.push(borrowck_dot::Assigns);
+    }
+    if opt(print_all) || opt(print_needs_drop) {
+        variants.push(borrowck_dot::NeedsDrop);
+    }
+    variants
+}
+
+pub fn pretty_print_input(sess: Session,
+                          cfg: ast::CrateConfig,
+                          input: &Input,
+                          ppm: PpMode,
+                          ofile: Option<Path>) {
+    let krate = phase_1_parse_input(&sess, cfg, input);
+    let id = link::find_crate_name(Some(&sess), krate.attrs.as_slice(), input);
+
+    let (krate, ast_map, is_expanded) = match ppm {
+        PpmExpanded | PpmExpandedIdentified | PpmTyped | PpmFlowGraph(_) => {
+            let (krate, ast_map)
+                = match phase_2_configure_and_expand(&sess, krate,
+                                                     id.as_slice(), None) {
+                    None => return,
+                    Some(p) => p,
+                };
+            (krate, Some(ast_map), true)
+        }
+        _ => (krate, None, false)
+    };
+
+    let src_name = source_name(input);
+    let src = Vec::from_slice(sess.codemap()
+                                  .get_filemap(src_name.as_slice())
+                                  .src
+                                  .as_bytes());
+    let mut rdr = MemReader::new(src);
+
+    let out = match ofile {
+        None => box io::stdout() as Box<Writer>,
+        Some(p) => {
+            let r = io::File::create(&p);
+            match r {
+                Ok(w) => box w as Box<Writer>,
+                Err(e) => fail!("print-print failed to open {} due to {}",
+                                p.display(), e),
+            }
+        }
+    };
+    match ppm {
+        PpmIdentified | PpmExpandedIdentified => {
+            pprust::print_crate(sess.codemap(),
+                                sess.diagnostic(),
+                                &krate,
+                                src_name.to_string(),
+                                &mut rdr,
+                                out,
+                                &IdentifiedAnnotation,
+                                is_expanded)
+        }
+        PpmTyped => {
+            let ast_map = ast_map.expect("--pretty=typed missing ast_map");
+            let analysis = phase_3_run_analysis_passes(sess, &krate, ast_map, id);
+            let annotation = TypedAnnotation {
+                analysis: analysis
+            };
+            pprust::print_crate(annotation.analysis.ty_cx.sess.codemap(),
+                                annotation.analysis.ty_cx.sess.diagnostic(),
+                                &krate,
+                                src_name.to_string(),
+                                &mut rdr,
+                                out,
+                                &annotation,
+                                is_expanded)
+        }
+        PpmFlowGraph(nodeid) => {
+            let ast_map = ast_map.expect("--pretty flowgraph missing ast_map");
+            let node = ast_map.find(nodeid).unwrap_or_else(|| {
+                sess.fatal(format!("--pretty flowgraph couldn't find id: {}",
+                                   nodeid).as_slice())
+            });
+            let code = blocks::Code::from_node(node);
+            match code {
+                Some(code) => {
+                    let variants = gather_flowgraph_variants(&sess);
+                    let analysis = phase_3_run_analysis_passes(sess, &krate,
+                                                               ast_map, id);
+                    print_flowgraph(variants, analysis, code, out)
+                }
+                None => {
+                    let message = format!("--pretty=flowgraph needs \
+                                           block, fn, or method; got {:?}",
+                                          node);
+
+                    // point to what was found, if there's an
+                    // accessible span.
+                    match ast_map.opt_span(nodeid) {
+                        Some(sp) => sess.span_fatal(sp, message.as_slice()),
+                        None => sess.fatal(message.as_slice())
+                    }
+                }
+            }
+        }
+        _ => {
+            pprust::print_crate(sess.codemap(),
+                                sess.diagnostic(),
+                                &krate,
+                                src_name.to_string(),
+                                &mut rdr,
+                                out,
+                                &pprust::NoAnn,
+                                is_expanded)
+        }
+    }.unwrap()
+
+}
+
+fn print_flowgraph<W:io::Writer>(variants: Vec<borrowck_dot::Variant>,
+                                 analysis: CrateAnalysis,
+                                 code: blocks::Code,
+                                 mut out: W) -> io::IoResult<()> {
+    let ty_cx = &analysis.ty_cx;
+    let cfg = match code {
+        blocks::BlockCode(block) => cfg::CFG::new(ty_cx, &*block),
+        blocks::FnLikeCode(fn_like) => cfg::CFG::new(ty_cx, &*fn_like.body()),
+    };
+    debug!("cfg: {:?}", cfg);
+
+    match code {
+        _ if variants.len() == 0 => {
+            let lcfg = LabelledCFG {
+                ast_map: &ty_cx.map,
+                cfg: &cfg,
+                name: format!("node_{}", code.id()),
+            };
+            let r = dot::render(&lcfg, &mut out);
+            return expand_err_details(r);
+        }
+        blocks::BlockCode(_) => {
+            ty_cx.sess.err("--pretty flowgraph with -Z flowgraph-print \
+                            annotations requires fn-like node id.");
+            return Ok(())
+        }
+        blocks::FnLikeCode(fn_like) => {
+            let fn_parts = FnPartsWithCFG::from_fn_like(&fn_like, &cfg);
+            let (bccx, analysis_data) =
+                borrowck::build_borrowck_dataflow_data_for_fn(ty_cx, fn_parts);
+
+            let lcfg = LabelledCFG {
+                ast_map: &ty_cx.map,
+                cfg: &cfg,
+                name: format!("node_{}", code.id()),
+            };
+            let lcfg = borrowck_dot::DataflowLabeller {
+                inner: lcfg,
+                variants: variants,
+                borrowck_ctxt: &bccx,
+                analysis_data: &analysis_data,
+            };
+            let r = dot::render(&lcfg, &mut out);
+            return expand_err_details(r);
+        }
+    }
+
+    fn expand_err_details(r: io::IoResult<()>) -> io::IoResult<()> {
+        r.map_err(|ioerr| {
+            let orig_detail = ioerr.detail.clone();
+            let m = "graphviz::render failed";
+            io::IoError {
+                detail: Some(match orig_detail {
+                    None => m.into_string(),
+                    Some(d) => format!("{}: {}", m, d)
+                }),
+                ..ioerr
+            }
+        })
+    }
+}
+
+>>>>>>> checkpoint prelim needs drop analysis.
 pub fn collect_crate_types(session: &Session,
                            attrs: &[ast::Attribute]) -> Vec<config::CrateType> {
     // Unconditionally collect crate types from attributes to make them used
diff --git a/src/librustc/driver/pretty.rs b/src/librustc/driver/pretty.rs
index a3227e4..8400650 100644
--- a/src/librustc/driver/pretty.rs
+++ b/src/librustc/driver/pretty.rs
@@ -313,6 +313,7 @@ fn gather_flowgraph_variants(sess: &Session) -> Vec<borrowck_dot::Variant> {
     let print_loans   = config::FLOWGRAPH_PRINT_LOANS;
     let print_moves   = config::FLOWGRAPH_PRINT_MOVES;
     let print_assigns = config::FLOWGRAPH_PRINT_ASSIGNS;
+    let print_needs_drop = config::FLOWGRAPH_PRINT_NEEDS_DROP;
     let print_all     = config::FLOWGRAPH_PRINT_ALL;
     let opt = |print_which| sess.debugging_opt(print_which);
     let mut variants = Vec::new();
@@ -325,6 +326,9 @@ fn gather_flowgraph_variants(sess: &Session) -> Vec<borrowck_dot::Variant> {
     if opt(print_all) || opt(print_assigns) {
         variants.push(borrowck_dot::Assigns);
     }
+    if opt(print_all) || opt(print_needs_drop) {
+        variants.push(borrowck_dot::NeedsDrop);
+    }
     variants
 }
 
diff --git a/src/librustc/middle/borrowck/graphviz.rs b/src/librustc/middle/borrowck/graphviz.rs
index e75378d..48a3c5f 100644
--- a/src/librustc/middle/borrowck/graphviz.rs
+++ b/src/librustc/middle/borrowck/graphviz.rs
@@ -31,14 +31,16 @@ pub enum Variant {
     Loans,
     Moves,
     Assigns,
+    NeedsDrop,
 }
 
 impl Variant {
     pub fn short_name(&self) -> &'static str {
         match *self {
-            Loans   => "loans",
-            Moves   => "moves",
-            Assigns => "assigns",
+            Loans     => "loans",
+            Moves     => "moves",
+            Assigns   => "assigns",
+            NeedsDrop => "needs_drop",
         }
     }
 }
@@ -68,9 +70,10 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {
     fn dataflow_for_variant(&self, e: EntryOrExit, n: &Node, v: Variant) -> String {
         let cfgidx = n.val0();
         match v {
-            Loans   => self.dataflow_loans_for(e, cfgidx),
-            Moves   => self.dataflow_moves_for(e, cfgidx),
-            Assigns => self.dataflow_assigns_for(e, cfgidx),
+            Loans     => self.dataflow_loans_for(e, cfgidx),
+            Moves     => self.dataflow_moves_for(e, cfgidx),
+            Assigns   => self.dataflow_assigns_for(e, cfgidx),
+            NeedsDrop => self.dataflow_needs_drop_for(e, cfgidx),
         }
     }
 
@@ -124,6 +127,15 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {
         };
         self.build_set(e, cfgidx, dfcx, assign_index_to_path)
     }
+
+    fn dataflow_needs_drop_for(&self, e: EntryOrExit, cfgidx: CFGIndex) -> String {
+        let dfcx = &self.analysis_data.move_data.dfcx_needs_drop;
+        let needs_drop_index_to_path = |needs_drop_index| {
+            let move_data = &self.analysis_data.move_data.move_data;
+            move_data.path_loan_path(borrowck::move_data::MovePathIndex(needs_drop_index))
+        };
+        self.build_set(e, cfgidx, dfcx, needs_drop_index_to_path)
+    }
 }
 
 impl<'a, 'tcx> dot::Labeller<'a, Node<'a>, Edge<'a>> for DataflowLabeller<'a, 'tcx> {
diff --git a/src/librustc/middle/borrowck/mod.rs b/src/librustc/middle/borrowck/mod.rs
index f4d3678..1cbed9a 100644
--- a/src/librustc/middle/borrowck/mod.rs
+++ b/src/librustc/middle/borrowck/mod.rs
@@ -55,6 +55,8 @@ pub mod graphviz;
 
 pub mod move_data;
 
+// pub mod needs_drop;
+
 #[deriving(Clone)]
 pub struct LoanDataFlowOperator;
 
@@ -531,17 +533,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {
             move_data::Declared => {}
 
             move_data::MoveExpr => {
-                let (expr_ty, expr_span) = match self.tcx.map.find(move.id) {
-                    Some(ast_map::NodeExpr(expr)) => {
-                        (ty::expr_ty_adjusted(self.tcx, &*expr), expr.span)
-                    }
-                    r => {
-                        self.tcx.sess.bug(format!("MoveExpr({:?}) maps to \
-                                                   {:?}, not Expr",
-                                                  move.id,
-                                                  r).as_slice())
-                    }
-                };
+                let (expr_ty, expr_span) = move.ty_and_span(self.tcx);
                 let suggestion = move_suggestion(self.tcx, expr_ty,
                         "moved by default (use `copy` to override)");
                 self.tcx.sess.span_note(
@@ -553,8 +545,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {
             }
 
             move_data::MovePat => {
-                let pat_ty = ty::node_id_to_type(self.tcx, move.id);
-                self.tcx.sess.span_note(self.tcx.map.span(move.id),
+                let (pat_ty, pat_span) = move.ty_and_span(self.tcx);
+                self.tcx.sess.span_note(pat_span,
                     format!("`{}` moved here because it has type `{}`, \
                              which is moved by default (use `ref` to \
                              override)",
@@ -563,17 +555,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {
             }
 
             move_data::Captured => {
-                let (expr_ty, expr_span) = match self.tcx.map.find(move.id) {
-                    Some(ast_map::NodeExpr(expr)) => {
-                        (ty::expr_ty_adjusted(self.tcx, &*expr), expr.span)
-                    }
-                    r => {
-                        self.tcx.sess.bug(format!("Captured({:?}) maps to \
-                                                   {:?}, not Expr",
-                                                  move.id,
-                                                  r).as_slice())
-                    }
-                };
+                let (expr_ty, expr_span) = move.ty_and_span(self.tcx);
                 let suggestion = move_suggestion(self.tcx, expr_ty,
                         "moved by default (make a copy and \
                          capture that instead to override)");
diff --git a/src/librustc/middle/borrowck/move_data.rs b/src/librustc/middle/borrowck/move_data.rs
index fdd16c8..a8a2f49 100644
--- a/src/librustc/middle/borrowck/move_data.rs
+++ b/src/librustc/middle/borrowck/move_data.rs
@@ -28,6 +28,7 @@ use middle::expr_use_visitor as euv;
 use middle::mem_categorization as mc;
 use middle::ty;
 use syntax::ast;
+use syntax::ast_map;
 use syntax::ast_util;
 use syntax::codemap::Span;
 use util::ppaux::Repr;
@@ -65,11 +66,14 @@ pub struct FlowedMoveData<'a, 'tcx: 'a> {
     // and assign data flow into one, but this way it's easier to
     // distinguish the bits that correspond to moves and assignments.
     pub dfcx_assign: AssignDataFlow<'a, 'tcx>
+
+    pub dfcx_needs_drop: NeedsDropDataFlow<'a, 'tcx>,
 }
 
 /// Index into `MoveData.paths`, used like a pointer
 #[deriving(PartialEq)]
-pub struct MovePathIndex(uint);
+// FIXME: should not be `pub`. Revise dataflow to support abstractions like this.
+pub struct MovePathIndex(pub uint);
 
 impl MovePathIndex {
     fn get(&self) -> uint {
@@ -161,6 +165,10 @@ pub struct AssignDataFlowOperator;
 
 pub type AssignDataFlow<'a, 'tcx> = DataFlowContext<'a, 'tcx, AssignDataFlowOperator>;
 
+#[deriving(Clone)]
+pub struct NeedsDropDataFlowOperator;
+pub type NeedsDropDataFlow<'a> = DataFlowContext<'a, NeedsDropDataFlowOperator>;
+
 fn loan_path_is_precise(loan_path: &LoanPath) -> bool {
     match *loan_path {
         LpVar(_) | LpUpvar(_) => {
@@ -177,6 +185,40 @@ fn loan_path_is_precise(loan_path: &LoanPath) -> bool {
     }
 }
 
+impl Move {
+    pub fn ty_and_span(&self, tcx: &ty::ctxt) -> (ty::t, Span) {
+        match self.kind {
+            Declared  => unimplemented!(),
+            MovePat => (ty::node_id_to_type(tcx, self.id), tcx.map.span(self.id)),
+            MoveExpr | Captured => match tcx.map.find(self.id) {
+                Some(ast_map::NodeExpr(expr)) =>
+                    (ty::expr_ty_adjusted(tcx, &*expr), expr.span),
+                r => tcx.sess.bug(format!("{:?}({:?}) maps to {:?}, not Expr",
+                                          self.kind, self.id, r).as_slice())
+            },
+        }
+    }
+
+    pub fn ty(&self, tcx: &ty::ctxt) -> ty::t {
+        self.ty_and_span(tcx).val0()
+    }
+}
+
+impl Assignment {
+    pub fn ty_and_span(&self, tcx: &ty::ctxt) -> (ty::t, Span) {
+        match tcx.map.find(self.id) {
+            Some(ast_map::NodeExpr(expr)) =>
+                (ty::expr_ty_adjusted(tcx, &*expr), expr.span),
+            Some(ast_map::NodeLocal(pat)) =>
+                (ty::node_id_to_type(tcx, pat.id), tcx.map.span(pat.id)),
+            r => tcx.sess.bug(format!("{:?} maps to {:?}, not Expr", self, r).as_slice())
+        }
+    }
+    pub fn ty(&self, tcx: &ty::ctxt) -> ty::t {
+        self.ty_and_span(tcx).val0()
+    }
+}
+
 impl MoveData {
     pub fn new() -> MoveData {
         MoveData {
@@ -404,41 +446,51 @@ impl MoveData {
     fn add_gen_kills(&self,
                      tcx: &ty::ctxt,
                      dfcx_moves: &mut MoveDataFlow,
-                     dfcx_assign: &mut AssignDataFlow) {
+                     dfcx_assign: &mut AssignDataFlow,
+                     dfcx_needs_drop: &mut NeedsDropDataFlow) {
         /*!
          * Adds the gen/kills for the various moves and
          * assignments into the provided data flow contexts.
          * Moves are generated by moves and killed by assignments and
          * scoping. Assignments are generated by assignment to variables and
-         * killed by scoping. See `doc.rs` for more details.
+         * killed by scoping.  Drop obligations (aka "Needs-Drop") are
+         * generated by assignments and killed by moves and scoping. by
+         * See `doc.rs` for more details.
          */
 
         for (i, move) in self.moves.borrow().iter().enumerate() {
             dfcx_moves.add_gen(move.id, i);
+            self.remove_drop_obligation(move, dfcx_needs_drop);
         }
 
         for (i, assignment) in self.var_assignments.borrow().iter().enumerate() {
             dfcx_assign.add_gen(assignment.id, i);
             self.kill_moves(assignment.path, assignment.id, dfcx_moves);
+            self.add_drop_obligations(tcx, assignment, dfcx_needs_drop);
         }
 
         for assignment in self.path_assignments.borrow().iter() {
             self.kill_moves(assignment.path, assignment.id, dfcx_moves);
+            self.add_drop_obligations(tcx, assignment, dfcx_needs_drop);
         }
 
-        // Kill all moves related to a variable `x` when it goes out
-        // of scope:
+        // Kill all moves and drop-obligations related to a variable `x` when
+        // it goes out of scope:
         for path in self.paths.borrow().iter() {
             match *path.loan_path {
                 LpVar(id) => {
                     let kill_id = tcx.region_maps.var_scope(id);
                     let path = *self.path_map.borrow().get(&path.loan_path);
                     self.kill_moves(path, kill_id, dfcx_moves);
+                    self.remove_drop_obligation(
+                        Removed { where: kill_id, what_path: path }, dfcx_needs_drop);
                 }
                 LpUpvar(ty::UpvarId { var_id: _, closure_expr_id }) => {
                     let kill_id = closure_to_block(closure_expr_id, tcx);
                     let path = *self.path_map.borrow().get(&path.loan_path);
                     self.kill_moves(path, kill_id, dfcx_moves);
+                    self.remove_drop_obligation(
+                        Removed { where: kill_id, what_path: path }, dfcx_needs_drop);
                 }
                 LpExtend(..) => {}
             }
@@ -529,6 +581,38 @@ impl MoveData {
             });
         }
     }
+
+    fn add_drop_obligations(&self,
+                            tcx: &ty::ctxt,
+                            assignment: &Assignment,
+                            dfcx_needs_drop: &mut NeedsDropDataFlow) {
+        if ty::type_needs_drop(tcx, assignment.ty(tcx)) {
+            dfcx_needs_drop.add_gen(assignment.id, assignment.path.get());
+        }
+    }
+
+    fn remove_drop_obligation<A:RemoveNeedsDropArg>(&self,
+                                                    a: A,
+                                                    dfcx_needs_drop: &mut NeedsDropDataFlow) {
+        // Kill path and all of its sub-paths.
+        let id = a.node_id_removing_obligation();
+        let path = a.path_being_moved();
+        dfcx_needs_drop.add_kill(id, path.get());
+    }
+}
+
+trait RemoveNeedsDropArg {
+    fn node_id_removing_obligation(&self) -> ast::NodeId;
+    fn path_being_moved(&self) -> MovePathIndex;
+}
+struct Removed { where: ast::NodeId, what_path: MovePathIndex }
+impl RemoveNeedsDropArg for Removed {
+    fn node_id_removing_obligation(&self) -> ast::NodeId { self.where }
+    fn path_being_moved(&self) -> MovePathIndex { self.what_path }
+}
+impl<'a> RemoveNeedsDropArg for &'a Move {
+    fn node_id_removing_obligation(&self) -> ast::NodeId { self.id }
+    fn path_being_moved(&self) -> MovePathIndex { self.path }
 }
 
 impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {
@@ -555,16 +639,32 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {
                                  AssignDataFlowOperator,
                                  id_range,
                                  move_data.var_assignments.borrow().len());
-        move_data.add_gen_kills(tcx, &mut dfcx_moves, &mut dfcx_assign);
+        let mut dfcx_needs_drop =
+            DataFlowContext::new(tcx,
+                                 "flowed_move_data_needs_drop",
+                                 Some(decl),
+                                 cfg,
+                                 NeedsDropDataFlowOperator,
+                                 id_range,
+                                 move_data.paths.borrow().len());
+        move_data.add_gen_kills(tcx,
+                                &mut dfcx_moves,
+                                &mut dfcx_assign,
+                                &mut dfcx_needs_drop);
+
         dfcx_moves.add_kills_from_flow_exits(cfg);
         dfcx_assign.add_kills_from_flow_exits(cfg);
+        dfcx_needs_drop.add_kills_from_flow_exits(cfg);
+
         dfcx_moves.propagate(cfg, body);
         dfcx_assign.propagate(cfg, body);
+        dfcx_needs_drop.propagate(cfg, body);
 
         FlowedMoveData {
             move_data: move_data,
             dfcx_moves: dfcx_moves,
             dfcx_assign: dfcx_assign,
+            dfcx_needs_drop: dfcx_needs_drop,
         }
     }
 
@@ -732,3 +832,45 @@ impl DataFlowOperator for AssignDataFlowOperator {
         false // no assignments in scope by default
     }
 }
+
+impl BitwiseOperator for NeedsDropDataFlowOperator {
+    #[inline]
+    fn join(&self, succ: uint, pred: uint) -> uint {
+        // In principle, for correct code, the fixed-point solution
+        // to the dataflow equations will have succ == pred here.
+        //
+        // But since we need to deal with states before we hit the
+        // fixed point, we use logical-or here, to properly handle cases
+        // like a while loop:
+        //   `{ let a = box 3; while <cond> { <body> } <rest> }`
+        // where <cond> and <body> do not move or drop `a`:
+        //
+        //         [let a = box 3;]
+        //           |
+        //           v 1
+        //       [loopback] <--+ 5
+        //           |         |
+        //           v 2       |
+        //   +-----[cond]      |
+        //   |       |         |
+        //   |       v 4       |
+        //   |     [body] -----+
+        //   v 3
+        // [rest]
+        //
+        // we need to ensure that the fixed-point solution registers
+        // that `a` is needs-drop on all of the above edges.
+        // Logical-or will accomplish that here (while logical-and
+        // would cause the fixed point solution to falsely claim that
+        // `a` is only needs-drop on edge 1.
+
+        succ | pred
+    }
+}
+
+impl DataFlowOperator for NeedsDropDataFlowOperator {
+    #[inline]
+    fn initial_value(&self) -> bool {
+        false // paths uninitialized by default and thus do not need dropping
+    }
+}
diff --git a/src/librustc/middle/borrowck/needs_drop.rs b/src/librustc/middle/borrowck/needs_drop.rs
new file mode 100644
index 0000000..94f2de6
--- /dev/null
+++ b/src/librustc/middle/borrowck/needs_drop.rs
@@ -0,0 +1,169 @@
+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT
+// file at the top-level directory of this distribution and at
+// http://rust-lang.org/COPYRIGHT.
+//
+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
+// option. This file may not be copied, modified, or distributed
+// except according to those terms.
+
+/// Data structures for tracking which paths are scheduled for
+/// eventual dropping (as opposed to paths that has been moved, and
+/// thus the drop obligation has been shifted to the receiver of the
+/// move).
+///
+/// The goal is to identify control-flow join points where one
+/// predecessor node has a path that needs to be eventually dropped
+/// while that same path has been moved away on another predecessor
+/// node. Such join points will probably become illegal in the future
+/// (so that the set of dropped state is equivalent on all
+/// control-flow paths, and thus the drop-flag can be removed from
+/// droppable structures).
+
+use std::collections::{HashMap, HashSet};
+use middle::borrowck::*;
+use middle::cfg;
+use middle::dataflow::DataFlowContext;
+use middle::dataflow::BitwiseOperator;
+use middle::dataflow;
+use euv = middle::expr_use_visitor;
+use mc = middle::mem_categorization;
+use middle::ty;
+use syntax::ast;
+use syntax::ast_util;
+use syntax::codemap::Span;
+
+struct NeedsDropCtxt<'a> {
+    paths: uint,
+}
+
+impl<'a> euv::Delegate for NeedsDropCtxt<'a> {
+    // The value found at `cmt` is either copied or moved, depending
+    // on mode.
+    fn consume(&mut self,
+               consume_id: ast::NodeId,
+               consume_span: Span,
+               cmt: mc::cmt,
+               mode: euv::ConsumeMode) {
+        debug!("consume(consume_id={}, cmt={}, mode={})",
+               consume_id, cmt.repr(self.tcx()), mode);
+
+        unimplemented!()
+    }
+
+    // The value found at `cmt` is either copied or moved via the
+    // pattern binding `consume_pat`, depending on mode.
+    fn consume_pat(&mut self,
+                   consume_pat: &ast::Pat,
+                   cmt: mc::cmt,
+                   mode: euv::ConsumeMode) {
+        debug!("consume_pat(consume_pat={}, cmt={}, mode={})",
+               consume_pat.repr(self.tcx()),
+               cmt.repr(self.tcx()),
+               mode);
+
+        unimplemented!()
+    }
+
+    // The value found at `borrow` is being borrowed at the point
+    // `borrow_id` for the region `loan_region` with kind `bk`.
+    fn borrow(&mut self,
+              borrow_id: ast::NodeId,
+              borrow_span: Span,
+              cmt: mc::cmt,
+              loan_region: ty::Region,
+              bk: ty::BorrowKind,
+              loan_cause: euv::LoanCause) {
+        debug!("borrow(borrow_id={}, cmt={}, loan_region={}, \
+               bk={}, loan_cause={:?})",
+               borrow_id, cmt.repr(self.tcx()), loan_region,
+               bk, loan_cause);
+
+        unimplemented!()
+    }
+
+    // The local variable `id` is declared but not initialized.
+    fn decl_without_init(&mut self,
+                         id: ast::NodeId,
+                         span: Span) {
+        debug!("decl_without_init(id={})", id);
+
+        unimplemented!()
+    }
+
+    // The path at `cmt` is being assigned to.
+    fn mutate(&mut self,
+              assignment_id: ast::NodeId,
+              assignment_span: Span,
+              assignee_cmt: mc::cmt,
+              mode: euv::MutateMode) {
+        debug!("mutate(assignment_id={}, assignee_cmt={})",
+               assignment_id, assignee_cmt.repr(self.tcx()));
+
+        unimplemented!()
+    }
+}
+
+#[deriving(Clone)]
+pub struct Operator;
+
+pub type NeedsDropDataFlow<'a> = DataFlowContext<'a, Operator>;
+
+
+
+pub struct NeedsDropData<'a> {
+    pub dfcx: NeedsDropDataFlow<'a>,
+}
+
+impl<'a> NeedsDropData<'a> {
+    pub fn new(bccx: &mut BorrowckCtxt<'a>,
+               id_range: ast_util::IdRange,
+               decl: &ast::FnDecl,
+               cfg: &cfg::CFG,
+               body: &ast::Block) -> NeedsDropData<'a> {
+        debug!("needs_drop::check_control_paths(body id={:?})", body.id);
+
+        let mut ndcx = NeedsDropCtxt {
+            paths: 0,
+        };
+
+        {
+            let mut euv = euv::ExprUseVisitor::new(&mut ndcx, bccx.tcx);
+            euv.walk_fn(decl, body);
+        }
+
+        let len = ndcx.paths;
+
+        let mut dfcx =
+            DataFlowContext::new(bccx.tcx,
+                                 "needs_drop",
+                                 Some(decl),
+                                 cfg,
+                                 Operator,
+                                 id_range,
+                                 len);
+
+        NeedsDropData {
+            dfcx: dfcx,
+        }
+    }
+}
+
+impl dataflow::BitwiseOperator for Operator {
+    /// Joins two predecessor bits together, typically either `|` or `&`
+    fn join(&self, succ: uint, pred: uint) -> uint {
+        succ | pred
+    }
+}
+
+impl dataflow::DataFlowOperator for Operator {
+    /// Specifies the initial value for each bit in the `on_entry` set
+    fn initial_value(&self) -> bool {
+        // nothing needs to be dropped until it is initialized.
+        // E.g. `let x;` should be initialized as not needing to be
+        // dropped.  (Other things like function parameters are of
+        // course implicitly initialized and are handled accordingly.)
+        false
+    }
+}

commit 41d88df8f06da373cf1c06691d2ca56e791afaf5
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Sat Jul 26 12:37:48 2014 +0200

    revised control-flow-graph to indicate that we flow into heads of patterns
    before their subpatterns.
    
    This makes sense when you think about the flow of how one checks if
    patterns match.  Patterns are matched from top-down (while
    value-producing expressions are built from the bottom up).
    
    It also solves a problem for the dataflow of needsdrop.
---
 src/librustc/middle/cfg/construct.rs | 21 +++++++++------------
 1 file changed, 9 insertions(+), 12 deletions(-)

diff --git a/src/librustc/middle/cfg/construct.rs b/src/librustc/middle/cfg/construct.rs
index 6d5c4ce..3e076c9 100644
--- a/src/librustc/middle/cfg/construct.rs
+++ b/src/librustc/middle/cfg/construct.rs
@@ -148,31 +148,28 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {
             ast::PatBox(ref subpat) |
             ast::PatRegion(ref subpat) |
             ast::PatIdent(_, _, Some(ref subpat)) => {
-                let subpat_exit = self.pat(&**subpat, pred);
-                self.add_node(pat.id, [subpat_exit])
+                let pat_head_exit = self.add_node(pat.id, [pred]);
+                self.pat(&**subpat, pat_head_exit)
             }
 
             ast::PatEnum(_, Some(ref subpats)) |
             ast::PatTup(ref subpats) => {
-                let pats_exit =
-                    self.pats_all(subpats.iter().map(|p| p.clone()), pred);
-                self.add_node(pat.id, [pats_exit])
+                let pat_head_exit = self.add_node(pat.id, [pred]);
+                self.pats_all(subpats.iter().map(|p| p.clone()), pat_head_exit)
             }
 
             ast::PatStruct(_, ref subpats, _) => {
-                let pats_exit =
-                    self.pats_all(subpats.iter().map(|f| f.pat.clone()), pred);
-                self.add_node(pat.id, [pats_exit])
+                let pat_head_exit = self.add_node(pat.id, [pred]);
+                self.pats_all(subpats.iter().map(|f| f.pat.clone()), pat_head_exit)
             }
 
             ast::PatVec(ref pre, ref vec, ref post) => {
+                let pat_head_exit = self.add_node(pat.id, [pred]);
                 let pre_exit =
-                    self.pats_all(pre.iter().map(|p| *p), pred);
+                    self.pats_all(pre.iter().map(|p| *p), pat_head_exit);
                 let vec_exit =
                     self.pats_all(vec.iter().map(|p| *p), pre_exit);
-                let post_exit =
-                    self.pats_all(post.iter().map(|p| *p), vec_exit);
-                self.add_node(pat.id, [post_exit])
+                self.pats_all(post.iter().map(|p| *p), vec_exit)
             }
 
             ast::PatMac(_) => {

commit 1e7d7851283bdcb35d43f430c63ab22776ae7438
Author: Felix S. Klock II <pnkfelix@pnkfx.org>
Date:   Tue Jul 22 18:08:39 2014 +0200

    Added state tracking whether a given cfg node is reachable or not.
---
 src/librustc/middle/cfg/construct.rs | 29 ++++++++++++++++++++++++++++-
 src/librustc/middle/cfg/mod.rs       |  7 +++++++
 2 files changed, 35 insertions(+), 1 deletion(-)

diff --git a/src/librustc/middle/cfg/construct.rs b/src/librustc/middle/cfg/construct.rs
index ec414b8..6d5c4ce 100644
--- a/src/librustc/middle/cfg/construct.rs
+++ b/src/librustc/middle/cfg/construct.rs
@@ -17,6 +17,7 @@ use syntax::ast;
 use syntax::ast_util;
 use util::nodemap::NodeMap;
 
+use std::collections::bitv::Bitv;
 use std::gc::Gc;
 
 struct CFGBuilder<'a, 'tcx: 'a> {
@@ -55,10 +56,36 @@ pub fn construct(tcx: &ty::ctxt,
     block_exit = cfg_builder.block(blk, entry);
     cfg_builder.add_contained_edge(block_exit, fn_exit);
     let CFGBuilder {exit_map, graph, ..} = cfg_builder;
+
+    let mut reachable = Bitv::with_capacity(graph.all_nodes().len(), false);
+    mark_reachable(&graph, entry, &mut reachable);
     CFG {exit_map: exit_map,
          graph: graph,
          entry: entry,
-         exit: fn_exit}
+         exit: fn_exit,
+         reachable: reachable}
+}
+
+fn mark_reachable(graph: &CFGGraph,
+                  entry: CFGIndex,
+                  reachable: &mut Bitv) {
+    let mut stack = vec![];
+    stack.push(entry);
+    loop {
+        let n = match stack.pop() {
+            None => return,
+            Some(n) => n,
+        };
+
+        reachable.set(n.node_id(), true);
+        graph.each_outgoing_edge(n, |_edge_index, edge| {
+            let target = edge.target();
+            if !reachable.get(target.node_id()) {
+                stack.push(target);
+            }
+            true
+        });
+    }
 }
 
 fn add_initial_dummy_node(g: &mut CFGGraph) -> CFGIndex {
diff --git a/src/librustc/middle/cfg/mod.rs b/src/librustc/middle/cfg/mod.rs
index bb758ec..e3f88c7 100644
--- a/src/librustc/middle/cfg/mod.rs
+++ b/src/librustc/middle/cfg/mod.rs
@@ -20,6 +20,8 @@ use middle::ty;
 use syntax::ast;
 use util::nodemap::NodeMap;
 
+use std::collections::bitv::Bitv;
+
 mod construct;
 pub mod graphviz;
 
@@ -28,6 +30,7 @@ pub struct CFG {
     pub graph: CFGGraph,
     pub entry: CFGIndex,
     pub exit: CFGIndex,
+    pub reachable: Bitv,
 }
 
 pub struct CFGNodeData {
@@ -51,4 +54,8 @@ impl CFG {
                blk: &ast::Block) -> CFG {
         construct::construct(tcx, blk)
     }
+
+    pub fn is_reachable(&self, cfg_index: CFGIndex) -> bool {
+        self.reachable.get(cfg_index.node_id())
+    }
 }
